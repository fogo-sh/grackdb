// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/fogo-sh/grackdb/ent/discordaccount"
	"github.com/fogo-sh/grackdb/ent/discordbot"
	"github.com/fogo-sh/grackdb/ent/githubaccount"
	"github.com/fogo-sh/grackdb/ent/githuborganization"
	"github.com/fogo-sh/grackdb/ent/githuborganizationmember"
	"github.com/fogo-sh/grackdb/ent/predicate"
	"github.com/fogo-sh/grackdb/ent/project"
	"github.com/fogo-sh/grackdb/ent/projectassociation"
	"github.com/fogo-sh/grackdb/ent/projectcontributor"
	"github.com/fogo-sh/grackdb/ent/repository"
	"github.com/fogo-sh/grackdb/ent/site"
	"github.com/fogo-sh/grackdb/ent/technology"
	"github.com/fogo-sh/grackdb/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDiscordAccount           = "DiscordAccount"
	TypeDiscordBot               = "DiscordBot"
	TypeGithubAccount            = "GithubAccount"
	TypeGithubOrganization       = "GithubOrganization"
	TypeGithubOrganizationMember = "GithubOrganizationMember"
	TypeProject                  = "Project"
	TypeProjectAssociation       = "ProjectAssociation"
	TypeProjectContributor       = "ProjectContributor"
	TypeRepository               = "Repository"
	TypeSite                     = "Site"
	TypeTechnology               = "Technology"
	TypeUser                     = "User"
)

// DiscordAccountMutation represents an operation that mutates the DiscordAccount nodes in the graph.
type DiscordAccountMutation struct {
	config
	op            Op
	typ           string
	id            *int
	discord_id    *string
	username      *string
	discriminator *string
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	bot           *int
	clearedbot    bool
	done          bool
	oldValue      func(context.Context) (*DiscordAccount, error)
	predicates    []predicate.DiscordAccount
}

var _ ent.Mutation = (*DiscordAccountMutation)(nil)

// discordaccountOption allows management of the mutation configuration using functional options.
type discordaccountOption func(*DiscordAccountMutation)

// newDiscordAccountMutation creates new mutation for the DiscordAccount entity.
func newDiscordAccountMutation(c config, op Op, opts ...discordaccountOption) *DiscordAccountMutation {
	m := &DiscordAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeDiscordAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiscordAccountID sets the ID field of the mutation.
func withDiscordAccountID(id int) discordaccountOption {
	return func(m *DiscordAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *DiscordAccount
		)
		m.oldValue = func(ctx context.Context) (*DiscordAccount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DiscordAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiscordAccount sets the old DiscordAccount of the mutation.
func withDiscordAccount(node *DiscordAccount) discordaccountOption {
	return func(m *DiscordAccountMutation) {
		m.oldValue = func(context.Context) (*DiscordAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiscordAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiscordAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiscordAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDiscordID sets the "discord_id" field.
func (m *DiscordAccountMutation) SetDiscordID(s string) {
	m.discord_id = &s
}

// DiscordID returns the value of the "discord_id" field in the mutation.
func (m *DiscordAccountMutation) DiscordID() (r string, exists bool) {
	v := m.discord_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscordID returns the old "discord_id" field's value of the DiscordAccount entity.
// If the DiscordAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscordAccountMutation) OldDiscordID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscordID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscordID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscordID: %w", err)
	}
	return oldValue.DiscordID, nil
}

// ResetDiscordID resets all changes to the "discord_id" field.
func (m *DiscordAccountMutation) ResetDiscordID() {
	m.discord_id = nil
}

// SetUsername sets the "username" field.
func (m *DiscordAccountMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *DiscordAccountMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the DiscordAccount entity.
// If the DiscordAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscordAccountMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *DiscordAccountMutation) ResetUsername() {
	m.username = nil
}

// SetDiscriminator sets the "discriminator" field.
func (m *DiscordAccountMutation) SetDiscriminator(s string) {
	m.discriminator = &s
}

// Discriminator returns the value of the "discriminator" field in the mutation.
func (m *DiscordAccountMutation) Discriminator() (r string, exists bool) {
	v := m.discriminator
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscriminator returns the old "discriminator" field's value of the DiscordAccount entity.
// If the DiscordAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscordAccountMutation) OldDiscriminator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscriminator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscriminator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscriminator: %w", err)
	}
	return oldValue.Discriminator, nil
}

// ResetDiscriminator resets all changes to the "discriminator" field.
func (m *DiscordAccountMutation) ResetDiscriminator() {
	m.discriminator = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *DiscordAccountMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *DiscordAccountMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *DiscordAccountMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *DiscordAccountMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *DiscordAccountMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *DiscordAccountMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetBotID sets the "bot" edge to the DiscordBot entity by id.
func (m *DiscordAccountMutation) SetBotID(id int) {
	m.bot = &id
}

// ClearBot clears the "bot" edge to the DiscordBot entity.
func (m *DiscordAccountMutation) ClearBot() {
	m.clearedbot = true
}

// BotCleared reports if the "bot" edge to the DiscordBot entity was cleared.
func (m *DiscordAccountMutation) BotCleared() bool {
	return m.clearedbot
}

// BotID returns the "bot" edge ID in the mutation.
func (m *DiscordAccountMutation) BotID() (id int, exists bool) {
	if m.bot != nil {
		return *m.bot, true
	}
	return
}

// BotIDs returns the "bot" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BotID instead. It exists only for internal usage by the builders.
func (m *DiscordAccountMutation) BotIDs() (ids []int) {
	if id := m.bot; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBot resets all changes to the "bot" edge.
func (m *DiscordAccountMutation) ResetBot() {
	m.bot = nil
	m.clearedbot = false
}

// Op returns the operation name.
func (m *DiscordAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DiscordAccount).
func (m *DiscordAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiscordAccountMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.discord_id != nil {
		fields = append(fields, discordaccount.FieldDiscordID)
	}
	if m.username != nil {
		fields = append(fields, discordaccount.FieldUsername)
	}
	if m.discriminator != nil {
		fields = append(fields, discordaccount.FieldDiscriminator)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiscordAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case discordaccount.FieldDiscordID:
		return m.DiscordID()
	case discordaccount.FieldUsername:
		return m.Username()
	case discordaccount.FieldDiscriminator:
		return m.Discriminator()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiscordAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case discordaccount.FieldDiscordID:
		return m.OldDiscordID(ctx)
	case discordaccount.FieldUsername:
		return m.OldUsername(ctx)
	case discordaccount.FieldDiscriminator:
		return m.OldDiscriminator(ctx)
	}
	return nil, fmt.Errorf("unknown DiscordAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscordAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case discordaccount.FieldDiscordID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscordID(v)
		return nil
	case discordaccount.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case discordaccount.FieldDiscriminator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscriminator(v)
		return nil
	}
	return fmt.Errorf("unknown DiscordAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiscordAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiscordAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscordAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DiscordAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiscordAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiscordAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiscordAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DiscordAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiscordAccountMutation) ResetField(name string) error {
	switch name {
	case discordaccount.FieldDiscordID:
		m.ResetDiscordID()
		return nil
	case discordaccount.FieldUsername:
		m.ResetUsername()
		return nil
	case discordaccount.FieldDiscriminator:
		m.ResetDiscriminator()
		return nil
	}
	return fmt.Errorf("unknown DiscordAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiscordAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, discordaccount.EdgeOwner)
	}
	if m.bot != nil {
		edges = append(edges, discordaccount.EdgeBot)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiscordAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case discordaccount.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case discordaccount.EdgeBot:
		if id := m.bot; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiscordAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiscordAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiscordAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, discordaccount.EdgeOwner)
	}
	if m.clearedbot {
		edges = append(edges, discordaccount.EdgeBot)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiscordAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case discordaccount.EdgeOwner:
		return m.clearedowner
	case discordaccount.EdgeBot:
		return m.clearedbot
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiscordAccountMutation) ClearEdge(name string) error {
	switch name {
	case discordaccount.EdgeOwner:
		m.ClearOwner()
		return nil
	case discordaccount.EdgeBot:
		m.ClearBot()
		return nil
	}
	return fmt.Errorf("unknown DiscordAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiscordAccountMutation) ResetEdge(name string) error {
	switch name {
	case discordaccount.EdgeOwner:
		m.ResetOwner()
		return nil
	case discordaccount.EdgeBot:
		m.ResetBot()
		return nil
	}
	return fmt.Errorf("unknown DiscordAccount edge %s", name)
}

// DiscordBotMutation represents an operation that mutates the DiscordBot nodes in the graph.
type DiscordBotMutation struct {
	config
	op                Op
	typ               string
	id                *int
	clearedFields     map[string]struct{}
	account           *int
	clearedaccount    bool
	project           *int
	clearedproject    bool
	repository        *int
	clearedrepository bool
	done              bool
	oldValue          func(context.Context) (*DiscordBot, error)
	predicates        []predicate.DiscordBot
}

var _ ent.Mutation = (*DiscordBotMutation)(nil)

// discordbotOption allows management of the mutation configuration using functional options.
type discordbotOption func(*DiscordBotMutation)

// newDiscordBotMutation creates new mutation for the DiscordBot entity.
func newDiscordBotMutation(c config, op Op, opts ...discordbotOption) *DiscordBotMutation {
	m := &DiscordBotMutation{
		config:        c,
		op:            op,
		typ:           TypeDiscordBot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiscordBotID sets the ID field of the mutation.
func withDiscordBotID(id int) discordbotOption {
	return func(m *DiscordBotMutation) {
		var (
			err   error
			once  sync.Once
			value *DiscordBot
		)
		m.oldValue = func(ctx context.Context) (*DiscordBot, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DiscordBot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiscordBot sets the old DiscordBot of the mutation.
func withDiscordBot(node *DiscordBot) discordbotOption {
	return func(m *DiscordBotMutation) {
		m.oldValue = func(context.Context) (*DiscordBot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiscordBotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiscordBotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiscordBotMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAccountID sets the "account" edge to the DiscordAccount entity by id.
func (m *DiscordBotMutation) SetAccountID(id int) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the DiscordAccount entity.
func (m *DiscordBotMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the DiscordAccount entity was cleared.
func (m *DiscordBotMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *DiscordBotMutation) AccountID() (id int, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *DiscordBotMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *DiscordBotMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *DiscordBotMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *DiscordBotMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *DiscordBotMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *DiscordBotMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *DiscordBotMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *DiscordBotMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetRepositoryID sets the "repository" edge to the Repository entity by id.
func (m *DiscordBotMutation) SetRepositoryID(id int) {
	m.repository = &id
}

// ClearRepository clears the "repository" edge to the Repository entity.
func (m *DiscordBotMutation) ClearRepository() {
	m.clearedrepository = true
}

// RepositoryCleared reports if the "repository" edge to the Repository entity was cleared.
func (m *DiscordBotMutation) RepositoryCleared() bool {
	return m.clearedrepository
}

// RepositoryID returns the "repository" edge ID in the mutation.
func (m *DiscordBotMutation) RepositoryID() (id int, exists bool) {
	if m.repository != nil {
		return *m.repository, true
	}
	return
}

// RepositoryIDs returns the "repository" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepositoryID instead. It exists only for internal usage by the builders.
func (m *DiscordBotMutation) RepositoryIDs() (ids []int) {
	if id := m.repository; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepository resets all changes to the "repository" edge.
func (m *DiscordBotMutation) ResetRepository() {
	m.repository = nil
	m.clearedrepository = false
}

// Op returns the operation name.
func (m *DiscordBotMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DiscordBot).
func (m *DiscordBotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiscordBotMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiscordBotMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiscordBotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown DiscordBot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscordBotMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DiscordBot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiscordBotMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiscordBotMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscordBotMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown DiscordBot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiscordBotMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiscordBotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiscordBotMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DiscordBot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiscordBotMutation) ResetField(name string) error {
	return fmt.Errorf("unknown DiscordBot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiscordBotMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.account != nil {
		edges = append(edges, discordbot.EdgeAccount)
	}
	if m.project != nil {
		edges = append(edges, discordbot.EdgeProject)
	}
	if m.repository != nil {
		edges = append(edges, discordbot.EdgeRepository)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiscordBotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case discordbot.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case discordbot.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case discordbot.EdgeRepository:
		if id := m.repository; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiscordBotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiscordBotMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiscordBotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedaccount {
		edges = append(edges, discordbot.EdgeAccount)
	}
	if m.clearedproject {
		edges = append(edges, discordbot.EdgeProject)
	}
	if m.clearedrepository {
		edges = append(edges, discordbot.EdgeRepository)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiscordBotMutation) EdgeCleared(name string) bool {
	switch name {
	case discordbot.EdgeAccount:
		return m.clearedaccount
	case discordbot.EdgeProject:
		return m.clearedproject
	case discordbot.EdgeRepository:
		return m.clearedrepository
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiscordBotMutation) ClearEdge(name string) error {
	switch name {
	case discordbot.EdgeAccount:
		m.ClearAccount()
		return nil
	case discordbot.EdgeProject:
		m.ClearProject()
		return nil
	case discordbot.EdgeRepository:
		m.ClearRepository()
		return nil
	}
	return fmt.Errorf("unknown DiscordBot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiscordBotMutation) ResetEdge(name string) error {
	switch name {
	case discordbot.EdgeAccount:
		m.ResetAccount()
		return nil
	case discordbot.EdgeProject:
		m.ResetProject()
		return nil
	case discordbot.EdgeRepository:
		m.ResetRepository()
		return nil
	}
	return fmt.Errorf("unknown DiscordBot edge %s", name)
}

// GithubAccountMutation represents an operation that mutates the GithubAccount nodes in the graph.
type GithubAccountMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	username                        *string
	clearedFields                   map[string]struct{}
	owner                           *int
	clearedowner                    bool
	organization_memberships        map[int]struct{}
	removedorganization_memberships map[int]struct{}
	clearedorganization_memberships bool
	repositories                    map[int]struct{}
	removedrepositories             map[int]struct{}
	clearedrepositories             bool
	done                            bool
	oldValue                        func(context.Context) (*GithubAccount, error)
	predicates                      []predicate.GithubAccount
}

var _ ent.Mutation = (*GithubAccountMutation)(nil)

// githubaccountOption allows management of the mutation configuration using functional options.
type githubaccountOption func(*GithubAccountMutation)

// newGithubAccountMutation creates new mutation for the GithubAccount entity.
func newGithubAccountMutation(c config, op Op, opts ...githubaccountOption) *GithubAccountMutation {
	m := &GithubAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeGithubAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGithubAccountID sets the ID field of the mutation.
func withGithubAccountID(id int) githubaccountOption {
	return func(m *GithubAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *GithubAccount
		)
		m.oldValue = func(ctx context.Context) (*GithubAccount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GithubAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGithubAccount sets the old GithubAccount of the mutation.
func withGithubAccount(node *GithubAccount) githubaccountOption {
	return func(m *GithubAccountMutation) {
		m.oldValue = func(context.Context) (*GithubAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GithubAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GithubAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GithubAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUsername sets the "username" field.
func (m *GithubAccountMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *GithubAccountMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the GithubAccount entity.
// If the GithubAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubAccountMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *GithubAccountMutation) ResetUsername() {
	m.username = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *GithubAccountMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *GithubAccountMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *GithubAccountMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *GithubAccountMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *GithubAccountMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *GithubAccountMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddOrganizationMembershipIDs adds the "organization_memberships" edge to the GithubOrganizationMember entity by ids.
func (m *GithubAccountMutation) AddOrganizationMembershipIDs(ids ...int) {
	if m.organization_memberships == nil {
		m.organization_memberships = make(map[int]struct{})
	}
	for i := range ids {
		m.organization_memberships[ids[i]] = struct{}{}
	}
}

// ClearOrganizationMemberships clears the "organization_memberships" edge to the GithubOrganizationMember entity.
func (m *GithubAccountMutation) ClearOrganizationMemberships() {
	m.clearedorganization_memberships = true
}

// OrganizationMembershipsCleared reports if the "organization_memberships" edge to the GithubOrganizationMember entity was cleared.
func (m *GithubAccountMutation) OrganizationMembershipsCleared() bool {
	return m.clearedorganization_memberships
}

// RemoveOrganizationMembershipIDs removes the "organization_memberships" edge to the GithubOrganizationMember entity by IDs.
func (m *GithubAccountMutation) RemoveOrganizationMembershipIDs(ids ...int) {
	if m.removedorganization_memberships == nil {
		m.removedorganization_memberships = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.organization_memberships, ids[i])
		m.removedorganization_memberships[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationMemberships returns the removed IDs of the "organization_memberships" edge to the GithubOrganizationMember entity.
func (m *GithubAccountMutation) RemovedOrganizationMembershipsIDs() (ids []int) {
	for id := range m.removedorganization_memberships {
		ids = append(ids, id)
	}
	return
}

// OrganizationMembershipsIDs returns the "organization_memberships" edge IDs in the mutation.
func (m *GithubAccountMutation) OrganizationMembershipsIDs() (ids []int) {
	for id := range m.organization_memberships {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationMemberships resets all changes to the "organization_memberships" edge.
func (m *GithubAccountMutation) ResetOrganizationMemberships() {
	m.organization_memberships = nil
	m.clearedorganization_memberships = false
	m.removedorganization_memberships = nil
}

// AddRepositoryIDs adds the "repositories" edge to the Repository entity by ids.
func (m *GithubAccountMutation) AddRepositoryIDs(ids ...int) {
	if m.repositories == nil {
		m.repositories = make(map[int]struct{})
	}
	for i := range ids {
		m.repositories[ids[i]] = struct{}{}
	}
}

// ClearRepositories clears the "repositories" edge to the Repository entity.
func (m *GithubAccountMutation) ClearRepositories() {
	m.clearedrepositories = true
}

// RepositoriesCleared reports if the "repositories" edge to the Repository entity was cleared.
func (m *GithubAccountMutation) RepositoriesCleared() bool {
	return m.clearedrepositories
}

// RemoveRepositoryIDs removes the "repositories" edge to the Repository entity by IDs.
func (m *GithubAccountMutation) RemoveRepositoryIDs(ids ...int) {
	if m.removedrepositories == nil {
		m.removedrepositories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.repositories, ids[i])
		m.removedrepositories[ids[i]] = struct{}{}
	}
}

// RemovedRepositories returns the removed IDs of the "repositories" edge to the Repository entity.
func (m *GithubAccountMutation) RemovedRepositoriesIDs() (ids []int) {
	for id := range m.removedrepositories {
		ids = append(ids, id)
	}
	return
}

// RepositoriesIDs returns the "repositories" edge IDs in the mutation.
func (m *GithubAccountMutation) RepositoriesIDs() (ids []int) {
	for id := range m.repositories {
		ids = append(ids, id)
	}
	return
}

// ResetRepositories resets all changes to the "repositories" edge.
func (m *GithubAccountMutation) ResetRepositories() {
	m.repositories = nil
	m.clearedrepositories = false
	m.removedrepositories = nil
}

// Op returns the operation name.
func (m *GithubAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GithubAccount).
func (m *GithubAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GithubAccountMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.username != nil {
		fields = append(fields, githubaccount.FieldUsername)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GithubAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case githubaccount.FieldUsername:
		return m.Username()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GithubAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case githubaccount.FieldUsername:
		return m.OldUsername(ctx)
	}
	return nil, fmt.Errorf("unknown GithubAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GithubAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case githubaccount.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	}
	return fmt.Errorf("unknown GithubAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GithubAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GithubAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GithubAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GithubAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GithubAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GithubAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GithubAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GithubAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GithubAccountMutation) ResetField(name string) error {
	switch name {
	case githubaccount.FieldUsername:
		m.ResetUsername()
		return nil
	}
	return fmt.Errorf("unknown GithubAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GithubAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, githubaccount.EdgeOwner)
	}
	if m.organization_memberships != nil {
		edges = append(edges, githubaccount.EdgeOrganizationMemberships)
	}
	if m.repositories != nil {
		edges = append(edges, githubaccount.EdgeRepositories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GithubAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case githubaccount.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case githubaccount.EdgeOrganizationMemberships:
		ids := make([]ent.Value, 0, len(m.organization_memberships))
		for id := range m.organization_memberships {
			ids = append(ids, id)
		}
		return ids
	case githubaccount.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m.repositories))
		for id := range m.repositories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GithubAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedorganization_memberships != nil {
		edges = append(edges, githubaccount.EdgeOrganizationMemberships)
	}
	if m.removedrepositories != nil {
		edges = append(edges, githubaccount.EdgeRepositories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GithubAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case githubaccount.EdgeOrganizationMemberships:
		ids := make([]ent.Value, 0, len(m.removedorganization_memberships))
		for id := range m.removedorganization_memberships {
			ids = append(ids, id)
		}
		return ids
	case githubaccount.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m.removedrepositories))
		for id := range m.removedrepositories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GithubAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, githubaccount.EdgeOwner)
	}
	if m.clearedorganization_memberships {
		edges = append(edges, githubaccount.EdgeOrganizationMemberships)
	}
	if m.clearedrepositories {
		edges = append(edges, githubaccount.EdgeRepositories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GithubAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case githubaccount.EdgeOwner:
		return m.clearedowner
	case githubaccount.EdgeOrganizationMemberships:
		return m.clearedorganization_memberships
	case githubaccount.EdgeRepositories:
		return m.clearedrepositories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GithubAccountMutation) ClearEdge(name string) error {
	switch name {
	case githubaccount.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown GithubAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GithubAccountMutation) ResetEdge(name string) error {
	switch name {
	case githubaccount.EdgeOwner:
		m.ResetOwner()
		return nil
	case githubaccount.EdgeOrganizationMemberships:
		m.ResetOrganizationMemberships()
		return nil
	case githubaccount.EdgeRepositories:
		m.ResetRepositories()
		return nil
	}
	return fmt.Errorf("unknown GithubAccount edge %s", name)
}

// GithubOrganizationMutation represents an operation that mutates the GithubOrganization nodes in the graph.
type GithubOrganizationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	display_name        *string
	clearedFields       map[string]struct{}
	members             map[int]struct{}
	removedmembers      map[int]struct{}
	clearedmembers      bool
	repositories        map[int]struct{}
	removedrepositories map[int]struct{}
	clearedrepositories bool
	done                bool
	oldValue            func(context.Context) (*GithubOrganization, error)
	predicates          []predicate.GithubOrganization
}

var _ ent.Mutation = (*GithubOrganizationMutation)(nil)

// githuborganizationOption allows management of the mutation configuration using functional options.
type githuborganizationOption func(*GithubOrganizationMutation)

// newGithubOrganizationMutation creates new mutation for the GithubOrganization entity.
func newGithubOrganizationMutation(c config, op Op, opts ...githuborganizationOption) *GithubOrganizationMutation {
	m := &GithubOrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeGithubOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGithubOrganizationID sets the ID field of the mutation.
func withGithubOrganizationID(id int) githuborganizationOption {
	return func(m *GithubOrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *GithubOrganization
		)
		m.oldValue = func(ctx context.Context) (*GithubOrganization, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GithubOrganization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGithubOrganization sets the old GithubOrganization of the mutation.
func withGithubOrganization(node *GithubOrganization) githuborganizationOption {
	return func(m *GithubOrganizationMutation) {
		m.oldValue = func(context.Context) (*GithubOrganization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GithubOrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GithubOrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GithubOrganizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *GithubOrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GithubOrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GithubOrganization entity.
// If the GithubOrganization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubOrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GithubOrganizationMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *GithubOrganizationMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *GithubOrganizationMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the GithubOrganization entity.
// If the GithubOrganization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubOrganizationMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *GithubOrganizationMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[githuborganization.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *GithubOrganizationMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[githuborganization.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *GithubOrganizationMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, githuborganization.FieldDisplayName)
}

// AddMemberIDs adds the "members" edge to the GithubOrganizationMember entity by ids.
func (m *GithubOrganizationMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the GithubOrganizationMember entity.
func (m *GithubOrganizationMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the GithubOrganizationMember entity was cleared.
func (m *GithubOrganizationMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the GithubOrganizationMember entity by IDs.
func (m *GithubOrganizationMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the GithubOrganizationMember entity.
func (m *GithubOrganizationMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *GithubOrganizationMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *GithubOrganizationMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddRepositoryIDs adds the "repositories" edge to the Repository entity by ids.
func (m *GithubOrganizationMutation) AddRepositoryIDs(ids ...int) {
	if m.repositories == nil {
		m.repositories = make(map[int]struct{})
	}
	for i := range ids {
		m.repositories[ids[i]] = struct{}{}
	}
}

// ClearRepositories clears the "repositories" edge to the Repository entity.
func (m *GithubOrganizationMutation) ClearRepositories() {
	m.clearedrepositories = true
}

// RepositoriesCleared reports if the "repositories" edge to the Repository entity was cleared.
func (m *GithubOrganizationMutation) RepositoriesCleared() bool {
	return m.clearedrepositories
}

// RemoveRepositoryIDs removes the "repositories" edge to the Repository entity by IDs.
func (m *GithubOrganizationMutation) RemoveRepositoryIDs(ids ...int) {
	if m.removedrepositories == nil {
		m.removedrepositories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.repositories, ids[i])
		m.removedrepositories[ids[i]] = struct{}{}
	}
}

// RemovedRepositories returns the removed IDs of the "repositories" edge to the Repository entity.
func (m *GithubOrganizationMutation) RemovedRepositoriesIDs() (ids []int) {
	for id := range m.removedrepositories {
		ids = append(ids, id)
	}
	return
}

// RepositoriesIDs returns the "repositories" edge IDs in the mutation.
func (m *GithubOrganizationMutation) RepositoriesIDs() (ids []int) {
	for id := range m.repositories {
		ids = append(ids, id)
	}
	return
}

// ResetRepositories resets all changes to the "repositories" edge.
func (m *GithubOrganizationMutation) ResetRepositories() {
	m.repositories = nil
	m.clearedrepositories = false
	m.removedrepositories = nil
}

// Op returns the operation name.
func (m *GithubOrganizationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GithubOrganization).
func (m *GithubOrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GithubOrganizationMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, githuborganization.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, githuborganization.FieldDisplayName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GithubOrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case githuborganization.FieldName:
		return m.Name()
	case githuborganization.FieldDisplayName:
		return m.DisplayName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GithubOrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case githuborganization.FieldName:
		return m.OldName(ctx)
	case githuborganization.FieldDisplayName:
		return m.OldDisplayName(ctx)
	}
	return nil, fmt.Errorf("unknown GithubOrganization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GithubOrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case githuborganization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case githuborganization.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	}
	return fmt.Errorf("unknown GithubOrganization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GithubOrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GithubOrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GithubOrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GithubOrganization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GithubOrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(githuborganization.FieldDisplayName) {
		fields = append(fields, githuborganization.FieldDisplayName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GithubOrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GithubOrganizationMutation) ClearField(name string) error {
	switch name {
	case githuborganization.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	}
	return fmt.Errorf("unknown GithubOrganization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GithubOrganizationMutation) ResetField(name string) error {
	switch name {
	case githuborganization.FieldName:
		m.ResetName()
		return nil
	case githuborganization.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	}
	return fmt.Errorf("unknown GithubOrganization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GithubOrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.members != nil {
		edges = append(edges, githuborganization.EdgeMembers)
	}
	if m.repositories != nil {
		edges = append(edges, githuborganization.EdgeRepositories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GithubOrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case githuborganization.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case githuborganization.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m.repositories))
		for id := range m.repositories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GithubOrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmembers != nil {
		edges = append(edges, githuborganization.EdgeMembers)
	}
	if m.removedrepositories != nil {
		edges = append(edges, githuborganization.EdgeRepositories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GithubOrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case githuborganization.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case githuborganization.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m.removedrepositories))
		for id := range m.removedrepositories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GithubOrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmembers {
		edges = append(edges, githuborganization.EdgeMembers)
	}
	if m.clearedrepositories {
		edges = append(edges, githuborganization.EdgeRepositories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GithubOrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case githuborganization.EdgeMembers:
		return m.clearedmembers
	case githuborganization.EdgeRepositories:
		return m.clearedrepositories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GithubOrganizationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GithubOrganization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GithubOrganizationMutation) ResetEdge(name string) error {
	switch name {
	case githuborganization.EdgeMembers:
		m.ResetMembers()
		return nil
	case githuborganization.EdgeRepositories:
		m.ResetRepositories()
		return nil
	}
	return fmt.Errorf("unknown GithubOrganization edge %s", name)
}

// GithubOrganizationMemberMutation represents an operation that mutates the GithubOrganizationMember nodes in the graph.
type GithubOrganizationMemberMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	role                *githuborganizationmember.Role
	clearedFields       map[string]struct{}
	organization        *int
	clearedorganization bool
	account             *int
	clearedaccount      bool
	done                bool
	oldValue            func(context.Context) (*GithubOrganizationMember, error)
	predicates          []predicate.GithubOrganizationMember
}

var _ ent.Mutation = (*GithubOrganizationMemberMutation)(nil)

// githuborganizationmemberOption allows management of the mutation configuration using functional options.
type githuborganizationmemberOption func(*GithubOrganizationMemberMutation)

// newGithubOrganizationMemberMutation creates new mutation for the GithubOrganizationMember entity.
func newGithubOrganizationMemberMutation(c config, op Op, opts ...githuborganizationmemberOption) *GithubOrganizationMemberMutation {
	m := &GithubOrganizationMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeGithubOrganizationMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGithubOrganizationMemberID sets the ID field of the mutation.
func withGithubOrganizationMemberID(id int) githuborganizationmemberOption {
	return func(m *GithubOrganizationMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *GithubOrganizationMember
		)
		m.oldValue = func(ctx context.Context) (*GithubOrganizationMember, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GithubOrganizationMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGithubOrganizationMember sets the old GithubOrganizationMember of the mutation.
func withGithubOrganizationMember(node *GithubOrganizationMember) githuborganizationmemberOption {
	return func(m *GithubOrganizationMemberMutation) {
		m.oldValue = func(context.Context) (*GithubOrganizationMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GithubOrganizationMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GithubOrganizationMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GithubOrganizationMemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRole sets the "role" field.
func (m *GithubOrganizationMemberMutation) SetRole(gi githuborganizationmember.Role) {
	m.role = &gi
}

// Role returns the value of the "role" field in the mutation.
func (m *GithubOrganizationMemberMutation) Role() (r githuborganizationmember.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the GithubOrganizationMember entity.
// If the GithubOrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GithubOrganizationMemberMutation) OldRole(ctx context.Context) (v githuborganizationmember.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *GithubOrganizationMemberMutation) ResetRole() {
	m.role = nil
}

// SetOrganizationID sets the "organization" edge to the GithubOrganization entity by id.
func (m *GithubOrganizationMemberMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the GithubOrganization entity.
func (m *GithubOrganizationMemberMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the GithubOrganization entity was cleared.
func (m *GithubOrganizationMemberMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *GithubOrganizationMemberMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *GithubOrganizationMemberMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *GithubOrganizationMemberMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetAccountID sets the "account" edge to the GithubAccount entity by id.
func (m *GithubOrganizationMemberMutation) SetAccountID(id int) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the GithubAccount entity.
func (m *GithubOrganizationMemberMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the GithubAccount entity was cleared.
func (m *GithubOrganizationMemberMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *GithubOrganizationMemberMutation) AccountID() (id int, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *GithubOrganizationMemberMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *GithubOrganizationMemberMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Op returns the operation name.
func (m *GithubOrganizationMemberMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GithubOrganizationMember).
func (m *GithubOrganizationMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GithubOrganizationMemberMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.role != nil {
		fields = append(fields, githuborganizationmember.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GithubOrganizationMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case githuborganizationmember.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GithubOrganizationMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case githuborganizationmember.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown GithubOrganizationMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GithubOrganizationMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case githuborganizationmember.FieldRole:
		v, ok := value.(githuborganizationmember.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown GithubOrganizationMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GithubOrganizationMemberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GithubOrganizationMemberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GithubOrganizationMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GithubOrganizationMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GithubOrganizationMemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GithubOrganizationMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GithubOrganizationMemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GithubOrganizationMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GithubOrganizationMemberMutation) ResetField(name string) error {
	switch name {
	case githuborganizationmember.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown GithubOrganizationMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GithubOrganizationMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, githuborganizationmember.EdgeOrganization)
	}
	if m.account != nil {
		edges = append(edges, githuborganizationmember.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GithubOrganizationMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case githuborganizationmember.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case githuborganizationmember.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GithubOrganizationMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GithubOrganizationMemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GithubOrganizationMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, githuborganizationmember.EdgeOrganization)
	}
	if m.clearedaccount {
		edges = append(edges, githuborganizationmember.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GithubOrganizationMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case githuborganizationmember.EdgeOrganization:
		return m.clearedorganization
	case githuborganizationmember.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GithubOrganizationMemberMutation) ClearEdge(name string) error {
	switch name {
	case githuborganizationmember.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case githuborganizationmember.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown GithubOrganizationMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GithubOrganizationMemberMutation) ResetEdge(name string) error {
	switch name {
	case githuborganizationmember.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case githuborganizationmember.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown GithubOrganizationMember edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	name                   *string
	description            *string
	start_date             *time.Time
	end_date               *time.Time
	clearedFields          map[string]struct{}
	contributors           map[int]struct{}
	removedcontributors    map[int]struct{}
	clearedcontributors    bool
	parent_projects        map[int]struct{}
	removedparent_projects map[int]struct{}
	clearedparent_projects bool
	child_projects         map[int]struct{}
	removedchild_projects  map[int]struct{}
	clearedchild_projects  bool
	repositories           map[int]struct{}
	removedrepositories    map[int]struct{}
	clearedrepositories    bool
	discord_bots           map[int]struct{}
	removeddiscord_bots    map[int]struct{}
	cleareddiscord_bots    bool
	sites                  map[int]struct{}
	removedsites           map[int]struct{}
	clearedsites           bool
	done                   bool
	oldValue               func(context.Context) (*Project, error)
	predicates             []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[project.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[project.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, project.FieldDescription)
}

// SetStartDate sets the "start_date" field.
func (m *ProjectMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ProjectMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ProjectMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *ProjectMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ProjectMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ProjectMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[project.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ProjectMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[project.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ProjectMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, project.FieldEndDate)
}

// AddContributorIDs adds the "contributors" edge to the ProjectContributor entity by ids.
func (m *ProjectMutation) AddContributorIDs(ids ...int) {
	if m.contributors == nil {
		m.contributors = make(map[int]struct{})
	}
	for i := range ids {
		m.contributors[ids[i]] = struct{}{}
	}
}

// ClearContributors clears the "contributors" edge to the ProjectContributor entity.
func (m *ProjectMutation) ClearContributors() {
	m.clearedcontributors = true
}

// ContributorsCleared reports if the "contributors" edge to the ProjectContributor entity was cleared.
func (m *ProjectMutation) ContributorsCleared() bool {
	return m.clearedcontributors
}

// RemoveContributorIDs removes the "contributors" edge to the ProjectContributor entity by IDs.
func (m *ProjectMutation) RemoveContributorIDs(ids ...int) {
	if m.removedcontributors == nil {
		m.removedcontributors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.contributors, ids[i])
		m.removedcontributors[ids[i]] = struct{}{}
	}
}

// RemovedContributors returns the removed IDs of the "contributors" edge to the ProjectContributor entity.
func (m *ProjectMutation) RemovedContributorsIDs() (ids []int) {
	for id := range m.removedcontributors {
		ids = append(ids, id)
	}
	return
}

// ContributorsIDs returns the "contributors" edge IDs in the mutation.
func (m *ProjectMutation) ContributorsIDs() (ids []int) {
	for id := range m.contributors {
		ids = append(ids, id)
	}
	return
}

// ResetContributors resets all changes to the "contributors" edge.
func (m *ProjectMutation) ResetContributors() {
	m.contributors = nil
	m.clearedcontributors = false
	m.removedcontributors = nil
}

// AddParentProjectIDs adds the "parent_projects" edge to the ProjectAssociation entity by ids.
func (m *ProjectMutation) AddParentProjectIDs(ids ...int) {
	if m.parent_projects == nil {
		m.parent_projects = make(map[int]struct{})
	}
	for i := range ids {
		m.parent_projects[ids[i]] = struct{}{}
	}
}

// ClearParentProjects clears the "parent_projects" edge to the ProjectAssociation entity.
func (m *ProjectMutation) ClearParentProjects() {
	m.clearedparent_projects = true
}

// ParentProjectsCleared reports if the "parent_projects" edge to the ProjectAssociation entity was cleared.
func (m *ProjectMutation) ParentProjectsCleared() bool {
	return m.clearedparent_projects
}

// RemoveParentProjectIDs removes the "parent_projects" edge to the ProjectAssociation entity by IDs.
func (m *ProjectMutation) RemoveParentProjectIDs(ids ...int) {
	if m.removedparent_projects == nil {
		m.removedparent_projects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.parent_projects, ids[i])
		m.removedparent_projects[ids[i]] = struct{}{}
	}
}

// RemovedParentProjects returns the removed IDs of the "parent_projects" edge to the ProjectAssociation entity.
func (m *ProjectMutation) RemovedParentProjectsIDs() (ids []int) {
	for id := range m.removedparent_projects {
		ids = append(ids, id)
	}
	return
}

// ParentProjectsIDs returns the "parent_projects" edge IDs in the mutation.
func (m *ProjectMutation) ParentProjectsIDs() (ids []int) {
	for id := range m.parent_projects {
		ids = append(ids, id)
	}
	return
}

// ResetParentProjects resets all changes to the "parent_projects" edge.
func (m *ProjectMutation) ResetParentProjects() {
	m.parent_projects = nil
	m.clearedparent_projects = false
	m.removedparent_projects = nil
}

// AddChildProjectIDs adds the "child_projects" edge to the ProjectAssociation entity by ids.
func (m *ProjectMutation) AddChildProjectIDs(ids ...int) {
	if m.child_projects == nil {
		m.child_projects = make(map[int]struct{})
	}
	for i := range ids {
		m.child_projects[ids[i]] = struct{}{}
	}
}

// ClearChildProjects clears the "child_projects" edge to the ProjectAssociation entity.
func (m *ProjectMutation) ClearChildProjects() {
	m.clearedchild_projects = true
}

// ChildProjectsCleared reports if the "child_projects" edge to the ProjectAssociation entity was cleared.
func (m *ProjectMutation) ChildProjectsCleared() bool {
	return m.clearedchild_projects
}

// RemoveChildProjectIDs removes the "child_projects" edge to the ProjectAssociation entity by IDs.
func (m *ProjectMutation) RemoveChildProjectIDs(ids ...int) {
	if m.removedchild_projects == nil {
		m.removedchild_projects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.child_projects, ids[i])
		m.removedchild_projects[ids[i]] = struct{}{}
	}
}

// RemovedChildProjects returns the removed IDs of the "child_projects" edge to the ProjectAssociation entity.
func (m *ProjectMutation) RemovedChildProjectsIDs() (ids []int) {
	for id := range m.removedchild_projects {
		ids = append(ids, id)
	}
	return
}

// ChildProjectsIDs returns the "child_projects" edge IDs in the mutation.
func (m *ProjectMutation) ChildProjectsIDs() (ids []int) {
	for id := range m.child_projects {
		ids = append(ids, id)
	}
	return
}

// ResetChildProjects resets all changes to the "child_projects" edge.
func (m *ProjectMutation) ResetChildProjects() {
	m.child_projects = nil
	m.clearedchild_projects = false
	m.removedchild_projects = nil
}

// AddRepositoryIDs adds the "repositories" edge to the Repository entity by ids.
func (m *ProjectMutation) AddRepositoryIDs(ids ...int) {
	if m.repositories == nil {
		m.repositories = make(map[int]struct{})
	}
	for i := range ids {
		m.repositories[ids[i]] = struct{}{}
	}
}

// ClearRepositories clears the "repositories" edge to the Repository entity.
func (m *ProjectMutation) ClearRepositories() {
	m.clearedrepositories = true
}

// RepositoriesCleared reports if the "repositories" edge to the Repository entity was cleared.
func (m *ProjectMutation) RepositoriesCleared() bool {
	return m.clearedrepositories
}

// RemoveRepositoryIDs removes the "repositories" edge to the Repository entity by IDs.
func (m *ProjectMutation) RemoveRepositoryIDs(ids ...int) {
	if m.removedrepositories == nil {
		m.removedrepositories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.repositories, ids[i])
		m.removedrepositories[ids[i]] = struct{}{}
	}
}

// RemovedRepositories returns the removed IDs of the "repositories" edge to the Repository entity.
func (m *ProjectMutation) RemovedRepositoriesIDs() (ids []int) {
	for id := range m.removedrepositories {
		ids = append(ids, id)
	}
	return
}

// RepositoriesIDs returns the "repositories" edge IDs in the mutation.
func (m *ProjectMutation) RepositoriesIDs() (ids []int) {
	for id := range m.repositories {
		ids = append(ids, id)
	}
	return
}

// ResetRepositories resets all changes to the "repositories" edge.
func (m *ProjectMutation) ResetRepositories() {
	m.repositories = nil
	m.clearedrepositories = false
	m.removedrepositories = nil
}

// AddDiscordBotIDs adds the "discord_bots" edge to the DiscordBot entity by ids.
func (m *ProjectMutation) AddDiscordBotIDs(ids ...int) {
	if m.discord_bots == nil {
		m.discord_bots = make(map[int]struct{})
	}
	for i := range ids {
		m.discord_bots[ids[i]] = struct{}{}
	}
}

// ClearDiscordBots clears the "discord_bots" edge to the DiscordBot entity.
func (m *ProjectMutation) ClearDiscordBots() {
	m.cleareddiscord_bots = true
}

// DiscordBotsCleared reports if the "discord_bots" edge to the DiscordBot entity was cleared.
func (m *ProjectMutation) DiscordBotsCleared() bool {
	return m.cleareddiscord_bots
}

// RemoveDiscordBotIDs removes the "discord_bots" edge to the DiscordBot entity by IDs.
func (m *ProjectMutation) RemoveDiscordBotIDs(ids ...int) {
	if m.removeddiscord_bots == nil {
		m.removeddiscord_bots = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.discord_bots, ids[i])
		m.removeddiscord_bots[ids[i]] = struct{}{}
	}
}

// RemovedDiscordBots returns the removed IDs of the "discord_bots" edge to the DiscordBot entity.
func (m *ProjectMutation) RemovedDiscordBotsIDs() (ids []int) {
	for id := range m.removeddiscord_bots {
		ids = append(ids, id)
	}
	return
}

// DiscordBotsIDs returns the "discord_bots" edge IDs in the mutation.
func (m *ProjectMutation) DiscordBotsIDs() (ids []int) {
	for id := range m.discord_bots {
		ids = append(ids, id)
	}
	return
}

// ResetDiscordBots resets all changes to the "discord_bots" edge.
func (m *ProjectMutation) ResetDiscordBots() {
	m.discord_bots = nil
	m.cleareddiscord_bots = false
	m.removeddiscord_bots = nil
}

// AddSiteIDs adds the "sites" edge to the Site entity by ids.
func (m *ProjectMutation) AddSiteIDs(ids ...int) {
	if m.sites == nil {
		m.sites = make(map[int]struct{})
	}
	for i := range ids {
		m.sites[ids[i]] = struct{}{}
	}
}

// ClearSites clears the "sites" edge to the Site entity.
func (m *ProjectMutation) ClearSites() {
	m.clearedsites = true
}

// SitesCleared reports if the "sites" edge to the Site entity was cleared.
func (m *ProjectMutation) SitesCleared() bool {
	return m.clearedsites
}

// RemoveSiteIDs removes the "sites" edge to the Site entity by IDs.
func (m *ProjectMutation) RemoveSiteIDs(ids ...int) {
	if m.removedsites == nil {
		m.removedsites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sites, ids[i])
		m.removedsites[ids[i]] = struct{}{}
	}
}

// RemovedSites returns the removed IDs of the "sites" edge to the Site entity.
func (m *ProjectMutation) RemovedSitesIDs() (ids []int) {
	for id := range m.removedsites {
		ids = append(ids, id)
	}
	return
}

// SitesIDs returns the "sites" edge IDs in the mutation.
func (m *ProjectMutation) SitesIDs() (ids []int) {
	for id := range m.sites {
		ids = append(ids, id)
	}
	return
}

// ResetSites resets all changes to the "sites" edge.
func (m *ProjectMutation) ResetSites() {
	m.sites = nil
	m.clearedsites = false
	m.removedsites = nil
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.start_date != nil {
		fields = append(fields, project.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, project.FieldEndDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldStartDate:
		return m.StartDate()
	case project.FieldEndDate:
		return m.EndDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldStartDate:
		return m.OldStartDate(ctx)
	case project.FieldEndDate:
		return m.OldEndDate(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case project.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDescription) {
		fields = append(fields, project.FieldDescription)
	}
	if m.FieldCleared(project.FieldEndDate) {
		fields = append(fields, project.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDescription:
		m.ClearDescription()
		return nil
	case project.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldStartDate:
		m.ResetStartDate()
		return nil
	case project.FieldEndDate:
		m.ResetEndDate()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.contributors != nil {
		edges = append(edges, project.EdgeContributors)
	}
	if m.parent_projects != nil {
		edges = append(edges, project.EdgeParentProjects)
	}
	if m.child_projects != nil {
		edges = append(edges, project.EdgeChildProjects)
	}
	if m.repositories != nil {
		edges = append(edges, project.EdgeRepositories)
	}
	if m.discord_bots != nil {
		edges = append(edges, project.EdgeDiscordBots)
	}
	if m.sites != nil {
		edges = append(edges, project.EdgeSites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeContributors:
		ids := make([]ent.Value, 0, len(m.contributors))
		for id := range m.contributors {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeParentProjects:
		ids := make([]ent.Value, 0, len(m.parent_projects))
		for id := range m.parent_projects {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeChildProjects:
		ids := make([]ent.Value, 0, len(m.child_projects))
		for id := range m.child_projects {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m.repositories))
		for id := range m.repositories {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeDiscordBots:
		ids := make([]ent.Value, 0, len(m.discord_bots))
		for id := range m.discord_bots {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeSites:
		ids := make([]ent.Value, 0, len(m.sites))
		for id := range m.sites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedcontributors != nil {
		edges = append(edges, project.EdgeContributors)
	}
	if m.removedparent_projects != nil {
		edges = append(edges, project.EdgeParentProjects)
	}
	if m.removedchild_projects != nil {
		edges = append(edges, project.EdgeChildProjects)
	}
	if m.removedrepositories != nil {
		edges = append(edges, project.EdgeRepositories)
	}
	if m.removeddiscord_bots != nil {
		edges = append(edges, project.EdgeDiscordBots)
	}
	if m.removedsites != nil {
		edges = append(edges, project.EdgeSites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeContributors:
		ids := make([]ent.Value, 0, len(m.removedcontributors))
		for id := range m.removedcontributors {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeParentProjects:
		ids := make([]ent.Value, 0, len(m.removedparent_projects))
		for id := range m.removedparent_projects {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeChildProjects:
		ids := make([]ent.Value, 0, len(m.removedchild_projects))
		for id := range m.removedchild_projects {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m.removedrepositories))
		for id := range m.removedrepositories {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeDiscordBots:
		ids := make([]ent.Value, 0, len(m.removeddiscord_bots))
		for id := range m.removeddiscord_bots {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeSites:
		ids := make([]ent.Value, 0, len(m.removedsites))
		for id := range m.removedsites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcontributors {
		edges = append(edges, project.EdgeContributors)
	}
	if m.clearedparent_projects {
		edges = append(edges, project.EdgeParentProjects)
	}
	if m.clearedchild_projects {
		edges = append(edges, project.EdgeChildProjects)
	}
	if m.clearedrepositories {
		edges = append(edges, project.EdgeRepositories)
	}
	if m.cleareddiscord_bots {
		edges = append(edges, project.EdgeDiscordBots)
	}
	if m.clearedsites {
		edges = append(edges, project.EdgeSites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeContributors:
		return m.clearedcontributors
	case project.EdgeParentProjects:
		return m.clearedparent_projects
	case project.EdgeChildProjects:
		return m.clearedchild_projects
	case project.EdgeRepositories:
		return m.clearedrepositories
	case project.EdgeDiscordBots:
		return m.cleareddiscord_bots
	case project.EdgeSites:
		return m.clearedsites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeContributors:
		m.ResetContributors()
		return nil
	case project.EdgeParentProjects:
		m.ResetParentProjects()
		return nil
	case project.EdgeChildProjects:
		m.ResetChildProjects()
		return nil
	case project.EdgeRepositories:
		m.ResetRepositories()
		return nil
	case project.EdgeDiscordBots:
		m.ResetDiscordBots()
		return nil
	case project.EdgeSites:
		m.ResetSites()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProjectAssociationMutation represents an operation that mutates the ProjectAssociation nodes in the graph.
type ProjectAssociationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_type         *projectassociation.Type
	clearedFields map[string]struct{}
	parent        *int
	clearedparent bool
	child         *int
	clearedchild  bool
	done          bool
	oldValue      func(context.Context) (*ProjectAssociation, error)
	predicates    []predicate.ProjectAssociation
}

var _ ent.Mutation = (*ProjectAssociationMutation)(nil)

// projectassociationOption allows management of the mutation configuration using functional options.
type projectassociationOption func(*ProjectAssociationMutation)

// newProjectAssociationMutation creates new mutation for the ProjectAssociation entity.
func newProjectAssociationMutation(c config, op Op, opts ...projectassociationOption) *ProjectAssociationMutation {
	m := &ProjectAssociationMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectAssociation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectAssociationID sets the ID field of the mutation.
func withProjectAssociationID(id int) projectassociationOption {
	return func(m *ProjectAssociationMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectAssociation
		)
		m.oldValue = func(ctx context.Context) (*ProjectAssociation, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectAssociation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectAssociation sets the old ProjectAssociation of the mutation.
func withProjectAssociation(node *ProjectAssociation) projectassociationOption {
	return func(m *ProjectAssociationMutation) {
		m.oldValue = func(context.Context) (*ProjectAssociation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectAssociationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectAssociationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectAssociationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the "type" field.
func (m *ProjectAssociationMutation) SetType(pr projectassociation.Type) {
	m._type = &pr
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProjectAssociationMutation) GetType() (r projectassociation.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ProjectAssociation entity.
// If the ProjectAssociation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectAssociationMutation) OldType(ctx context.Context) (v projectassociation.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ProjectAssociationMutation) ResetType() {
	m._type = nil
}

// SetParentID sets the "parent" edge to the Project entity by id.
func (m *ProjectAssociationMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Project entity.
func (m *ProjectAssociationMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Project entity was cleared.
func (m *ProjectAssociationMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ProjectAssociationMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ProjectAssociationMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ProjectAssociationMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// SetChildID sets the "child" edge to the Project entity by id.
func (m *ProjectAssociationMutation) SetChildID(id int) {
	m.child = &id
}

// ClearChild clears the "child" edge to the Project entity.
func (m *ProjectAssociationMutation) ClearChild() {
	m.clearedchild = true
}

// ChildCleared reports if the "child" edge to the Project entity was cleared.
func (m *ProjectAssociationMutation) ChildCleared() bool {
	return m.clearedchild
}

// ChildID returns the "child" edge ID in the mutation.
func (m *ProjectAssociationMutation) ChildID() (id int, exists bool) {
	if m.child != nil {
		return *m.child, true
	}
	return
}

// ChildIDs returns the "child" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChildID instead. It exists only for internal usage by the builders.
func (m *ProjectAssociationMutation) ChildIDs() (ids []int) {
	if id := m.child; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChild resets all changes to the "child" edge.
func (m *ProjectAssociationMutation) ResetChild() {
	m.child = nil
	m.clearedchild = false
}

// Op returns the operation name.
func (m *ProjectAssociationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectAssociation).
func (m *ProjectAssociationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectAssociationMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._type != nil {
		fields = append(fields, projectassociation.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectAssociationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectassociation.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectAssociationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectassociation.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectAssociation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectAssociationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectassociation.FieldType:
		v, ok := value.(projectassociation.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectAssociation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectAssociationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectAssociationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectAssociationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectAssociation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectAssociationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectAssociationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectAssociationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectAssociation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectAssociationMutation) ResetField(name string) error {
	switch name {
	case projectassociation.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ProjectAssociation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectAssociationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, projectassociation.EdgeParent)
	}
	if m.child != nil {
		edges = append(edges, projectassociation.EdgeChild)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectAssociationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectassociation.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case projectassociation.EdgeChild:
		if id := m.child; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectAssociationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectAssociationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectAssociationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, projectassociation.EdgeParent)
	}
	if m.clearedchild {
		edges = append(edges, projectassociation.EdgeChild)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectAssociationMutation) EdgeCleared(name string) bool {
	switch name {
	case projectassociation.EdgeParent:
		return m.clearedparent
	case projectassociation.EdgeChild:
		return m.clearedchild
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectAssociationMutation) ClearEdge(name string) error {
	switch name {
	case projectassociation.EdgeParent:
		m.ClearParent()
		return nil
	case projectassociation.EdgeChild:
		m.ClearChild()
		return nil
	}
	return fmt.Errorf("unknown ProjectAssociation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectAssociationMutation) ResetEdge(name string) error {
	switch name {
	case projectassociation.EdgeParent:
		m.ResetParent()
		return nil
	case projectassociation.EdgeChild:
		m.ResetChild()
		return nil
	}
	return fmt.Errorf("unknown ProjectAssociation edge %s", name)
}

// ProjectContributorMutation represents an operation that mutates the ProjectContributor nodes in the graph.
type ProjectContributorMutation struct {
	config
	op             Op
	typ            string
	id             *int
	role           *projectcontributor.Role
	clearedFields  map[string]struct{}
	project        *int
	clearedproject bool
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*ProjectContributor, error)
	predicates     []predicate.ProjectContributor
}

var _ ent.Mutation = (*ProjectContributorMutation)(nil)

// projectcontributorOption allows management of the mutation configuration using functional options.
type projectcontributorOption func(*ProjectContributorMutation)

// newProjectContributorMutation creates new mutation for the ProjectContributor entity.
func newProjectContributorMutation(c config, op Op, opts ...projectcontributorOption) *ProjectContributorMutation {
	m := &ProjectContributorMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectContributor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectContributorID sets the ID field of the mutation.
func withProjectContributorID(id int) projectcontributorOption {
	return func(m *ProjectContributorMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectContributor
		)
		m.oldValue = func(ctx context.Context) (*ProjectContributor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectContributor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectContributor sets the old ProjectContributor of the mutation.
func withProjectContributor(node *ProjectContributor) projectcontributorOption {
	return func(m *ProjectContributorMutation) {
		m.oldValue = func(context.Context) (*ProjectContributor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectContributorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectContributorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectContributorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRole sets the "role" field.
func (m *ProjectContributorMutation) SetRole(pr projectcontributor.Role) {
	m.role = &pr
}

// Role returns the value of the "role" field in the mutation.
func (m *ProjectContributorMutation) Role() (r projectcontributor.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the ProjectContributor entity.
// If the ProjectContributor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectContributorMutation) OldRole(ctx context.Context) (v projectcontributor.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *ProjectContributorMutation) ResetRole() {
	m.role = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ProjectContributorMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectContributorMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectContributorMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ProjectContributorMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectContributorMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectContributorMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ProjectContributorMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProjectContributorMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProjectContributorMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ProjectContributorMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProjectContributorMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProjectContributorMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *ProjectContributorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectContributor).
func (m *ProjectContributorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectContributorMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.role != nil {
		fields = append(fields, projectcontributor.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectContributorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectcontributor.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectContributorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectcontributor.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectContributor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectContributorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectcontributor.FieldRole:
		v, ok := value.(projectcontributor.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectContributor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectContributorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectContributorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectContributorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectContributor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectContributorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectContributorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectContributorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectContributor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectContributorMutation) ResetField(name string) error {
	switch name {
	case projectcontributor.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown ProjectContributor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectContributorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, projectcontributor.EdgeProject)
	}
	if m.user != nil {
		edges = append(edges, projectcontributor.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectContributorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectcontributor.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projectcontributor.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectContributorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectContributorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectContributorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, projectcontributor.EdgeProject)
	}
	if m.cleareduser {
		edges = append(edges, projectcontributor.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectContributorMutation) EdgeCleared(name string) bool {
	switch name {
	case projectcontributor.EdgeProject:
		return m.clearedproject
	case projectcontributor.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectContributorMutation) ClearEdge(name string) error {
	switch name {
	case projectcontributor.EdgeProject:
		m.ClearProject()
		return nil
	case projectcontributor.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ProjectContributor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectContributorMutation) ResetEdge(name string) error {
	switch name {
	case projectcontributor.EdgeProject:
		m.ResetProject()
		return nil
	case projectcontributor.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ProjectContributor edge %s", name)
}

// RepositoryMutation represents an operation that mutates the Repository nodes in the graph.
type RepositoryMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	name                       *string
	description                *string
	clearedFields              map[string]struct{}
	project                    *int
	clearedproject             bool
	github_account             *int
	clearedgithub_account      bool
	github_organization        *int
	clearedgithub_organization bool
	discord_bots               map[int]struct{}
	removeddiscord_bots        map[int]struct{}
	cleareddiscord_bots        bool
	sites                      map[int]struct{}
	removedsites               map[int]struct{}
	clearedsites               bool
	done                       bool
	oldValue                   func(context.Context) (*Repository, error)
	predicates                 []predicate.Repository
}

var _ ent.Mutation = (*RepositoryMutation)(nil)

// repositoryOption allows management of the mutation configuration using functional options.
type repositoryOption func(*RepositoryMutation)

// newRepositoryMutation creates new mutation for the Repository entity.
func newRepositoryMutation(c config, op Op, opts ...repositoryOption) *RepositoryMutation {
	m := &RepositoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRepository,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepositoryID sets the ID field of the mutation.
func withRepositoryID(id int) repositoryOption {
	return func(m *RepositoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Repository
		)
		m.oldValue = func(ctx context.Context) (*Repository, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repository.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepository sets the old Repository of the mutation.
func withRepository(node *Repository) repositoryOption {
	return func(m *RepositoryMutation) {
		m.oldValue = func(context.Context) (*Repository, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepositoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepositoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepositoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *RepositoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RepositoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RepositoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RepositoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RepositoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RepositoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[repository.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RepositoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[repository.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RepositoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, repository.FieldDescription)
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *RepositoryMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *RepositoryMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *RepositoryMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *RepositoryMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *RepositoryMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *RepositoryMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetGithubAccountID sets the "github_account" edge to the GithubAccount entity by id.
func (m *RepositoryMutation) SetGithubAccountID(id int) {
	m.github_account = &id
}

// ClearGithubAccount clears the "github_account" edge to the GithubAccount entity.
func (m *RepositoryMutation) ClearGithubAccount() {
	m.clearedgithub_account = true
}

// GithubAccountCleared reports if the "github_account" edge to the GithubAccount entity was cleared.
func (m *RepositoryMutation) GithubAccountCleared() bool {
	return m.clearedgithub_account
}

// GithubAccountID returns the "github_account" edge ID in the mutation.
func (m *RepositoryMutation) GithubAccountID() (id int, exists bool) {
	if m.github_account != nil {
		return *m.github_account, true
	}
	return
}

// GithubAccountIDs returns the "github_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GithubAccountID instead. It exists only for internal usage by the builders.
func (m *RepositoryMutation) GithubAccountIDs() (ids []int) {
	if id := m.github_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGithubAccount resets all changes to the "github_account" edge.
func (m *RepositoryMutation) ResetGithubAccount() {
	m.github_account = nil
	m.clearedgithub_account = false
}

// SetGithubOrganizationID sets the "github_organization" edge to the GithubOrganization entity by id.
func (m *RepositoryMutation) SetGithubOrganizationID(id int) {
	m.github_organization = &id
}

// ClearGithubOrganization clears the "github_organization" edge to the GithubOrganization entity.
func (m *RepositoryMutation) ClearGithubOrganization() {
	m.clearedgithub_organization = true
}

// GithubOrganizationCleared reports if the "github_organization" edge to the GithubOrganization entity was cleared.
func (m *RepositoryMutation) GithubOrganizationCleared() bool {
	return m.clearedgithub_organization
}

// GithubOrganizationID returns the "github_organization" edge ID in the mutation.
func (m *RepositoryMutation) GithubOrganizationID() (id int, exists bool) {
	if m.github_organization != nil {
		return *m.github_organization, true
	}
	return
}

// GithubOrganizationIDs returns the "github_organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GithubOrganizationID instead. It exists only for internal usage by the builders.
func (m *RepositoryMutation) GithubOrganizationIDs() (ids []int) {
	if id := m.github_organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGithubOrganization resets all changes to the "github_organization" edge.
func (m *RepositoryMutation) ResetGithubOrganization() {
	m.github_organization = nil
	m.clearedgithub_organization = false
}

// AddDiscordBotIDs adds the "discord_bots" edge to the DiscordBot entity by ids.
func (m *RepositoryMutation) AddDiscordBotIDs(ids ...int) {
	if m.discord_bots == nil {
		m.discord_bots = make(map[int]struct{})
	}
	for i := range ids {
		m.discord_bots[ids[i]] = struct{}{}
	}
}

// ClearDiscordBots clears the "discord_bots" edge to the DiscordBot entity.
func (m *RepositoryMutation) ClearDiscordBots() {
	m.cleareddiscord_bots = true
}

// DiscordBotsCleared reports if the "discord_bots" edge to the DiscordBot entity was cleared.
func (m *RepositoryMutation) DiscordBotsCleared() bool {
	return m.cleareddiscord_bots
}

// RemoveDiscordBotIDs removes the "discord_bots" edge to the DiscordBot entity by IDs.
func (m *RepositoryMutation) RemoveDiscordBotIDs(ids ...int) {
	if m.removeddiscord_bots == nil {
		m.removeddiscord_bots = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.discord_bots, ids[i])
		m.removeddiscord_bots[ids[i]] = struct{}{}
	}
}

// RemovedDiscordBots returns the removed IDs of the "discord_bots" edge to the DiscordBot entity.
func (m *RepositoryMutation) RemovedDiscordBotsIDs() (ids []int) {
	for id := range m.removeddiscord_bots {
		ids = append(ids, id)
	}
	return
}

// DiscordBotsIDs returns the "discord_bots" edge IDs in the mutation.
func (m *RepositoryMutation) DiscordBotsIDs() (ids []int) {
	for id := range m.discord_bots {
		ids = append(ids, id)
	}
	return
}

// ResetDiscordBots resets all changes to the "discord_bots" edge.
func (m *RepositoryMutation) ResetDiscordBots() {
	m.discord_bots = nil
	m.cleareddiscord_bots = false
	m.removeddiscord_bots = nil
}

// AddSiteIDs adds the "sites" edge to the Site entity by ids.
func (m *RepositoryMutation) AddSiteIDs(ids ...int) {
	if m.sites == nil {
		m.sites = make(map[int]struct{})
	}
	for i := range ids {
		m.sites[ids[i]] = struct{}{}
	}
}

// ClearSites clears the "sites" edge to the Site entity.
func (m *RepositoryMutation) ClearSites() {
	m.clearedsites = true
}

// SitesCleared reports if the "sites" edge to the Site entity was cleared.
func (m *RepositoryMutation) SitesCleared() bool {
	return m.clearedsites
}

// RemoveSiteIDs removes the "sites" edge to the Site entity by IDs.
func (m *RepositoryMutation) RemoveSiteIDs(ids ...int) {
	if m.removedsites == nil {
		m.removedsites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sites, ids[i])
		m.removedsites[ids[i]] = struct{}{}
	}
}

// RemovedSites returns the removed IDs of the "sites" edge to the Site entity.
func (m *RepositoryMutation) RemovedSitesIDs() (ids []int) {
	for id := range m.removedsites {
		ids = append(ids, id)
	}
	return
}

// SitesIDs returns the "sites" edge IDs in the mutation.
func (m *RepositoryMutation) SitesIDs() (ids []int) {
	for id := range m.sites {
		ids = append(ids, id)
	}
	return
}

// ResetSites resets all changes to the "sites" edge.
func (m *RepositoryMutation) ResetSites() {
	m.sites = nil
	m.clearedsites = false
	m.removedsites = nil
}

// Op returns the operation name.
func (m *RepositoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Repository).
func (m *RepositoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepositoryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, repository.FieldName)
	}
	if m.description != nil {
		fields = append(fields, repository.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepositoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repository.FieldName:
		return m.Name()
	case repository.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepositoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repository.FieldName:
		return m.OldName(ctx)
	case repository.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Repository field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repository.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case repository.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepositoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepositoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Repository numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepositoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(repository.FieldDescription) {
		fields = append(fields, repository.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepositoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepositoryMutation) ClearField(name string) error {
	switch name {
	case repository.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Repository nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepositoryMutation) ResetField(name string) error {
	switch name {
	case repository.FieldName:
		m.ResetName()
		return nil
	case repository.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepositoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.project != nil {
		edges = append(edges, repository.EdgeProject)
	}
	if m.github_account != nil {
		edges = append(edges, repository.EdgeGithubAccount)
	}
	if m.github_organization != nil {
		edges = append(edges, repository.EdgeGithubOrganization)
	}
	if m.discord_bots != nil {
		edges = append(edges, repository.EdgeDiscordBots)
	}
	if m.sites != nil {
		edges = append(edges, repository.EdgeSites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepositoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case repository.EdgeGithubAccount:
		if id := m.github_account; id != nil {
			return []ent.Value{*id}
		}
	case repository.EdgeGithubOrganization:
		if id := m.github_organization; id != nil {
			return []ent.Value{*id}
		}
	case repository.EdgeDiscordBots:
		ids := make([]ent.Value, 0, len(m.discord_bots))
		for id := range m.discord_bots {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeSites:
		ids := make([]ent.Value, 0, len(m.sites))
		for id := range m.sites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepositoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeddiscord_bots != nil {
		edges = append(edges, repository.EdgeDiscordBots)
	}
	if m.removedsites != nil {
		edges = append(edges, repository.EdgeSites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepositoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeDiscordBots:
		ids := make([]ent.Value, 0, len(m.removeddiscord_bots))
		for id := range m.removeddiscord_bots {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeSites:
		ids := make([]ent.Value, 0, len(m.removedsites))
		for id := range m.removedsites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepositoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedproject {
		edges = append(edges, repository.EdgeProject)
	}
	if m.clearedgithub_account {
		edges = append(edges, repository.EdgeGithubAccount)
	}
	if m.clearedgithub_organization {
		edges = append(edges, repository.EdgeGithubOrganization)
	}
	if m.cleareddiscord_bots {
		edges = append(edges, repository.EdgeDiscordBots)
	}
	if m.clearedsites {
		edges = append(edges, repository.EdgeSites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepositoryMutation) EdgeCleared(name string) bool {
	switch name {
	case repository.EdgeProject:
		return m.clearedproject
	case repository.EdgeGithubAccount:
		return m.clearedgithub_account
	case repository.EdgeGithubOrganization:
		return m.clearedgithub_organization
	case repository.EdgeDiscordBots:
		return m.cleareddiscord_bots
	case repository.EdgeSites:
		return m.clearedsites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepositoryMutation) ClearEdge(name string) error {
	switch name {
	case repository.EdgeProject:
		m.ClearProject()
		return nil
	case repository.EdgeGithubAccount:
		m.ClearGithubAccount()
		return nil
	case repository.EdgeGithubOrganization:
		m.ClearGithubOrganization()
		return nil
	}
	return fmt.Errorf("unknown Repository unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepositoryMutation) ResetEdge(name string) error {
	switch name {
	case repository.EdgeProject:
		m.ResetProject()
		return nil
	case repository.EdgeGithubAccount:
		m.ResetGithubAccount()
		return nil
	case repository.EdgeGithubOrganization:
		m.ResetGithubOrganization()
		return nil
	case repository.EdgeDiscordBots:
		m.ResetDiscordBots()
		return nil
	case repository.EdgeSites:
		m.ResetSites()
		return nil
	}
	return fmt.Errorf("unknown Repository edge %s", name)
}

// SiteMutation represents an operation that mutates the Site nodes in the graph.
type SiteMutation struct {
	config
	op                Op
	typ               string
	id                *int
	url               *string
	clearedFields     map[string]struct{}
	project           *int
	clearedproject    bool
	repository        *int
	clearedrepository bool
	done              bool
	oldValue          func(context.Context) (*Site, error)
	predicates        []predicate.Site
}

var _ ent.Mutation = (*SiteMutation)(nil)

// siteOption allows management of the mutation configuration using functional options.
type siteOption func(*SiteMutation)

// newSiteMutation creates new mutation for the Site entity.
func newSiteMutation(c config, op Op, opts ...siteOption) *SiteMutation {
	m := &SiteMutation{
		config:        c,
		op:            op,
		typ:           TypeSite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSiteID sets the ID field of the mutation.
func withSiteID(id int) siteOption {
	return func(m *SiteMutation) {
		var (
			err   error
			once  sync.Once
			value *Site
		)
		m.oldValue = func(ctx context.Context) (*Site, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Site.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSite sets the old Site of the mutation.
func withSite(node *Site) siteOption {
	return func(m *SiteMutation) {
		m.oldValue = func(context.Context) (*Site, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SiteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SiteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SiteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetURL sets the "url" field.
func (m *SiteMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *SiteMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *SiteMutation) ResetURL() {
	m.url = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *SiteMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *SiteMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *SiteMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *SiteMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *SiteMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *SiteMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetRepositoryID sets the "repository" edge to the Repository entity by id.
func (m *SiteMutation) SetRepositoryID(id int) {
	m.repository = &id
}

// ClearRepository clears the "repository" edge to the Repository entity.
func (m *SiteMutation) ClearRepository() {
	m.clearedrepository = true
}

// RepositoryCleared reports if the "repository" edge to the Repository entity was cleared.
func (m *SiteMutation) RepositoryCleared() bool {
	return m.clearedrepository
}

// RepositoryID returns the "repository" edge ID in the mutation.
func (m *SiteMutation) RepositoryID() (id int, exists bool) {
	if m.repository != nil {
		return *m.repository, true
	}
	return
}

// RepositoryIDs returns the "repository" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepositoryID instead. It exists only for internal usage by the builders.
func (m *SiteMutation) RepositoryIDs() (ids []int) {
	if id := m.repository; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepository resets all changes to the "repository" edge.
func (m *SiteMutation) ResetRepository() {
	m.repository = nil
	m.clearedrepository = false
}

// Op returns the operation name.
func (m *SiteMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Site).
func (m *SiteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SiteMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.url != nil {
		fields = append(fields, site.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SiteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case site.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SiteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case site.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Site field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SiteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case site.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Site field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SiteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SiteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SiteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Site numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SiteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SiteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SiteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Site nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SiteMutation) ResetField(name string) error {
	switch name {
	case site.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Site field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SiteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, site.EdgeProject)
	}
	if m.repository != nil {
		edges = append(edges, site.EdgeRepository)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SiteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case site.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case site.EdgeRepository:
		if id := m.repository; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SiteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SiteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SiteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, site.EdgeProject)
	}
	if m.clearedrepository {
		edges = append(edges, site.EdgeRepository)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SiteMutation) EdgeCleared(name string) bool {
	switch name {
	case site.EdgeProject:
		return m.clearedproject
	case site.EdgeRepository:
		return m.clearedrepository
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SiteMutation) ClearEdge(name string) error {
	switch name {
	case site.EdgeProject:
		m.ClearProject()
		return nil
	case site.EdgeRepository:
		m.ClearRepository()
		return nil
	}
	return fmt.Errorf("unknown Site unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SiteMutation) ResetEdge(name string) error {
	switch name {
	case site.EdgeProject:
		m.ResetProject()
		return nil
	case site.EdgeRepository:
		m.ResetRepository()
		return nil
	}
	return fmt.Errorf("unknown Site edge %s", name)
}

// TechnologyMutation represents an operation that mutates the Technology nodes in the graph.
type TechnologyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	colour        *string
	_type         *technology.Type
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Technology, error)
	predicates    []predicate.Technology
}

var _ ent.Mutation = (*TechnologyMutation)(nil)

// technologyOption allows management of the mutation configuration using functional options.
type technologyOption func(*TechnologyMutation)

// newTechnologyMutation creates new mutation for the Technology entity.
func newTechnologyMutation(c config, op Op, opts ...technologyOption) *TechnologyMutation {
	m := &TechnologyMutation{
		config:        c,
		op:            op,
		typ:           TypeTechnology,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTechnologyID sets the ID field of the mutation.
func withTechnologyID(id int) technologyOption {
	return func(m *TechnologyMutation) {
		var (
			err   error
			once  sync.Once
			value *Technology
		)
		m.oldValue = func(ctx context.Context) (*Technology, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Technology.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTechnology sets the old Technology of the mutation.
func withTechnology(node *Technology) technologyOption {
	return func(m *TechnologyMutation) {
		m.oldValue = func(context.Context) (*Technology, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TechnologyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TechnologyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TechnologyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *TechnologyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TechnologyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Technology entity.
// If the Technology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechnologyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TechnologyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TechnologyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TechnologyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Technology entity.
// If the Technology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechnologyMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TechnologyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[technology.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TechnologyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[technology.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TechnologyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, technology.FieldDescription)
}

// SetColour sets the "colour" field.
func (m *TechnologyMutation) SetColour(s string) {
	m.colour = &s
}

// Colour returns the value of the "colour" field in the mutation.
func (m *TechnologyMutation) Colour() (r string, exists bool) {
	v := m.colour
	if v == nil {
		return
	}
	return *v, true
}

// OldColour returns the old "colour" field's value of the Technology entity.
// If the Technology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechnologyMutation) OldColour(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldColour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldColour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColour: %w", err)
	}
	return oldValue.Colour, nil
}

// ClearColour clears the value of the "colour" field.
func (m *TechnologyMutation) ClearColour() {
	m.colour = nil
	m.clearedFields[technology.FieldColour] = struct{}{}
}

// ColourCleared returns if the "colour" field was cleared in this mutation.
func (m *TechnologyMutation) ColourCleared() bool {
	_, ok := m.clearedFields[technology.FieldColour]
	return ok
}

// ResetColour resets all changes to the "colour" field.
func (m *TechnologyMutation) ResetColour() {
	m.colour = nil
	delete(m.clearedFields, technology.FieldColour)
}

// SetType sets the "type" field.
func (m *TechnologyMutation) SetType(t technology.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TechnologyMutation) GetType() (r technology.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Technology entity.
// If the Technology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechnologyMutation) OldType(ctx context.Context) (v technology.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TechnologyMutation) ResetType() {
	m._type = nil
}

// Op returns the operation name.
func (m *TechnologyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Technology).
func (m *TechnologyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TechnologyMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, technology.FieldName)
	}
	if m.description != nil {
		fields = append(fields, technology.FieldDescription)
	}
	if m.colour != nil {
		fields = append(fields, technology.FieldColour)
	}
	if m._type != nil {
		fields = append(fields, technology.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TechnologyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case technology.FieldName:
		return m.Name()
	case technology.FieldDescription:
		return m.Description()
	case technology.FieldColour:
		return m.Colour()
	case technology.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TechnologyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case technology.FieldName:
		return m.OldName(ctx)
	case technology.FieldDescription:
		return m.OldDescription(ctx)
	case technology.FieldColour:
		return m.OldColour(ctx)
	case technology.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Technology field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TechnologyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case technology.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case technology.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case technology.FieldColour:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColour(v)
		return nil
	case technology.FieldType:
		v, ok := value.(technology.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Technology field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TechnologyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TechnologyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TechnologyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Technology numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TechnologyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(technology.FieldDescription) {
		fields = append(fields, technology.FieldDescription)
	}
	if m.FieldCleared(technology.FieldColour) {
		fields = append(fields, technology.FieldColour)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TechnologyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TechnologyMutation) ClearField(name string) error {
	switch name {
	case technology.FieldDescription:
		m.ClearDescription()
		return nil
	case technology.FieldColour:
		m.ClearColour()
		return nil
	}
	return fmt.Errorf("unknown Technology nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TechnologyMutation) ResetField(name string) error {
	switch name {
	case technology.FieldName:
		m.ResetName()
		return nil
	case technology.FieldDescription:
		m.ResetDescription()
		return nil
	case technology.FieldColour:
		m.ResetColour()
		return nil
	case technology.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Technology field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TechnologyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TechnologyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TechnologyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TechnologyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TechnologyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TechnologyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TechnologyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Technology unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TechnologyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Technology edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	username                     *string
	avatar_url                   *string
	clearedFields                map[string]struct{}
	discord_accounts             map[int]struct{}
	removeddiscord_accounts      map[int]struct{}
	cleareddiscord_accounts      bool
	github_accounts              map[int]struct{}
	removedgithub_accounts       map[int]struct{}
	clearedgithub_accounts       bool
	project_contributions        map[int]struct{}
	removedproject_contributions map[int]struct{}
	clearedproject_contributions bool
	done                         bool
	oldValue                     func(context.Context) (*User, error)
	predicates                   []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// AddDiscordAccountIDs adds the "discord_accounts" edge to the DiscordAccount entity by ids.
func (m *UserMutation) AddDiscordAccountIDs(ids ...int) {
	if m.discord_accounts == nil {
		m.discord_accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.discord_accounts[ids[i]] = struct{}{}
	}
}

// ClearDiscordAccounts clears the "discord_accounts" edge to the DiscordAccount entity.
func (m *UserMutation) ClearDiscordAccounts() {
	m.cleareddiscord_accounts = true
}

// DiscordAccountsCleared reports if the "discord_accounts" edge to the DiscordAccount entity was cleared.
func (m *UserMutation) DiscordAccountsCleared() bool {
	return m.cleareddiscord_accounts
}

// RemoveDiscordAccountIDs removes the "discord_accounts" edge to the DiscordAccount entity by IDs.
func (m *UserMutation) RemoveDiscordAccountIDs(ids ...int) {
	if m.removeddiscord_accounts == nil {
		m.removeddiscord_accounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.discord_accounts, ids[i])
		m.removeddiscord_accounts[ids[i]] = struct{}{}
	}
}

// RemovedDiscordAccounts returns the removed IDs of the "discord_accounts" edge to the DiscordAccount entity.
func (m *UserMutation) RemovedDiscordAccountsIDs() (ids []int) {
	for id := range m.removeddiscord_accounts {
		ids = append(ids, id)
	}
	return
}

// DiscordAccountsIDs returns the "discord_accounts" edge IDs in the mutation.
func (m *UserMutation) DiscordAccountsIDs() (ids []int) {
	for id := range m.discord_accounts {
		ids = append(ids, id)
	}
	return
}

// ResetDiscordAccounts resets all changes to the "discord_accounts" edge.
func (m *UserMutation) ResetDiscordAccounts() {
	m.discord_accounts = nil
	m.cleareddiscord_accounts = false
	m.removeddiscord_accounts = nil
}

// AddGithubAccountIDs adds the "github_accounts" edge to the GithubAccount entity by ids.
func (m *UserMutation) AddGithubAccountIDs(ids ...int) {
	if m.github_accounts == nil {
		m.github_accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.github_accounts[ids[i]] = struct{}{}
	}
}

// ClearGithubAccounts clears the "github_accounts" edge to the GithubAccount entity.
func (m *UserMutation) ClearGithubAccounts() {
	m.clearedgithub_accounts = true
}

// GithubAccountsCleared reports if the "github_accounts" edge to the GithubAccount entity was cleared.
func (m *UserMutation) GithubAccountsCleared() bool {
	return m.clearedgithub_accounts
}

// RemoveGithubAccountIDs removes the "github_accounts" edge to the GithubAccount entity by IDs.
func (m *UserMutation) RemoveGithubAccountIDs(ids ...int) {
	if m.removedgithub_accounts == nil {
		m.removedgithub_accounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.github_accounts, ids[i])
		m.removedgithub_accounts[ids[i]] = struct{}{}
	}
}

// RemovedGithubAccounts returns the removed IDs of the "github_accounts" edge to the GithubAccount entity.
func (m *UserMutation) RemovedGithubAccountsIDs() (ids []int) {
	for id := range m.removedgithub_accounts {
		ids = append(ids, id)
	}
	return
}

// GithubAccountsIDs returns the "github_accounts" edge IDs in the mutation.
func (m *UserMutation) GithubAccountsIDs() (ids []int) {
	for id := range m.github_accounts {
		ids = append(ids, id)
	}
	return
}

// ResetGithubAccounts resets all changes to the "github_accounts" edge.
func (m *UserMutation) ResetGithubAccounts() {
	m.github_accounts = nil
	m.clearedgithub_accounts = false
	m.removedgithub_accounts = nil
}

// AddProjectContributionIDs adds the "project_contributions" edge to the ProjectContributor entity by ids.
func (m *UserMutation) AddProjectContributionIDs(ids ...int) {
	if m.project_contributions == nil {
		m.project_contributions = make(map[int]struct{})
	}
	for i := range ids {
		m.project_contributions[ids[i]] = struct{}{}
	}
}

// ClearProjectContributions clears the "project_contributions" edge to the ProjectContributor entity.
func (m *UserMutation) ClearProjectContributions() {
	m.clearedproject_contributions = true
}

// ProjectContributionsCleared reports if the "project_contributions" edge to the ProjectContributor entity was cleared.
func (m *UserMutation) ProjectContributionsCleared() bool {
	return m.clearedproject_contributions
}

// RemoveProjectContributionIDs removes the "project_contributions" edge to the ProjectContributor entity by IDs.
func (m *UserMutation) RemoveProjectContributionIDs(ids ...int) {
	if m.removedproject_contributions == nil {
		m.removedproject_contributions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project_contributions, ids[i])
		m.removedproject_contributions[ids[i]] = struct{}{}
	}
}

// RemovedProjectContributions returns the removed IDs of the "project_contributions" edge to the ProjectContributor entity.
func (m *UserMutation) RemovedProjectContributionsIDs() (ids []int) {
	for id := range m.removedproject_contributions {
		ids = append(ids, id)
	}
	return
}

// ProjectContributionsIDs returns the "project_contributions" edge IDs in the mutation.
func (m *UserMutation) ProjectContributionsIDs() (ids []int) {
	for id := range m.project_contributions {
		ids = append(ids, id)
	}
	return
}

// ResetProjectContributions resets all changes to the "project_contributions" edge.
func (m *UserMutation) ResetProjectContributions() {
	m.project_contributions = nil
	m.clearedproject_contributions = false
	m.removedproject_contributions = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.discord_accounts != nil {
		edges = append(edges, user.EdgeDiscordAccounts)
	}
	if m.github_accounts != nil {
		edges = append(edges, user.EdgeGithubAccounts)
	}
	if m.project_contributions != nil {
		edges = append(edges, user.EdgeProjectContributions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDiscordAccounts:
		ids := make([]ent.Value, 0, len(m.discord_accounts))
		for id := range m.discord_accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGithubAccounts:
		ids := make([]ent.Value, 0, len(m.github_accounts))
		for id := range m.github_accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjectContributions:
		ids := make([]ent.Value, 0, len(m.project_contributions))
		for id := range m.project_contributions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddiscord_accounts != nil {
		edges = append(edges, user.EdgeDiscordAccounts)
	}
	if m.removedgithub_accounts != nil {
		edges = append(edges, user.EdgeGithubAccounts)
	}
	if m.removedproject_contributions != nil {
		edges = append(edges, user.EdgeProjectContributions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDiscordAccounts:
		ids := make([]ent.Value, 0, len(m.removeddiscord_accounts))
		for id := range m.removeddiscord_accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGithubAccounts:
		ids := make([]ent.Value, 0, len(m.removedgithub_accounts))
		for id := range m.removedgithub_accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjectContributions:
		ids := make([]ent.Value, 0, len(m.removedproject_contributions))
		for id := range m.removedproject_contributions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddiscord_accounts {
		edges = append(edges, user.EdgeDiscordAccounts)
	}
	if m.clearedgithub_accounts {
		edges = append(edges, user.EdgeGithubAccounts)
	}
	if m.clearedproject_contributions {
		edges = append(edges, user.EdgeProjectContributions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeDiscordAccounts:
		return m.cleareddiscord_accounts
	case user.EdgeGithubAccounts:
		return m.clearedgithub_accounts
	case user.EdgeProjectContributions:
		return m.clearedproject_contributions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeDiscordAccounts:
		m.ResetDiscordAccounts()
		return nil
	case user.EdgeGithubAccounts:
		m.ResetGithubAccounts()
		return nil
	case user.EdgeProjectContributions:
		m.ResetProjectContributions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
