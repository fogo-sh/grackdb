// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/fogo-sh/grackdb/ent"
	"github.com/fogo-sh/grackdb/ent/githuborganizationmember"
	"github.com/fogo-sh/grackdb/ent/projectassociation"
	"github.com/fogo-sh/grackdb/ent/projectcontributor"
	"github.com/fogo-sh/grackdb/ent/projecttechnology"
	"github.com/fogo-sh/grackdb/ent/repositorytechnology"
	"github.com/fogo-sh/grackdb/ent/technology"
	"github.com/fogo-sh/grackdb/ent/technologyassociation"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AuthProvider struct {
		Type func(childComplexity int) int
		URL  func(childComplexity int) int
	}

	DiscordAccount struct {
		Bot           func(childComplexity int) int
		DiscordID     func(childComplexity int) int
		Discriminator func(childComplexity int) int
		ID            func(childComplexity int) int
		Owner         func(childComplexity int) int
		Username      func(childComplexity int) int
	}

	DiscordAccountConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	DiscordAccountEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	DiscordBot struct {
		Account    func(childComplexity int) int
		ID         func(childComplexity int) int
		Project    func(childComplexity int) int
		Repository func(childComplexity int) int
	}

	DiscordBotConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	DiscordBotEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	GithubAccount struct {
		ID                      func(childComplexity int) int
		OrganizationMemberships func(childComplexity int) int
		Owner                   func(childComplexity int) int
		Repositories            func(childComplexity int) int
		Username                func(childComplexity int) int
	}

	GithubAccountConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	GithubAccountEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	GithubOrganization struct {
		DisplayName  func(childComplexity int) int
		ID           func(childComplexity int) int
		Members      func(childComplexity int) int
		Name         func(childComplexity int) int
		Repositories func(childComplexity int) int
	}

	GithubOrganizationConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	GithubOrganizationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	GithubOrganizationMember struct {
		Account      func(childComplexity int) int
		ID           func(childComplexity int) int
		Organization func(childComplexity int) int
		Role         func(childComplexity int) int
	}

	GithubOrganizationMemberConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	GithubOrganizationMemberEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Mutation struct {
		AssumeDevelopmentUser          func(childComplexity int, id int) int
		CreateDiscordAccount           func(childComplexity int, input ent.CreateDiscordAccountInput) int
		CreateDiscordBot               func(childComplexity int, input ent.CreateDiscordBotInput) int
		CreateGithubAccount            func(childComplexity int, input ent.CreateGithubAccountInput) int
		CreateGithubOrganization       func(childComplexity int, input ent.CreateGithubOrganizationInput) int
		CreateGithubOrganizationMember func(childComplexity int, input ent.CreateGithubOrganizationMemberInput) int
		CreateProject                  func(childComplexity int, input ent.CreateProjectInput) int
		CreateProjectAssociation       func(childComplexity int, input ent.CreateProjectAssociationInput) int
		CreateProjectContributor       func(childComplexity int, input ent.CreateProjectContributorInput) int
		CreateProjectTechnology        func(childComplexity int, input ent.CreateProjectTechnologyInput) int
		CreateRepository               func(childComplexity int, input ent.CreateRepositoryInput) int
		CreateRepositoryTechnology     func(childComplexity int, input ent.CreateRepositoryTechnologyInput) int
		CreateSite                     func(childComplexity int, input ent.CreateSiteInput) int
		CreateTechnology               func(childComplexity int, input ent.CreateTechnologyInput) int
		CreateTechnologyAssociation    func(childComplexity int, input ent.CreateTechnologyAssociationInput) int
		CreateUser                     func(childComplexity int, input ent.CreateUserInput) int
		DeleteDiscordAccount           func(childComplexity int, id int) int
		DeleteDiscordBot               func(childComplexity int, id int) int
		DeleteGithubAccount            func(childComplexity int, id int) int
		DeleteGithubOrganization       func(childComplexity int, id int) int
		DeleteGithubOrganizationMember func(childComplexity int, id int) int
		DeleteProject                  func(childComplexity int, id int) int
		DeleteProjectAssociation       func(childComplexity int, id int) int
		DeleteProjectContributor       func(childComplexity int, id int) int
		DeleteProjectTechnology        func(childComplexity int, id int) int
		DeleteRepository               func(childComplexity int, id int) int
		DeleteRepositoryTechnology     func(childComplexity int, id int) int
		DeleteSite                     func(childComplexity int, id int) int
		DeleteTechnology               func(childComplexity int, id int) int
		DeleteTechnologyAssociation    func(childComplexity int, id int) int
		DeleteUser                     func(childComplexity int, id int) int
		UpdateDiscordAccount           func(childComplexity int, id int, input ent.UpdateDiscordAccountInput) int
		UpdateDiscordBot               func(childComplexity int, id int, input ent.UpdateDiscordBotInput) int
		UpdateGithubAccount            func(childComplexity int, id int, input ent.UpdateGithubAccountInput) int
		UpdateGithubOrganization       func(childComplexity int, id int, input ent.UpdateGithubOrganizationInput) int
		UpdateGithubOrganizationMember func(childComplexity int, id int, input ent.UpdateGithubOrganizationMemberInput) int
		UpdateProject                  func(childComplexity int, id int, input ent.UpdateProjectInput) int
		UpdateProjectAssociation       func(childComplexity int, id int, input ent.UpdateProjectAssociationInput) int
		UpdateProjectContributor       func(childComplexity int, id int, input ent.UpdateProjectContributorInput) int
		UpdateProjectTechnology        func(childComplexity int, id int, input ent.UpdateProjectTechnologyInput) int
		UpdateRepository               func(childComplexity int, id int, input ent.UpdateRepositoryInput) int
		UpdateRepositoryTechnology     func(childComplexity int, id int, input ent.UpdateRepositoryTechnologyInput) int
		UpdateSite                     func(childComplexity int, id int, input ent.UpdateSiteInput) int
		UpdateTechnology               func(childComplexity int, id int, input ent.UpdateTechnologyInput) int
		UpdateTechnologyAssociation    func(childComplexity int, id int, input ent.UpdateTechnologyAssociationInput) int
		UpdateUser                     func(childComplexity int, id int, input ent.UpdateUserInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Project struct {
		ChildProjects  func(childComplexity int) int
		Contributors   func(childComplexity int) int
		Description    func(childComplexity int) int
		DiscordBots    func(childComplexity int) int
		EndDate        func(childComplexity int) int
		ID             func(childComplexity int) int
		Name           func(childComplexity int) int
		ParentProjects func(childComplexity int) int
		Repositories   func(childComplexity int) int
		Sites          func(childComplexity int) int
		StartDate      func(childComplexity int) int
		Technologies   func(childComplexity int) int
	}

	ProjectAssociation struct {
		Child  func(childComplexity int) int
		ID     func(childComplexity int) int
		Parent func(childComplexity int) int
		Type   func(childComplexity int) int
	}

	ProjectAssociationConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ProjectAssociationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ProjectConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ProjectContributor struct {
		ID      func(childComplexity int) int
		Project func(childComplexity int) int
		Role    func(childComplexity int) int
		User    func(childComplexity int) int
	}

	ProjectContributorConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ProjectContributorEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ProjectEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ProjectTechnology struct {
		ID         func(childComplexity int) int
		Project    func(childComplexity int) int
		Technology func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	ProjectTechnologyConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ProjectTechnologyEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Query struct {
		AvailableAuthProviders    func(childComplexity int) int
		CurrentUser               func(childComplexity int) int
		DevelopmentMode           func(childComplexity int) int
		DiscordAccounts           func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.DiscordAccountOrder, where *ent.DiscordAccountWhereInput) int
		DiscordBots               func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, where *ent.DiscordBotWhereInput) int
		GithubAccounts            func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubAccountOrder, where *ent.GithubAccountWhereInput) int
		GithubOrganizationMembers func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubOrganizationMemberOrder, where *ent.GithubOrganizationMemberWhereInput) int
		GithubOrganizations       func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubOrganizationOrder, where *ent.GithubOrganizationWhereInput) int
		Node                      func(childComplexity int, id int) int
		Nodes                     func(childComplexity int, ids []int) int
		ProjectAssociations       func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ProjectAssociationOrder, where *ent.ProjectAssociationWhereInput) int
		ProjectContributors       func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ProjectContributorOrder, where *ent.ProjectContributorWhereInput) int
		ProjectTechnologies       func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ProjectTechnologyOrder, where *ent.ProjectTechnologyWhereInput) int
		Projects                  func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ProjectOrder, where *ent.ProjectWhereInput) int
		Repositories              func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.RepositoryOrder, where *ent.RepositoryWhereInput) int
		RepositoryTechnologies    func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.RepositoryTechnologyOrder, where *ent.RepositoryTechnologyWhereInput) int
		Sites                     func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.SiteOrder, where *ent.SiteWhereInput) int
		Technologies              func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TechnologyOrder, where *ent.TechnologyWhereInput) int
		TechnologyAssociations    func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TechnologyAssociationOrder, where *ent.TechnologyAssociationWhereInput) int
		Users                     func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.UserOrder, where *ent.UserWhereInput) int
	}

	Repository struct {
		Description        func(childComplexity int) int
		DiscordBots        func(childComplexity int) int
		GithubAccount      func(childComplexity int) int
		GithubOrganization func(childComplexity int) int
		ID                 func(childComplexity int) int
		Name               func(childComplexity int) int
		Project            func(childComplexity int) int
		Sites              func(childComplexity int) int
		Technologies       func(childComplexity int) int
	}

	RepositoryConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	RepositoryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RepositoryTechnology struct {
		ID         func(childComplexity int) int
		Repository func(childComplexity int) int
		Technology func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	RepositoryTechnologyConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	RepositoryTechnologyEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Site struct {
		ID         func(childComplexity int) int
		Project    func(childComplexity int) int
		Repository func(childComplexity int) int
		URL        func(childComplexity int) int
	}

	SiteConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	SiteEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Technology struct {
		ChildTechnologies  func(childComplexity int) int
		Colour             func(childComplexity int) int
		Description        func(childComplexity int) int
		ID                 func(childComplexity int) int
		Name               func(childComplexity int) int
		ParentTechnologies func(childComplexity int) int
		Projects           func(childComplexity int) int
		Repositories       func(childComplexity int) int
		Type               func(childComplexity int) int
	}

	TechnologyAssociation struct {
		Child  func(childComplexity int) int
		ID     func(childComplexity int) int
		Parent func(childComplexity int) int
		Type   func(childComplexity int) int
	}

	TechnologyAssociationConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TechnologyAssociationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TechnologyConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TechnologyEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	User struct {
		AvatarURL            func(childComplexity int) int
		DiscordAccounts      func(childComplexity int) int
		GithubAccounts       func(childComplexity int) int
		ID                   func(childComplexity int) int
		ProjectContributions func(childComplexity int) int
		Username             func(childComplexity int) int
	}

	UserConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateUser(ctx context.Context, input ent.CreateUserInput) (*ent.User, error)
	UpdateUser(ctx context.Context, id int, input ent.UpdateUserInput) (*ent.User, error)
	DeleteUser(ctx context.Context, id int) (*ent.User, error)
	CreateDiscordAccount(ctx context.Context, input ent.CreateDiscordAccountInput) (*ent.DiscordAccount, error)
	UpdateDiscordAccount(ctx context.Context, id int, input ent.UpdateDiscordAccountInput) (*ent.DiscordAccount, error)
	DeleteDiscordAccount(ctx context.Context, id int) (*ent.DiscordAccount, error)
	CreateDiscordBot(ctx context.Context, input ent.CreateDiscordBotInput) (*ent.DiscordBot, error)
	UpdateDiscordBot(ctx context.Context, id int, input ent.UpdateDiscordBotInput) (*ent.DiscordBot, error)
	DeleteDiscordBot(ctx context.Context, id int) (*ent.DiscordBot, error)
	CreateGithubAccount(ctx context.Context, input ent.CreateGithubAccountInput) (*ent.GithubAccount, error)
	UpdateGithubAccount(ctx context.Context, id int, input ent.UpdateGithubAccountInput) (*ent.GithubAccount, error)
	DeleteGithubAccount(ctx context.Context, id int) (*ent.GithubAccount, error)
	CreateGithubOrganization(ctx context.Context, input ent.CreateGithubOrganizationInput) (*ent.GithubOrganization, error)
	UpdateGithubOrganization(ctx context.Context, id int, input ent.UpdateGithubOrganizationInput) (*ent.GithubOrganization, error)
	DeleteGithubOrganization(ctx context.Context, id int) (*ent.GithubOrganization, error)
	CreateGithubOrganizationMember(ctx context.Context, input ent.CreateGithubOrganizationMemberInput) (*ent.GithubOrganizationMember, error)
	UpdateGithubOrganizationMember(ctx context.Context, id int, input ent.UpdateGithubOrganizationMemberInput) (*ent.GithubOrganizationMember, error)
	DeleteGithubOrganizationMember(ctx context.Context, id int) (*ent.GithubOrganizationMember, error)
	CreateProject(ctx context.Context, input ent.CreateProjectInput) (*ent.Project, error)
	UpdateProject(ctx context.Context, id int, input ent.UpdateProjectInput) (*ent.Project, error)
	DeleteProject(ctx context.Context, id int) (*ent.Project, error)
	CreateProjectContributor(ctx context.Context, input ent.CreateProjectContributorInput) (*ent.ProjectContributor, error)
	UpdateProjectContributor(ctx context.Context, id int, input ent.UpdateProjectContributorInput) (*ent.ProjectContributor, error)
	DeleteProjectContributor(ctx context.Context, id int) (*ent.ProjectContributor, error)
	CreateProjectAssociation(ctx context.Context, input ent.CreateProjectAssociationInput) (*ent.ProjectAssociation, error)
	UpdateProjectAssociation(ctx context.Context, id int, input ent.UpdateProjectAssociationInput) (*ent.ProjectAssociation, error)
	DeleteProjectAssociation(ctx context.Context, id int) (*ent.ProjectAssociation, error)
	CreateRepository(ctx context.Context, input ent.CreateRepositoryInput) (*ent.Repository, error)
	UpdateRepository(ctx context.Context, id int, input ent.UpdateRepositoryInput) (*ent.Repository, error)
	DeleteRepository(ctx context.Context, id int) (*ent.Repository, error)
	CreateSite(ctx context.Context, input ent.CreateSiteInput) (*ent.Site, error)
	UpdateSite(ctx context.Context, id int, input ent.UpdateSiteInput) (*ent.Site, error)
	DeleteSite(ctx context.Context, id int) (*ent.Site, error)
	CreateTechnology(ctx context.Context, input ent.CreateTechnologyInput) (*ent.Technology, error)
	UpdateTechnology(ctx context.Context, id int, input ent.UpdateTechnologyInput) (*ent.Technology, error)
	DeleteTechnology(ctx context.Context, id int) (*ent.Technology, error)
	CreateTechnologyAssociation(ctx context.Context, input ent.CreateTechnologyAssociationInput) (*ent.TechnologyAssociation, error)
	UpdateTechnologyAssociation(ctx context.Context, id int, input ent.UpdateTechnologyAssociationInput) (*ent.TechnologyAssociation, error)
	DeleteTechnologyAssociation(ctx context.Context, id int) (*ent.TechnologyAssociation, error)
	CreateProjectTechnology(ctx context.Context, input ent.CreateProjectTechnologyInput) (*ent.ProjectTechnology, error)
	UpdateProjectTechnology(ctx context.Context, id int, input ent.UpdateProjectTechnologyInput) (*ent.ProjectTechnology, error)
	DeleteProjectTechnology(ctx context.Context, id int) (*ent.ProjectTechnology, error)
	CreateRepositoryTechnology(ctx context.Context, input ent.CreateRepositoryTechnologyInput) (*ent.RepositoryTechnology, error)
	UpdateRepositoryTechnology(ctx context.Context, id int, input ent.UpdateRepositoryTechnologyInput) (*ent.RepositoryTechnology, error)
	DeleteRepositoryTechnology(ctx context.Context, id int) (*ent.RepositoryTechnology, error)
	AssumeDevelopmentUser(ctx context.Context, id int) (*ent.User, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id int) (ent.Noder, error)
	Nodes(ctx context.Context, ids []int) ([]ent.Noder, error)
	DiscordAccounts(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.DiscordAccountOrder, where *ent.DiscordAccountWhereInput) (*ent.DiscordAccountConnection, error)
	DiscordBots(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, where *ent.DiscordBotWhereInput) (*ent.DiscordBotConnection, error)
	GithubAccounts(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubAccountOrder, where *ent.GithubAccountWhereInput) (*ent.GithubAccountConnection, error)
	GithubOrganizations(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubOrganizationOrder, where *ent.GithubOrganizationWhereInput) (*ent.GithubOrganizationConnection, error)
	GithubOrganizationMembers(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubOrganizationMemberOrder, where *ent.GithubOrganizationMemberWhereInput) (*ent.GithubOrganizationMemberConnection, error)
	Projects(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ProjectOrder, where *ent.ProjectWhereInput) (*ent.ProjectConnection, error)
	ProjectAssociations(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ProjectAssociationOrder, where *ent.ProjectAssociationWhereInput) (*ent.ProjectAssociationConnection, error)
	ProjectContributors(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ProjectContributorOrder, where *ent.ProjectContributorWhereInput) (*ent.ProjectContributorConnection, error)
	ProjectTechnologies(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ProjectTechnologyOrder, where *ent.ProjectTechnologyWhereInput) (*ent.ProjectTechnologyConnection, error)
	Repositories(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.RepositoryOrder, where *ent.RepositoryWhereInput) (*ent.RepositoryConnection, error)
	RepositoryTechnologies(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.RepositoryTechnologyOrder, where *ent.RepositoryTechnologyWhereInput) (*ent.RepositoryTechnologyConnection, error)
	Sites(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.SiteOrder, where *ent.SiteWhereInput) (*ent.SiteConnection, error)
	Technologies(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TechnologyOrder, where *ent.TechnologyWhereInput) (*ent.TechnologyConnection, error)
	TechnologyAssociations(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TechnologyAssociationOrder, where *ent.TechnologyAssociationWhereInput) (*ent.TechnologyAssociationConnection, error)
	Users(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.UserOrder, where *ent.UserWhereInput) (*ent.UserConnection, error)
	AvailableAuthProviders(ctx context.Context) ([]*AuthProvider, error)
	CurrentUser(ctx context.Context) (*ent.User, error)
	DevelopmentMode(ctx context.Context) (bool, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AuthProvider.type":
		if e.complexity.AuthProvider.Type == nil {
			break
		}

		return e.complexity.AuthProvider.Type(childComplexity), true

	case "AuthProvider.url":
		if e.complexity.AuthProvider.URL == nil {
			break
		}

		return e.complexity.AuthProvider.URL(childComplexity), true

	case "DiscordAccount.bot":
		if e.complexity.DiscordAccount.Bot == nil {
			break
		}

		return e.complexity.DiscordAccount.Bot(childComplexity), true

	case "DiscordAccount.discordID":
		if e.complexity.DiscordAccount.DiscordID == nil {
			break
		}

		return e.complexity.DiscordAccount.DiscordID(childComplexity), true

	case "DiscordAccount.discriminator":
		if e.complexity.DiscordAccount.Discriminator == nil {
			break
		}

		return e.complexity.DiscordAccount.Discriminator(childComplexity), true

	case "DiscordAccount.id":
		if e.complexity.DiscordAccount.ID == nil {
			break
		}

		return e.complexity.DiscordAccount.ID(childComplexity), true

	case "DiscordAccount.owner":
		if e.complexity.DiscordAccount.Owner == nil {
			break
		}

		return e.complexity.DiscordAccount.Owner(childComplexity), true

	case "DiscordAccount.username":
		if e.complexity.DiscordAccount.Username == nil {
			break
		}

		return e.complexity.DiscordAccount.Username(childComplexity), true

	case "DiscordAccountConnection.edges":
		if e.complexity.DiscordAccountConnection.Edges == nil {
			break
		}

		return e.complexity.DiscordAccountConnection.Edges(childComplexity), true

	case "DiscordAccountConnection.pageInfo":
		if e.complexity.DiscordAccountConnection.PageInfo == nil {
			break
		}

		return e.complexity.DiscordAccountConnection.PageInfo(childComplexity), true

	case "DiscordAccountConnection.totalCount":
		if e.complexity.DiscordAccountConnection.TotalCount == nil {
			break
		}

		return e.complexity.DiscordAccountConnection.TotalCount(childComplexity), true

	case "DiscordAccountEdge.cursor":
		if e.complexity.DiscordAccountEdge.Cursor == nil {
			break
		}

		return e.complexity.DiscordAccountEdge.Cursor(childComplexity), true

	case "DiscordAccountEdge.node":
		if e.complexity.DiscordAccountEdge.Node == nil {
			break
		}

		return e.complexity.DiscordAccountEdge.Node(childComplexity), true

	case "DiscordBot.account":
		if e.complexity.DiscordBot.Account == nil {
			break
		}

		return e.complexity.DiscordBot.Account(childComplexity), true

	case "DiscordBot.id":
		if e.complexity.DiscordBot.ID == nil {
			break
		}

		return e.complexity.DiscordBot.ID(childComplexity), true

	case "DiscordBot.project":
		if e.complexity.DiscordBot.Project == nil {
			break
		}

		return e.complexity.DiscordBot.Project(childComplexity), true

	case "DiscordBot.repository":
		if e.complexity.DiscordBot.Repository == nil {
			break
		}

		return e.complexity.DiscordBot.Repository(childComplexity), true

	case "DiscordBotConnection.edges":
		if e.complexity.DiscordBotConnection.Edges == nil {
			break
		}

		return e.complexity.DiscordBotConnection.Edges(childComplexity), true

	case "DiscordBotConnection.pageInfo":
		if e.complexity.DiscordBotConnection.PageInfo == nil {
			break
		}

		return e.complexity.DiscordBotConnection.PageInfo(childComplexity), true

	case "DiscordBotConnection.totalCount":
		if e.complexity.DiscordBotConnection.TotalCount == nil {
			break
		}

		return e.complexity.DiscordBotConnection.TotalCount(childComplexity), true

	case "DiscordBotEdge.cursor":
		if e.complexity.DiscordBotEdge.Cursor == nil {
			break
		}

		return e.complexity.DiscordBotEdge.Cursor(childComplexity), true

	case "DiscordBotEdge.node":
		if e.complexity.DiscordBotEdge.Node == nil {
			break
		}

		return e.complexity.DiscordBotEdge.Node(childComplexity), true

	case "GithubAccount.id":
		if e.complexity.GithubAccount.ID == nil {
			break
		}

		return e.complexity.GithubAccount.ID(childComplexity), true

	case "GithubAccount.organizationMemberships":
		if e.complexity.GithubAccount.OrganizationMemberships == nil {
			break
		}

		return e.complexity.GithubAccount.OrganizationMemberships(childComplexity), true

	case "GithubAccount.owner":
		if e.complexity.GithubAccount.Owner == nil {
			break
		}

		return e.complexity.GithubAccount.Owner(childComplexity), true

	case "GithubAccount.repositories":
		if e.complexity.GithubAccount.Repositories == nil {
			break
		}

		return e.complexity.GithubAccount.Repositories(childComplexity), true

	case "GithubAccount.username":
		if e.complexity.GithubAccount.Username == nil {
			break
		}

		return e.complexity.GithubAccount.Username(childComplexity), true

	case "GithubAccountConnection.edges":
		if e.complexity.GithubAccountConnection.Edges == nil {
			break
		}

		return e.complexity.GithubAccountConnection.Edges(childComplexity), true

	case "GithubAccountConnection.pageInfo":
		if e.complexity.GithubAccountConnection.PageInfo == nil {
			break
		}

		return e.complexity.GithubAccountConnection.PageInfo(childComplexity), true

	case "GithubAccountConnection.totalCount":
		if e.complexity.GithubAccountConnection.TotalCount == nil {
			break
		}

		return e.complexity.GithubAccountConnection.TotalCount(childComplexity), true

	case "GithubAccountEdge.cursor":
		if e.complexity.GithubAccountEdge.Cursor == nil {
			break
		}

		return e.complexity.GithubAccountEdge.Cursor(childComplexity), true

	case "GithubAccountEdge.node":
		if e.complexity.GithubAccountEdge.Node == nil {
			break
		}

		return e.complexity.GithubAccountEdge.Node(childComplexity), true

	case "GithubOrganization.displayName":
		if e.complexity.GithubOrganization.DisplayName == nil {
			break
		}

		return e.complexity.GithubOrganization.DisplayName(childComplexity), true

	case "GithubOrganization.id":
		if e.complexity.GithubOrganization.ID == nil {
			break
		}

		return e.complexity.GithubOrganization.ID(childComplexity), true

	case "GithubOrganization.members":
		if e.complexity.GithubOrganization.Members == nil {
			break
		}

		return e.complexity.GithubOrganization.Members(childComplexity), true

	case "GithubOrganization.name":
		if e.complexity.GithubOrganization.Name == nil {
			break
		}

		return e.complexity.GithubOrganization.Name(childComplexity), true

	case "GithubOrganization.repositories":
		if e.complexity.GithubOrganization.Repositories == nil {
			break
		}

		return e.complexity.GithubOrganization.Repositories(childComplexity), true

	case "GithubOrganizationConnection.edges":
		if e.complexity.GithubOrganizationConnection.Edges == nil {
			break
		}

		return e.complexity.GithubOrganizationConnection.Edges(childComplexity), true

	case "GithubOrganizationConnection.pageInfo":
		if e.complexity.GithubOrganizationConnection.PageInfo == nil {
			break
		}

		return e.complexity.GithubOrganizationConnection.PageInfo(childComplexity), true

	case "GithubOrganizationConnection.totalCount":
		if e.complexity.GithubOrganizationConnection.TotalCount == nil {
			break
		}

		return e.complexity.GithubOrganizationConnection.TotalCount(childComplexity), true

	case "GithubOrganizationEdge.cursor":
		if e.complexity.GithubOrganizationEdge.Cursor == nil {
			break
		}

		return e.complexity.GithubOrganizationEdge.Cursor(childComplexity), true

	case "GithubOrganizationEdge.node":
		if e.complexity.GithubOrganizationEdge.Node == nil {
			break
		}

		return e.complexity.GithubOrganizationEdge.Node(childComplexity), true

	case "GithubOrganizationMember.account":
		if e.complexity.GithubOrganizationMember.Account == nil {
			break
		}

		return e.complexity.GithubOrganizationMember.Account(childComplexity), true

	case "GithubOrganizationMember.id":
		if e.complexity.GithubOrganizationMember.ID == nil {
			break
		}

		return e.complexity.GithubOrganizationMember.ID(childComplexity), true

	case "GithubOrganizationMember.organization":
		if e.complexity.GithubOrganizationMember.Organization == nil {
			break
		}

		return e.complexity.GithubOrganizationMember.Organization(childComplexity), true

	case "GithubOrganizationMember.role":
		if e.complexity.GithubOrganizationMember.Role == nil {
			break
		}

		return e.complexity.GithubOrganizationMember.Role(childComplexity), true

	case "GithubOrganizationMemberConnection.edges":
		if e.complexity.GithubOrganizationMemberConnection.Edges == nil {
			break
		}

		return e.complexity.GithubOrganizationMemberConnection.Edges(childComplexity), true

	case "GithubOrganizationMemberConnection.pageInfo":
		if e.complexity.GithubOrganizationMemberConnection.PageInfo == nil {
			break
		}

		return e.complexity.GithubOrganizationMemberConnection.PageInfo(childComplexity), true

	case "GithubOrganizationMemberConnection.totalCount":
		if e.complexity.GithubOrganizationMemberConnection.TotalCount == nil {
			break
		}

		return e.complexity.GithubOrganizationMemberConnection.TotalCount(childComplexity), true

	case "GithubOrganizationMemberEdge.cursor":
		if e.complexity.GithubOrganizationMemberEdge.Cursor == nil {
			break
		}

		return e.complexity.GithubOrganizationMemberEdge.Cursor(childComplexity), true

	case "GithubOrganizationMemberEdge.node":
		if e.complexity.GithubOrganizationMemberEdge.Node == nil {
			break
		}

		return e.complexity.GithubOrganizationMemberEdge.Node(childComplexity), true

	case "Mutation.assumeDevelopmentUser":
		if e.complexity.Mutation.AssumeDevelopmentUser == nil {
			break
		}

		args, err := ec.field_Mutation_assumeDevelopmentUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AssumeDevelopmentUser(childComplexity, args["id"].(int)), true

	case "Mutation.createDiscordAccount":
		if e.complexity.Mutation.CreateDiscordAccount == nil {
			break
		}

		args, err := ec.field_Mutation_createDiscordAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDiscordAccount(childComplexity, args["input"].(ent.CreateDiscordAccountInput)), true

	case "Mutation.createDiscordBot":
		if e.complexity.Mutation.CreateDiscordBot == nil {
			break
		}

		args, err := ec.field_Mutation_createDiscordBot_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDiscordBot(childComplexity, args["input"].(ent.CreateDiscordBotInput)), true

	case "Mutation.createGithubAccount":
		if e.complexity.Mutation.CreateGithubAccount == nil {
			break
		}

		args, err := ec.field_Mutation_createGithubAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateGithubAccount(childComplexity, args["input"].(ent.CreateGithubAccountInput)), true

	case "Mutation.createGithubOrganization":
		if e.complexity.Mutation.CreateGithubOrganization == nil {
			break
		}

		args, err := ec.field_Mutation_createGithubOrganization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateGithubOrganization(childComplexity, args["input"].(ent.CreateGithubOrganizationInput)), true

	case "Mutation.createGithubOrganizationMember":
		if e.complexity.Mutation.CreateGithubOrganizationMember == nil {
			break
		}

		args, err := ec.field_Mutation_createGithubOrganizationMember_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateGithubOrganizationMember(childComplexity, args["input"].(ent.CreateGithubOrganizationMemberInput)), true

	case "Mutation.createProject":
		if e.complexity.Mutation.CreateProject == nil {
			break
		}

		args, err := ec.field_Mutation_createProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProject(childComplexity, args["input"].(ent.CreateProjectInput)), true

	case "Mutation.createProjectAssociation":
		if e.complexity.Mutation.CreateProjectAssociation == nil {
			break
		}

		args, err := ec.field_Mutation_createProjectAssociation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProjectAssociation(childComplexity, args["input"].(ent.CreateProjectAssociationInput)), true

	case "Mutation.createProjectContributor":
		if e.complexity.Mutation.CreateProjectContributor == nil {
			break
		}

		args, err := ec.field_Mutation_createProjectContributor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProjectContributor(childComplexity, args["input"].(ent.CreateProjectContributorInput)), true

	case "Mutation.createProjectTechnology":
		if e.complexity.Mutation.CreateProjectTechnology == nil {
			break
		}

		args, err := ec.field_Mutation_createProjectTechnology_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProjectTechnology(childComplexity, args["input"].(ent.CreateProjectTechnologyInput)), true

	case "Mutation.createRepository":
		if e.complexity.Mutation.CreateRepository == nil {
			break
		}

		args, err := ec.field_Mutation_createRepository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRepository(childComplexity, args["input"].(ent.CreateRepositoryInput)), true

	case "Mutation.createRepositoryTechnology":
		if e.complexity.Mutation.CreateRepositoryTechnology == nil {
			break
		}

		args, err := ec.field_Mutation_createRepositoryTechnology_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRepositoryTechnology(childComplexity, args["input"].(ent.CreateRepositoryTechnologyInput)), true

	case "Mutation.createSite":
		if e.complexity.Mutation.CreateSite == nil {
			break
		}

		args, err := ec.field_Mutation_createSite_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSite(childComplexity, args["input"].(ent.CreateSiteInput)), true

	case "Mutation.createTechnology":
		if e.complexity.Mutation.CreateTechnology == nil {
			break
		}

		args, err := ec.field_Mutation_createTechnology_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTechnology(childComplexity, args["input"].(ent.CreateTechnologyInput)), true

	case "Mutation.createTechnologyAssociation":
		if e.complexity.Mutation.CreateTechnologyAssociation == nil {
			break
		}

		args, err := ec.field_Mutation_createTechnologyAssociation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTechnologyAssociation(childComplexity, args["input"].(ent.CreateTechnologyAssociationInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(ent.CreateUserInput)), true

	case "Mutation.deleteDiscordAccount":
		if e.complexity.Mutation.DeleteDiscordAccount == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDiscordAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDiscordAccount(childComplexity, args["id"].(int)), true

	case "Mutation.deleteDiscordBot":
		if e.complexity.Mutation.DeleteDiscordBot == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDiscordBot_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDiscordBot(childComplexity, args["id"].(int)), true

	case "Mutation.deleteGithubAccount":
		if e.complexity.Mutation.DeleteGithubAccount == nil {
			break
		}

		args, err := ec.field_Mutation_deleteGithubAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteGithubAccount(childComplexity, args["id"].(int)), true

	case "Mutation.deleteGithubOrganization":
		if e.complexity.Mutation.DeleteGithubOrganization == nil {
			break
		}

		args, err := ec.field_Mutation_deleteGithubOrganization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteGithubOrganization(childComplexity, args["id"].(int)), true

	case "Mutation.deleteGithubOrganizationMember":
		if e.complexity.Mutation.DeleteGithubOrganizationMember == nil {
			break
		}

		args, err := ec.field_Mutation_deleteGithubOrganizationMember_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteGithubOrganizationMember(childComplexity, args["id"].(int)), true

	case "Mutation.deleteProject":
		if e.complexity.Mutation.DeleteProject == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProject(childComplexity, args["id"].(int)), true

	case "Mutation.deleteProjectAssociation":
		if e.complexity.Mutation.DeleteProjectAssociation == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProjectAssociation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProjectAssociation(childComplexity, args["id"].(int)), true

	case "Mutation.deleteProjectContributor":
		if e.complexity.Mutation.DeleteProjectContributor == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProjectContributor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProjectContributor(childComplexity, args["id"].(int)), true

	case "Mutation.deleteProjectTechnology":
		if e.complexity.Mutation.DeleteProjectTechnology == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProjectTechnology_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProjectTechnology(childComplexity, args["id"].(int)), true

	case "Mutation.deleteRepository":
		if e.complexity.Mutation.DeleteRepository == nil {
			break
		}

		args, err := ec.field_Mutation_deleteRepository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRepository(childComplexity, args["id"].(int)), true

	case "Mutation.deleteRepositoryTechnology":
		if e.complexity.Mutation.DeleteRepositoryTechnology == nil {
			break
		}

		args, err := ec.field_Mutation_deleteRepositoryTechnology_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRepositoryTechnology(childComplexity, args["id"].(int)), true

	case "Mutation.deleteSite":
		if e.complexity.Mutation.DeleteSite == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSite_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSite(childComplexity, args["id"].(int)), true

	case "Mutation.deleteTechnology":
		if e.complexity.Mutation.DeleteTechnology == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTechnology_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTechnology(childComplexity, args["id"].(int)), true

	case "Mutation.deleteTechnologyAssociation":
		if e.complexity.Mutation.DeleteTechnologyAssociation == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTechnologyAssociation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTechnologyAssociation(childComplexity, args["id"].(int)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["id"].(int)), true

	case "Mutation.updateDiscordAccount":
		if e.complexity.Mutation.UpdateDiscordAccount == nil {
			break
		}

		args, err := ec.field_Mutation_updateDiscordAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateDiscordAccount(childComplexity, args["id"].(int), args["input"].(ent.UpdateDiscordAccountInput)), true

	case "Mutation.updateDiscordBot":
		if e.complexity.Mutation.UpdateDiscordBot == nil {
			break
		}

		args, err := ec.field_Mutation_updateDiscordBot_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateDiscordBot(childComplexity, args["id"].(int), args["input"].(ent.UpdateDiscordBotInput)), true

	case "Mutation.updateGithubAccount":
		if e.complexity.Mutation.UpdateGithubAccount == nil {
			break
		}

		args, err := ec.field_Mutation_updateGithubAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateGithubAccount(childComplexity, args["id"].(int), args["input"].(ent.UpdateGithubAccountInput)), true

	case "Mutation.updateGithubOrganization":
		if e.complexity.Mutation.UpdateGithubOrganization == nil {
			break
		}

		args, err := ec.field_Mutation_updateGithubOrganization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateGithubOrganization(childComplexity, args["id"].(int), args["input"].(ent.UpdateGithubOrganizationInput)), true

	case "Mutation.updateGithubOrganizationMember":
		if e.complexity.Mutation.UpdateGithubOrganizationMember == nil {
			break
		}

		args, err := ec.field_Mutation_updateGithubOrganizationMember_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateGithubOrganizationMember(childComplexity, args["id"].(int), args["input"].(ent.UpdateGithubOrganizationMemberInput)), true

	case "Mutation.updateProject":
		if e.complexity.Mutation.UpdateProject == nil {
			break
		}

		args, err := ec.field_Mutation_updateProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProject(childComplexity, args["id"].(int), args["input"].(ent.UpdateProjectInput)), true

	case "Mutation.updateProjectAssociation":
		if e.complexity.Mutation.UpdateProjectAssociation == nil {
			break
		}

		args, err := ec.field_Mutation_updateProjectAssociation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProjectAssociation(childComplexity, args["id"].(int), args["input"].(ent.UpdateProjectAssociationInput)), true

	case "Mutation.updateProjectContributor":
		if e.complexity.Mutation.UpdateProjectContributor == nil {
			break
		}

		args, err := ec.field_Mutation_updateProjectContributor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProjectContributor(childComplexity, args["id"].(int), args["input"].(ent.UpdateProjectContributorInput)), true

	case "Mutation.updateProjectTechnology":
		if e.complexity.Mutation.UpdateProjectTechnology == nil {
			break
		}

		args, err := ec.field_Mutation_updateProjectTechnology_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProjectTechnology(childComplexity, args["id"].(int), args["input"].(ent.UpdateProjectTechnologyInput)), true

	case "Mutation.updateRepository":
		if e.complexity.Mutation.UpdateRepository == nil {
			break
		}

		args, err := ec.field_Mutation_updateRepository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRepository(childComplexity, args["id"].(int), args["input"].(ent.UpdateRepositoryInput)), true

	case "Mutation.updateRepositoryTechnology":
		if e.complexity.Mutation.UpdateRepositoryTechnology == nil {
			break
		}

		args, err := ec.field_Mutation_updateRepositoryTechnology_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRepositoryTechnology(childComplexity, args["id"].(int), args["input"].(ent.UpdateRepositoryTechnologyInput)), true

	case "Mutation.updateSite":
		if e.complexity.Mutation.UpdateSite == nil {
			break
		}

		args, err := ec.field_Mutation_updateSite_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSite(childComplexity, args["id"].(int), args["input"].(ent.UpdateSiteInput)), true

	case "Mutation.updateTechnology":
		if e.complexity.Mutation.UpdateTechnology == nil {
			break
		}

		args, err := ec.field_Mutation_updateTechnology_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTechnology(childComplexity, args["id"].(int), args["input"].(ent.UpdateTechnologyInput)), true

	case "Mutation.updateTechnologyAssociation":
		if e.complexity.Mutation.UpdateTechnologyAssociation == nil {
			break
		}

		args, err := ec.field_Mutation_updateTechnologyAssociation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTechnologyAssociation(childComplexity, args["id"].(int), args["input"].(ent.UpdateTechnologyAssociationInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["id"].(int), args["input"].(ent.UpdateUserInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Project.childProjects":
		if e.complexity.Project.ChildProjects == nil {
			break
		}

		return e.complexity.Project.ChildProjects(childComplexity), true

	case "Project.contributors":
		if e.complexity.Project.Contributors == nil {
			break
		}

		return e.complexity.Project.Contributors(childComplexity), true

	case "Project.description":
		if e.complexity.Project.Description == nil {
			break
		}

		return e.complexity.Project.Description(childComplexity), true

	case "Project.discordBots":
		if e.complexity.Project.DiscordBots == nil {
			break
		}

		return e.complexity.Project.DiscordBots(childComplexity), true

	case "Project.endDate":
		if e.complexity.Project.EndDate == nil {
			break
		}

		return e.complexity.Project.EndDate(childComplexity), true

	case "Project.id":
		if e.complexity.Project.ID == nil {
			break
		}

		return e.complexity.Project.ID(childComplexity), true

	case "Project.name":
		if e.complexity.Project.Name == nil {
			break
		}

		return e.complexity.Project.Name(childComplexity), true

	case "Project.parentProjects":
		if e.complexity.Project.ParentProjects == nil {
			break
		}

		return e.complexity.Project.ParentProjects(childComplexity), true

	case "Project.repositories":
		if e.complexity.Project.Repositories == nil {
			break
		}

		return e.complexity.Project.Repositories(childComplexity), true

	case "Project.sites":
		if e.complexity.Project.Sites == nil {
			break
		}

		return e.complexity.Project.Sites(childComplexity), true

	case "Project.startDate":
		if e.complexity.Project.StartDate == nil {
			break
		}

		return e.complexity.Project.StartDate(childComplexity), true

	case "Project.technologies":
		if e.complexity.Project.Technologies == nil {
			break
		}

		return e.complexity.Project.Technologies(childComplexity), true

	case "ProjectAssociation.child":
		if e.complexity.ProjectAssociation.Child == nil {
			break
		}

		return e.complexity.ProjectAssociation.Child(childComplexity), true

	case "ProjectAssociation.id":
		if e.complexity.ProjectAssociation.ID == nil {
			break
		}

		return e.complexity.ProjectAssociation.ID(childComplexity), true

	case "ProjectAssociation.parent":
		if e.complexity.ProjectAssociation.Parent == nil {
			break
		}

		return e.complexity.ProjectAssociation.Parent(childComplexity), true

	case "ProjectAssociation.type":
		if e.complexity.ProjectAssociation.Type == nil {
			break
		}

		return e.complexity.ProjectAssociation.Type(childComplexity), true

	case "ProjectAssociationConnection.edges":
		if e.complexity.ProjectAssociationConnection.Edges == nil {
			break
		}

		return e.complexity.ProjectAssociationConnection.Edges(childComplexity), true

	case "ProjectAssociationConnection.pageInfo":
		if e.complexity.ProjectAssociationConnection.PageInfo == nil {
			break
		}

		return e.complexity.ProjectAssociationConnection.PageInfo(childComplexity), true

	case "ProjectAssociationConnection.totalCount":
		if e.complexity.ProjectAssociationConnection.TotalCount == nil {
			break
		}

		return e.complexity.ProjectAssociationConnection.TotalCount(childComplexity), true

	case "ProjectAssociationEdge.cursor":
		if e.complexity.ProjectAssociationEdge.Cursor == nil {
			break
		}

		return e.complexity.ProjectAssociationEdge.Cursor(childComplexity), true

	case "ProjectAssociationEdge.node":
		if e.complexity.ProjectAssociationEdge.Node == nil {
			break
		}

		return e.complexity.ProjectAssociationEdge.Node(childComplexity), true

	case "ProjectConnection.edges":
		if e.complexity.ProjectConnection.Edges == nil {
			break
		}

		return e.complexity.ProjectConnection.Edges(childComplexity), true

	case "ProjectConnection.pageInfo":
		if e.complexity.ProjectConnection.PageInfo == nil {
			break
		}

		return e.complexity.ProjectConnection.PageInfo(childComplexity), true

	case "ProjectConnection.totalCount":
		if e.complexity.ProjectConnection.TotalCount == nil {
			break
		}

		return e.complexity.ProjectConnection.TotalCount(childComplexity), true

	case "ProjectContributor.id":
		if e.complexity.ProjectContributor.ID == nil {
			break
		}

		return e.complexity.ProjectContributor.ID(childComplexity), true

	case "ProjectContributor.project":
		if e.complexity.ProjectContributor.Project == nil {
			break
		}

		return e.complexity.ProjectContributor.Project(childComplexity), true

	case "ProjectContributor.role":
		if e.complexity.ProjectContributor.Role == nil {
			break
		}

		return e.complexity.ProjectContributor.Role(childComplexity), true

	case "ProjectContributor.user":
		if e.complexity.ProjectContributor.User == nil {
			break
		}

		return e.complexity.ProjectContributor.User(childComplexity), true

	case "ProjectContributorConnection.edges":
		if e.complexity.ProjectContributorConnection.Edges == nil {
			break
		}

		return e.complexity.ProjectContributorConnection.Edges(childComplexity), true

	case "ProjectContributorConnection.pageInfo":
		if e.complexity.ProjectContributorConnection.PageInfo == nil {
			break
		}

		return e.complexity.ProjectContributorConnection.PageInfo(childComplexity), true

	case "ProjectContributorConnection.totalCount":
		if e.complexity.ProjectContributorConnection.TotalCount == nil {
			break
		}

		return e.complexity.ProjectContributorConnection.TotalCount(childComplexity), true

	case "ProjectContributorEdge.cursor":
		if e.complexity.ProjectContributorEdge.Cursor == nil {
			break
		}

		return e.complexity.ProjectContributorEdge.Cursor(childComplexity), true

	case "ProjectContributorEdge.node":
		if e.complexity.ProjectContributorEdge.Node == nil {
			break
		}

		return e.complexity.ProjectContributorEdge.Node(childComplexity), true

	case "ProjectEdge.cursor":
		if e.complexity.ProjectEdge.Cursor == nil {
			break
		}

		return e.complexity.ProjectEdge.Cursor(childComplexity), true

	case "ProjectEdge.node":
		if e.complexity.ProjectEdge.Node == nil {
			break
		}

		return e.complexity.ProjectEdge.Node(childComplexity), true

	case "ProjectTechnology.id":
		if e.complexity.ProjectTechnology.ID == nil {
			break
		}

		return e.complexity.ProjectTechnology.ID(childComplexity), true

	case "ProjectTechnology.project":
		if e.complexity.ProjectTechnology.Project == nil {
			break
		}

		return e.complexity.ProjectTechnology.Project(childComplexity), true

	case "ProjectTechnology.technology":
		if e.complexity.ProjectTechnology.Technology == nil {
			break
		}

		return e.complexity.ProjectTechnology.Technology(childComplexity), true

	case "ProjectTechnology.type":
		if e.complexity.ProjectTechnology.Type == nil {
			break
		}

		return e.complexity.ProjectTechnology.Type(childComplexity), true

	case "ProjectTechnologyConnection.edges":
		if e.complexity.ProjectTechnologyConnection.Edges == nil {
			break
		}

		return e.complexity.ProjectTechnologyConnection.Edges(childComplexity), true

	case "ProjectTechnologyConnection.pageInfo":
		if e.complexity.ProjectTechnologyConnection.PageInfo == nil {
			break
		}

		return e.complexity.ProjectTechnologyConnection.PageInfo(childComplexity), true

	case "ProjectTechnologyConnection.totalCount":
		if e.complexity.ProjectTechnologyConnection.TotalCount == nil {
			break
		}

		return e.complexity.ProjectTechnologyConnection.TotalCount(childComplexity), true

	case "ProjectTechnologyEdge.cursor":
		if e.complexity.ProjectTechnologyEdge.Cursor == nil {
			break
		}

		return e.complexity.ProjectTechnologyEdge.Cursor(childComplexity), true

	case "ProjectTechnologyEdge.node":
		if e.complexity.ProjectTechnologyEdge.Node == nil {
			break
		}

		return e.complexity.ProjectTechnologyEdge.Node(childComplexity), true

	case "Query.availableAuthProviders":
		if e.complexity.Query.AvailableAuthProviders == nil {
			break
		}

		return e.complexity.Query.AvailableAuthProviders(childComplexity), true

	case "Query.currentUser":
		if e.complexity.Query.CurrentUser == nil {
			break
		}

		return e.complexity.Query.CurrentUser(childComplexity), true

	case "Query.developmentMode":
		if e.complexity.Query.DevelopmentMode == nil {
			break
		}

		return e.complexity.Query.DevelopmentMode(childComplexity), true

	case "Query.discordAccounts":
		if e.complexity.Query.DiscordAccounts == nil {
			break
		}

		args, err := ec.field_Query_discordAccounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DiscordAccounts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.DiscordAccountOrder), args["where"].(*ent.DiscordAccountWhereInput)), true

	case "Query.discordBots":
		if e.complexity.Query.DiscordBots == nil {
			break
		}

		args, err := ec.field_Query_discordBots_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DiscordBots(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["where"].(*ent.DiscordBotWhereInput)), true

	case "Query.githubAccounts":
		if e.complexity.Query.GithubAccounts == nil {
			break
		}

		args, err := ec.field_Query_githubAccounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GithubAccounts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.GithubAccountOrder), args["where"].(*ent.GithubAccountWhereInput)), true

	case "Query.githubOrganizationMembers":
		if e.complexity.Query.GithubOrganizationMembers == nil {
			break
		}

		args, err := ec.field_Query_githubOrganizationMembers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GithubOrganizationMembers(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.GithubOrganizationMemberOrder), args["where"].(*ent.GithubOrganizationMemberWhereInput)), true

	case "Query.githubOrganizations":
		if e.complexity.Query.GithubOrganizations == nil {
			break
		}

		args, err := ec.field_Query_githubOrganizations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GithubOrganizations(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.GithubOrganizationOrder), args["where"].(*ent.GithubOrganizationWhereInput)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.projectAssociations":
		if e.complexity.Query.ProjectAssociations == nil {
			break
		}

		args, err := ec.field_Query_projectAssociations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProjectAssociations(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.ProjectAssociationOrder), args["where"].(*ent.ProjectAssociationWhereInput)), true

	case "Query.projectContributors":
		if e.complexity.Query.ProjectContributors == nil {
			break
		}

		args, err := ec.field_Query_projectContributors_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProjectContributors(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.ProjectContributorOrder), args["where"].(*ent.ProjectContributorWhereInput)), true

	case "Query.projectTechnologies":
		if e.complexity.Query.ProjectTechnologies == nil {
			break
		}

		args, err := ec.field_Query_projectTechnologies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProjectTechnologies(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.ProjectTechnologyOrder), args["where"].(*ent.ProjectTechnologyWhereInput)), true

	case "Query.projects":
		if e.complexity.Query.Projects == nil {
			break
		}

		args, err := ec.field_Query_projects_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Projects(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.ProjectOrder), args["where"].(*ent.ProjectWhereInput)), true

	case "Query.repositories":
		if e.complexity.Query.Repositories == nil {
			break
		}

		args, err := ec.field_Query_repositories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Repositories(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.RepositoryOrder), args["where"].(*ent.RepositoryWhereInput)), true

	case "Query.repositoryTechnologies":
		if e.complexity.Query.RepositoryTechnologies == nil {
			break
		}

		args, err := ec.field_Query_repositoryTechnologies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RepositoryTechnologies(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.RepositoryTechnologyOrder), args["where"].(*ent.RepositoryTechnologyWhereInput)), true

	case "Query.sites":
		if e.complexity.Query.Sites == nil {
			break
		}

		args, err := ec.field_Query_sites_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Sites(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.SiteOrder), args["where"].(*ent.SiteWhereInput)), true

	case "Query.technologies":
		if e.complexity.Query.Technologies == nil {
			break
		}

		args, err := ec.field_Query_technologies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Technologies(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TechnologyOrder), args["where"].(*ent.TechnologyWhereInput)), true

	case "Query.technologyAssociations":
		if e.complexity.Query.TechnologyAssociations == nil {
			break
		}

		args, err := ec.field_Query_technologyAssociations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TechnologyAssociations(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TechnologyAssociationOrder), args["where"].(*ent.TechnologyAssociationWhereInput)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.UserOrder), args["where"].(*ent.UserWhereInput)), true

	case "Repository.description":
		if e.complexity.Repository.Description == nil {
			break
		}

		return e.complexity.Repository.Description(childComplexity), true

	case "Repository.discordBots":
		if e.complexity.Repository.DiscordBots == nil {
			break
		}

		return e.complexity.Repository.DiscordBots(childComplexity), true

	case "Repository.githubAccount":
		if e.complexity.Repository.GithubAccount == nil {
			break
		}

		return e.complexity.Repository.GithubAccount(childComplexity), true

	case "Repository.githubOrganization":
		if e.complexity.Repository.GithubOrganization == nil {
			break
		}

		return e.complexity.Repository.GithubOrganization(childComplexity), true

	case "Repository.id":
		if e.complexity.Repository.ID == nil {
			break
		}

		return e.complexity.Repository.ID(childComplexity), true

	case "Repository.name":
		if e.complexity.Repository.Name == nil {
			break
		}

		return e.complexity.Repository.Name(childComplexity), true

	case "Repository.project":
		if e.complexity.Repository.Project == nil {
			break
		}

		return e.complexity.Repository.Project(childComplexity), true

	case "Repository.sites":
		if e.complexity.Repository.Sites == nil {
			break
		}

		return e.complexity.Repository.Sites(childComplexity), true

	case "Repository.technologies":
		if e.complexity.Repository.Technologies == nil {
			break
		}

		return e.complexity.Repository.Technologies(childComplexity), true

	case "RepositoryConnection.edges":
		if e.complexity.RepositoryConnection.Edges == nil {
			break
		}

		return e.complexity.RepositoryConnection.Edges(childComplexity), true

	case "RepositoryConnection.pageInfo":
		if e.complexity.RepositoryConnection.PageInfo == nil {
			break
		}

		return e.complexity.RepositoryConnection.PageInfo(childComplexity), true

	case "RepositoryConnection.totalCount":
		if e.complexity.RepositoryConnection.TotalCount == nil {
			break
		}

		return e.complexity.RepositoryConnection.TotalCount(childComplexity), true

	case "RepositoryEdge.cursor":
		if e.complexity.RepositoryEdge.Cursor == nil {
			break
		}

		return e.complexity.RepositoryEdge.Cursor(childComplexity), true

	case "RepositoryEdge.node":
		if e.complexity.RepositoryEdge.Node == nil {
			break
		}

		return e.complexity.RepositoryEdge.Node(childComplexity), true

	case "RepositoryTechnology.id":
		if e.complexity.RepositoryTechnology.ID == nil {
			break
		}

		return e.complexity.RepositoryTechnology.ID(childComplexity), true

	case "RepositoryTechnology.repository":
		if e.complexity.RepositoryTechnology.Repository == nil {
			break
		}

		return e.complexity.RepositoryTechnology.Repository(childComplexity), true

	case "RepositoryTechnology.technology":
		if e.complexity.RepositoryTechnology.Technology == nil {
			break
		}

		return e.complexity.RepositoryTechnology.Technology(childComplexity), true

	case "RepositoryTechnology.type":
		if e.complexity.RepositoryTechnology.Type == nil {
			break
		}

		return e.complexity.RepositoryTechnology.Type(childComplexity), true

	case "RepositoryTechnologyConnection.edges":
		if e.complexity.RepositoryTechnologyConnection.Edges == nil {
			break
		}

		return e.complexity.RepositoryTechnologyConnection.Edges(childComplexity), true

	case "RepositoryTechnologyConnection.pageInfo":
		if e.complexity.RepositoryTechnologyConnection.PageInfo == nil {
			break
		}

		return e.complexity.RepositoryTechnologyConnection.PageInfo(childComplexity), true

	case "RepositoryTechnologyConnection.totalCount":
		if e.complexity.RepositoryTechnologyConnection.TotalCount == nil {
			break
		}

		return e.complexity.RepositoryTechnologyConnection.TotalCount(childComplexity), true

	case "RepositoryTechnologyEdge.cursor":
		if e.complexity.RepositoryTechnologyEdge.Cursor == nil {
			break
		}

		return e.complexity.RepositoryTechnologyEdge.Cursor(childComplexity), true

	case "RepositoryTechnologyEdge.node":
		if e.complexity.RepositoryTechnologyEdge.Node == nil {
			break
		}

		return e.complexity.RepositoryTechnologyEdge.Node(childComplexity), true

	case "Site.id":
		if e.complexity.Site.ID == nil {
			break
		}

		return e.complexity.Site.ID(childComplexity), true

	case "Site.project":
		if e.complexity.Site.Project == nil {
			break
		}

		return e.complexity.Site.Project(childComplexity), true

	case "Site.repository":
		if e.complexity.Site.Repository == nil {
			break
		}

		return e.complexity.Site.Repository(childComplexity), true

	case "Site.url":
		if e.complexity.Site.URL == nil {
			break
		}

		return e.complexity.Site.URL(childComplexity), true

	case "SiteConnection.edges":
		if e.complexity.SiteConnection.Edges == nil {
			break
		}

		return e.complexity.SiteConnection.Edges(childComplexity), true

	case "SiteConnection.pageInfo":
		if e.complexity.SiteConnection.PageInfo == nil {
			break
		}

		return e.complexity.SiteConnection.PageInfo(childComplexity), true

	case "SiteConnection.totalCount":
		if e.complexity.SiteConnection.TotalCount == nil {
			break
		}

		return e.complexity.SiteConnection.TotalCount(childComplexity), true

	case "SiteEdge.cursor":
		if e.complexity.SiteEdge.Cursor == nil {
			break
		}

		return e.complexity.SiteEdge.Cursor(childComplexity), true

	case "SiteEdge.node":
		if e.complexity.SiteEdge.Node == nil {
			break
		}

		return e.complexity.SiteEdge.Node(childComplexity), true

	case "Technology.childTechnologies":
		if e.complexity.Technology.ChildTechnologies == nil {
			break
		}

		return e.complexity.Technology.ChildTechnologies(childComplexity), true

	case "Technology.colour":
		if e.complexity.Technology.Colour == nil {
			break
		}

		return e.complexity.Technology.Colour(childComplexity), true

	case "Technology.description":
		if e.complexity.Technology.Description == nil {
			break
		}

		return e.complexity.Technology.Description(childComplexity), true

	case "Technology.id":
		if e.complexity.Technology.ID == nil {
			break
		}

		return e.complexity.Technology.ID(childComplexity), true

	case "Technology.name":
		if e.complexity.Technology.Name == nil {
			break
		}

		return e.complexity.Technology.Name(childComplexity), true

	case "Technology.parentTechnologies":
		if e.complexity.Technology.ParentTechnologies == nil {
			break
		}

		return e.complexity.Technology.ParentTechnologies(childComplexity), true

	case "Technology.projects":
		if e.complexity.Technology.Projects == nil {
			break
		}

		return e.complexity.Technology.Projects(childComplexity), true

	case "Technology.repositories":
		if e.complexity.Technology.Repositories == nil {
			break
		}

		return e.complexity.Technology.Repositories(childComplexity), true

	case "Technology.type":
		if e.complexity.Technology.Type == nil {
			break
		}

		return e.complexity.Technology.Type(childComplexity), true

	case "TechnologyAssociation.child":
		if e.complexity.TechnologyAssociation.Child == nil {
			break
		}

		return e.complexity.TechnologyAssociation.Child(childComplexity), true

	case "TechnologyAssociation.id":
		if e.complexity.TechnologyAssociation.ID == nil {
			break
		}

		return e.complexity.TechnologyAssociation.ID(childComplexity), true

	case "TechnologyAssociation.parent":
		if e.complexity.TechnologyAssociation.Parent == nil {
			break
		}

		return e.complexity.TechnologyAssociation.Parent(childComplexity), true

	case "TechnologyAssociation.type":
		if e.complexity.TechnologyAssociation.Type == nil {
			break
		}

		return e.complexity.TechnologyAssociation.Type(childComplexity), true

	case "TechnologyAssociationConnection.edges":
		if e.complexity.TechnologyAssociationConnection.Edges == nil {
			break
		}

		return e.complexity.TechnologyAssociationConnection.Edges(childComplexity), true

	case "TechnologyAssociationConnection.pageInfo":
		if e.complexity.TechnologyAssociationConnection.PageInfo == nil {
			break
		}

		return e.complexity.TechnologyAssociationConnection.PageInfo(childComplexity), true

	case "TechnologyAssociationConnection.totalCount":
		if e.complexity.TechnologyAssociationConnection.TotalCount == nil {
			break
		}

		return e.complexity.TechnologyAssociationConnection.TotalCount(childComplexity), true

	case "TechnologyAssociationEdge.cursor":
		if e.complexity.TechnologyAssociationEdge.Cursor == nil {
			break
		}

		return e.complexity.TechnologyAssociationEdge.Cursor(childComplexity), true

	case "TechnologyAssociationEdge.node":
		if e.complexity.TechnologyAssociationEdge.Node == nil {
			break
		}

		return e.complexity.TechnologyAssociationEdge.Node(childComplexity), true

	case "TechnologyConnection.edges":
		if e.complexity.TechnologyConnection.Edges == nil {
			break
		}

		return e.complexity.TechnologyConnection.Edges(childComplexity), true

	case "TechnologyConnection.pageInfo":
		if e.complexity.TechnologyConnection.PageInfo == nil {
			break
		}

		return e.complexity.TechnologyConnection.PageInfo(childComplexity), true

	case "TechnologyConnection.totalCount":
		if e.complexity.TechnologyConnection.TotalCount == nil {
			break
		}

		return e.complexity.TechnologyConnection.TotalCount(childComplexity), true

	case "TechnologyEdge.cursor":
		if e.complexity.TechnologyEdge.Cursor == nil {
			break
		}

		return e.complexity.TechnologyEdge.Cursor(childComplexity), true

	case "TechnologyEdge.node":
		if e.complexity.TechnologyEdge.Node == nil {
			break
		}

		return e.complexity.TechnologyEdge.Node(childComplexity), true

	case "User.avatarURL":
		if e.complexity.User.AvatarURL == nil {
			break
		}

		return e.complexity.User.AvatarURL(childComplexity), true

	case "User.discordAccounts":
		if e.complexity.User.DiscordAccounts == nil {
			break
		}

		return e.complexity.User.DiscordAccounts(childComplexity), true

	case "User.githubAccounts":
		if e.complexity.User.GithubAccounts == nil {
			break
		}

		return e.complexity.User.GithubAccounts(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.projectContributions":
		if e.complexity.User.ProjectContributions == nil {
			break
		}

		return e.complexity.User.ProjectContributions(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserConnection.totalCount":
		if e.complexity.UserConnection.TotalCount == nil {
			break
		}

		return e.complexity.UserConnection.TotalCount(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateDiscordAccountInput,
		ec.unmarshalInputCreateDiscordBotInput,
		ec.unmarshalInputCreateGithubAccountInput,
		ec.unmarshalInputCreateGithubOrganizationInput,
		ec.unmarshalInputCreateGithubOrganizationMemberInput,
		ec.unmarshalInputCreateProjectAssociationInput,
		ec.unmarshalInputCreateProjectContributorInput,
		ec.unmarshalInputCreateProjectInput,
		ec.unmarshalInputCreateProjectTechnologyInput,
		ec.unmarshalInputCreateRepositoryInput,
		ec.unmarshalInputCreateRepositoryTechnologyInput,
		ec.unmarshalInputCreateSiteInput,
		ec.unmarshalInputCreateTechnologyAssociationInput,
		ec.unmarshalInputCreateTechnologyInput,
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputDiscordAccountOrder,
		ec.unmarshalInputDiscordAccountWhereInput,
		ec.unmarshalInputDiscordBotWhereInput,
		ec.unmarshalInputGithubAccountOrder,
		ec.unmarshalInputGithubAccountWhereInput,
		ec.unmarshalInputGithubOrganizationMemberOrder,
		ec.unmarshalInputGithubOrganizationMemberWhereInput,
		ec.unmarshalInputGithubOrganizationOrder,
		ec.unmarshalInputGithubOrganizationWhereInput,
		ec.unmarshalInputProjectAssociationOrder,
		ec.unmarshalInputProjectAssociationWhereInput,
		ec.unmarshalInputProjectContributorOrder,
		ec.unmarshalInputProjectContributorWhereInput,
		ec.unmarshalInputProjectOrder,
		ec.unmarshalInputProjectTechnologyOrder,
		ec.unmarshalInputProjectTechnologyWhereInput,
		ec.unmarshalInputProjectWhereInput,
		ec.unmarshalInputRepositoryOrder,
		ec.unmarshalInputRepositoryTechnologyOrder,
		ec.unmarshalInputRepositoryTechnologyWhereInput,
		ec.unmarshalInputRepositoryWhereInput,
		ec.unmarshalInputSiteOrder,
		ec.unmarshalInputSiteWhereInput,
		ec.unmarshalInputTechnologyAssociationOrder,
		ec.unmarshalInputTechnologyAssociationWhereInput,
		ec.unmarshalInputTechnologyOrder,
		ec.unmarshalInputTechnologyWhereInput,
		ec.unmarshalInputUpdateDiscordAccountInput,
		ec.unmarshalInputUpdateDiscordBotInput,
		ec.unmarshalInputUpdateGithubAccountInput,
		ec.unmarshalInputUpdateGithubOrganizationInput,
		ec.unmarshalInputUpdateGithubOrganizationMemberInput,
		ec.unmarshalInputUpdateProjectAssociationInput,
		ec.unmarshalInputUpdateProjectContributorInput,
		ec.unmarshalInputUpdateProjectInput,
		ec.unmarshalInputUpdateProjectTechnologyInput,
		ec.unmarshalInputUpdateRepositoryInput,
		ec.unmarshalInputUpdateRepositoryTechnologyInput,
		ec.unmarshalInputUpdateSiteInput,
		ec.unmarshalInputUpdateTechnologyAssociationInput,
		ec.unmarshalInputUpdateTechnologyInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserOrder,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

//go:embed "ent.graphql" "grackdb.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "ent.graphql", Input: sourceData("ent.graphql"), BuiltIn: false},
	{Name: "grackdb.graphql", Input: sourceData("grackdb.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_assumeDevelopmentUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createDiscordAccount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateDiscordAccountInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateDiscordAccountInput2githubcomfogoshgrackdbentCreateDiscordAccountInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createDiscordBot_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateDiscordBotInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateDiscordBotInput2githubcomfogoshgrackdbentCreateDiscordBotInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createGithubAccount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateGithubAccountInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateGithubAccountInput2githubcomfogoshgrackdbentCreateGithubAccountInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createGithubOrganizationMember_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateGithubOrganizationMemberInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateGithubOrganizationMemberInput2githubcomfogoshgrackdbentCreateGithubOrganizationMemberInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createGithubOrganization_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateGithubOrganizationInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateGithubOrganizationInput2githubcomfogoshgrackdbentCreateGithubOrganizationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createProjectAssociation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateProjectAssociationInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateProjectAssociationInput2githubcomfogoshgrackdbentCreateProjectAssociationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createProjectContributor_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateProjectContributorInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateProjectContributorInput2githubcomfogoshgrackdbentCreateProjectContributorInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createProjectTechnology_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateProjectTechnologyInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateProjectTechnologyInput2githubcomfogoshgrackdbentCreateProjectTechnologyInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createProject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateProjectInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateProjectInput2githubcomfogoshgrackdbentCreateProjectInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createRepositoryTechnology_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateRepositoryTechnologyInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateRepositoryTechnologyInput2githubcomfogoshgrackdbentCreateRepositoryTechnologyInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createRepository_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateRepositoryInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateRepositoryInput2githubcomfogoshgrackdbentCreateRepositoryInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createSite_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateSiteInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateSiteInput2githubcomfogoshgrackdbentCreateSiteInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createTechnologyAssociation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateTechnologyAssociationInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateTechnologyAssociationInput2githubcomfogoshgrackdbentCreateTechnologyAssociationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createTechnology_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateTechnologyInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateTechnologyInput2githubcomfogoshgrackdbentCreateTechnologyInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateUserInput2githubcomfogoshgrackdbentCreateUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteDiscordAccount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteDiscordBot_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteGithubAccount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteGithubOrganizationMember_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteGithubOrganization_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteProjectAssociation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteProjectContributor_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteProjectTechnology_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteProject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteRepositoryTechnology_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteRepository_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSite_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteTechnologyAssociation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteTechnology_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateDiscordAccount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateDiscordAccountInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateDiscordAccountInput2githubcomfogoshgrackdbentUpdateDiscordAccountInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateDiscordBot_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateDiscordBotInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateDiscordBotInput2githubcomfogoshgrackdbentUpdateDiscordBotInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateGithubAccount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateGithubAccountInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateGithubAccountInput2githubcomfogoshgrackdbentUpdateGithubAccountInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateGithubOrganizationMember_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateGithubOrganizationMemberInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateGithubOrganizationMemberInput2githubcomfogoshgrackdbentUpdateGithubOrganizationMemberInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateGithubOrganization_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateGithubOrganizationInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateGithubOrganizationInput2githubcomfogoshgrackdbentUpdateGithubOrganizationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateProjectAssociation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateProjectAssociationInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateProjectAssociationInput2githubcomfogoshgrackdbentUpdateProjectAssociationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateProjectContributor_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateProjectContributorInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateProjectContributorInput2githubcomfogoshgrackdbentUpdateProjectContributorInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateProjectTechnology_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateProjectTechnologyInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateProjectTechnologyInput2githubcomfogoshgrackdbentUpdateProjectTechnologyInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateProject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateProjectInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateProjectInput2githubcomfogoshgrackdbentUpdateProjectInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRepositoryTechnology_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateRepositoryTechnologyInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateRepositoryTechnologyInput2githubcomfogoshgrackdbentUpdateRepositoryTechnologyInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRepository_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateRepositoryInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateRepositoryInput2githubcomfogoshgrackdbentUpdateRepositoryInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSite_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateSiteInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateSiteInput2githubcomfogoshgrackdbentUpdateSiteInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateTechnologyAssociation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateTechnologyAssociationInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateTechnologyAssociationInput2githubcomfogoshgrackdbentUpdateTechnologyAssociationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateTechnology_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateTechnologyInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateTechnologyInput2githubcomfogoshgrackdbentUpdateTechnologyInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateUserInput2githubcomfogoshgrackdbentUpdateUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_discordAccounts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.DiscordAccountOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalODiscordAccountOrder2githubcomfogoshgrackdbentDiscordAccountOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.DiscordAccountWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalODiscordAccountWhereInput2githubcomfogoshgrackdbentDiscordAccountWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_discordBots_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.DiscordBotWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalODiscordBotWhereInput2githubcomfogoshgrackdbentDiscordBotWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_githubAccounts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.GithubAccountOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOGithubAccountOrder2githubcomfogoshgrackdbentGithubAccountOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.GithubAccountWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOGithubAccountWhereInput2githubcomfogoshgrackdbentGithubAccountWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_githubOrganizationMembers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.GithubOrganizationMemberOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOGithubOrganizationMemberOrder2githubcomfogoshgrackdbentGithubOrganizationMemberOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.GithubOrganizationMemberWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOGithubOrganizationMemberWhereInput2githubcomfogoshgrackdbentGithubOrganizationMemberWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_githubOrganizations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.GithubOrganizationOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOGithubOrganizationOrder2githubcomfogoshgrackdbentGithubOrganizationOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.GithubOrganizationWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOGithubOrganizationWhereInput2githubcomfogoshgrackdbentGithubOrganizationWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_nodes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []int
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_projectAssociations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.ProjectAssociationOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOProjectAssociationOrder2githubcomfogoshgrackdbentProjectAssociationOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.ProjectAssociationWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOProjectAssociationWhereInput2githubcomfogoshgrackdbentProjectAssociationWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_projectContributors_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.ProjectContributorOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOProjectContributorOrder2githubcomfogoshgrackdbentProjectContributorOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.ProjectContributorWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOProjectContributorWhereInput2githubcomfogoshgrackdbentProjectContributorWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_projectTechnologies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.ProjectTechnologyOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOProjectTechnologyOrder2githubcomfogoshgrackdbentProjectTechnologyOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.ProjectTechnologyWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOProjectTechnologyWhereInput2githubcomfogoshgrackdbentProjectTechnologyWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_projects_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.ProjectOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOProjectOrder2githubcomfogoshgrackdbentProjectOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.ProjectWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOProjectWhereInput2githubcomfogoshgrackdbentProjectWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_repositories_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.RepositoryOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalORepositoryOrder2githubcomfogoshgrackdbentRepositoryOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.RepositoryWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalORepositoryWhereInput2githubcomfogoshgrackdbentRepositoryWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_repositoryTechnologies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.RepositoryTechnologyOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalORepositoryTechnologyOrder2githubcomfogoshgrackdbentRepositoryTechnologyOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.RepositoryTechnologyWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalORepositoryTechnologyWhereInput2githubcomfogoshgrackdbentRepositoryTechnologyWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_sites_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.SiteOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOSiteOrder2githubcomfogoshgrackdbentSiteOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.SiteWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOSiteWhereInput2githubcomfogoshgrackdbentSiteWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_technologies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.TechnologyOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOTechnologyOrder2githubcomfogoshgrackdbentTechnologyOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.TechnologyWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOTechnologyWhereInput2githubcomfogoshgrackdbentTechnologyWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_technologyAssociations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.TechnologyAssociationOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOTechnologyAssociationOrder2githubcomfogoshgrackdbentTechnologyAssociationOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.TechnologyAssociationWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOTechnologyAssociationWhereInput2githubcomfogoshgrackdbentTechnologyAssociationWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.UserOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOUserOrder2githubcomfogoshgrackdbentUserOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.UserWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOUserWhereInput2githubcomfogoshgrackdbentUserWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AuthProvider_type(ctx context.Context, field graphql.CollectedField, obj *AuthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthProvider_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AuthProviderType)
	fc.Result = res
	return ec.marshalNAuthProviderType2githubcomfogoshgrackdbgraphqlAuthProviderType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthProvider_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AuthProviderType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthProvider_url(ctx context.Context, field graphql.CollectedField, obj *AuthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthProvider_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthProvider_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordAccount_id(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordAccount_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordAccount_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordAccount_discordID(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordAccount_discordID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiscordID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordAccount_discordID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordAccount_username(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordAccount_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordAccount_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordAccount_discriminator(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordAccount_discriminator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Discriminator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordAccount_discriminator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordAccount_owner(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordAccount_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalOUser2githubcomfogoshgrackdbentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordAccount_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordAccount",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatarURL":
				return ec.fieldContext_User_avatarURL(ctx, field)
			case "discordAccounts":
				return ec.fieldContext_User_discordAccounts(ctx, field)
			case "githubAccounts":
				return ec.fieldContext_User_githubAccounts(ctx, field)
			case "projectContributions":
				return ec.fieldContext_User_projectContributions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordAccount_bot(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordAccount_bot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bot(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.DiscordBot)
	fc.Result = res
	return ec.marshalODiscordBot2githubcomfogoshgrackdbentDiscordBot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordAccount_bot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordAccount",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscordBot_id(ctx, field)
			case "account":
				return ec.fieldContext_DiscordBot_account(ctx, field)
			case "project":
				return ec.fieldContext_DiscordBot_project(ctx, field)
			case "repository":
				return ec.fieldContext_DiscordBot_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordBot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordAccountConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordAccountConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordAccountConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.DiscordAccountEdge)
	fc.Result = res
	return ec.marshalODiscordAccountEdge2githubcomfogoshgrackdbentDiscordAccountEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordAccountConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordAccountConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_DiscordAccountEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_DiscordAccountEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordAccountEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordAccountConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordAccountConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordAccountConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordAccountConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordAccountConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordAccountConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordAccountConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordAccountConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordAccountConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordAccountConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordAccountEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordAccountEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordAccountEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.DiscordAccount)
	fc.Result = res
	return ec.marshalODiscordAccount2githubcomfogoshgrackdbentDiscordAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordAccountEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordAccountEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscordAccount_id(ctx, field)
			case "discordID":
				return ec.fieldContext_DiscordAccount_discordID(ctx, field)
			case "username":
				return ec.fieldContext_DiscordAccount_username(ctx, field)
			case "discriminator":
				return ec.fieldContext_DiscordAccount_discriminator(ctx, field)
			case "owner":
				return ec.fieldContext_DiscordAccount_owner(ctx, field)
			case "bot":
				return ec.fieldContext_DiscordAccount_bot(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordAccountEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordAccountEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordAccountEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordAccountEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordAccountEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordBot_id(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordBot) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordBot_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordBot_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordBot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordBot_account(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordBot) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordBot_account(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Account(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.DiscordAccount)
	fc.Result = res
	return ec.marshalNDiscordAccount2githubcomfogoshgrackdbentDiscordAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordBot_account(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordBot",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscordAccount_id(ctx, field)
			case "discordID":
				return ec.fieldContext_DiscordAccount_discordID(ctx, field)
			case "username":
				return ec.fieldContext_DiscordAccount_username(ctx, field)
			case "discriminator":
				return ec.fieldContext_DiscordAccount_discriminator(ctx, field)
			case "owner":
				return ec.fieldContext_DiscordAccount_owner(ctx, field)
			case "bot":
				return ec.fieldContext_DiscordAccount_bot(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordBot_project(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordBot) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordBot_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Project)
	fc.Result = res
	return ec.marshalNProject2githubcomfogoshgrackdbentProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordBot_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordBot",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "startDate":
				return ec.fieldContext_Project_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Project_endDate(ctx, field)
			case "contributors":
				return ec.fieldContext_Project_contributors(ctx, field)
			case "parentProjects":
				return ec.fieldContext_Project_parentProjects(ctx, field)
			case "childProjects":
				return ec.fieldContext_Project_childProjects(ctx, field)
			case "repositories":
				return ec.fieldContext_Project_repositories(ctx, field)
			case "discordBots":
				return ec.fieldContext_Project_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Project_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Project_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordBot_repository(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordBot) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordBot_repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Repository)
	fc.Result = res
	return ec.marshalORepository2githubcomfogoshgrackdbentRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordBot_repository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordBot",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "description":
				return ec.fieldContext_Repository_description(ctx, field)
			case "project":
				return ec.fieldContext_Repository_project(ctx, field)
			case "githubAccount":
				return ec.fieldContext_Repository_githubAccount(ctx, field)
			case "githubOrganization":
				return ec.fieldContext_Repository_githubOrganization(ctx, field)
			case "discordBots":
				return ec.fieldContext_Repository_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Repository_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Repository_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordBotConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordBotConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordBotConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.DiscordBotEdge)
	fc.Result = res
	return ec.marshalODiscordBotEdge2githubcomfogoshgrackdbentDiscordBotEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordBotConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordBotConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_DiscordBotEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_DiscordBotEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordBotEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordBotConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordBotConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordBotConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordBotConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordBotConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordBotConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordBotConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordBotConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordBotConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordBotConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordBotEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordBotEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordBotEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.DiscordBot)
	fc.Result = res
	return ec.marshalODiscordBot2githubcomfogoshgrackdbentDiscordBot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordBotEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordBotEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscordBot_id(ctx, field)
			case "account":
				return ec.fieldContext_DiscordBot_account(ctx, field)
			case "project":
				return ec.fieldContext_DiscordBot_project(ctx, field)
			case "repository":
				return ec.fieldContext_DiscordBot_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordBot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscordBotEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.DiscordBotEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscordBotEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscordBotEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscordBotEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAccount_id(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAccount_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAccount_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAccount_username(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAccount_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAccount_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAccount_owner(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAccount_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomfogoshgrackdbentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAccount_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAccount",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatarURL":
				return ec.fieldContext_User_avatarURL(ctx, field)
			case "discordAccounts":
				return ec.fieldContext_User_discordAccounts(ctx, field)
			case "githubAccounts":
				return ec.fieldContext_User_githubAccounts(ctx, field)
			case "projectContributions":
				return ec.fieldContext_User_projectContributions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAccount_organizationMemberships(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAccount_organizationMemberships(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrganizationMemberships(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.GithubOrganizationMember)
	fc.Result = res
	return ec.marshalOGithubOrganizationMember2githubcomfogoshgrackdbentGithubOrganizationMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAccount_organizationMemberships(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAccount",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubOrganizationMember_id(ctx, field)
			case "role":
				return ec.fieldContext_GithubOrganizationMember_role(ctx, field)
			case "organization":
				return ec.fieldContext_GithubOrganizationMember_organization(ctx, field)
			case "account":
				return ec.fieldContext_GithubOrganizationMember_account(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganizationMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAccount_repositories(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAccount_repositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repositories(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Repository)
	fc.Result = res
	return ec.marshalORepository2githubcomfogoshgrackdbentRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAccount_repositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAccount",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "description":
				return ec.fieldContext_Repository_description(ctx, field)
			case "project":
				return ec.fieldContext_Repository_project(ctx, field)
			case "githubAccount":
				return ec.fieldContext_Repository_githubAccount(ctx, field)
			case "githubOrganization":
				return ec.fieldContext_Repository_githubOrganization(ctx, field)
			case "discordBots":
				return ec.fieldContext_Repository_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Repository_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Repository_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAccountConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAccountConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAccountConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.GithubAccountEdge)
	fc.Result = res
	return ec.marshalOGithubAccountEdge2githubcomfogoshgrackdbentGithubAccountEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAccountConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAccountConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_GithubAccountEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_GithubAccountEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAccountEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAccountConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAccountConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAccountConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAccountConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAccountConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAccountConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAccountConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAccountConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAccountConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAccountConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAccountEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAccountEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAccountEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GithubAccount)
	fc.Result = res
	return ec.marshalOGithubAccount2githubcomfogoshgrackdbentGithubAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAccountEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAccountEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubAccount_id(ctx, field)
			case "username":
				return ec.fieldContext_GithubAccount_username(ctx, field)
			case "owner":
				return ec.fieldContext_GithubAccount_owner(ctx, field)
			case "organizationMemberships":
				return ec.fieldContext_GithubAccount_organizationMemberships(ctx, field)
			case "repositories":
				return ec.fieldContext_GithubAccount_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAccountEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAccountEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAccountEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAccountEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAccountEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganization_id(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganization_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganization_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganization_name(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganization_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganization_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganization_displayName(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganization_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganization_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganization_members(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganization_members(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Members(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.GithubOrganizationMember)
	fc.Result = res
	return ec.marshalOGithubOrganizationMember2githubcomfogoshgrackdbentGithubOrganizationMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganization_members(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganization",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubOrganizationMember_id(ctx, field)
			case "role":
				return ec.fieldContext_GithubOrganizationMember_role(ctx, field)
			case "organization":
				return ec.fieldContext_GithubOrganizationMember_organization(ctx, field)
			case "account":
				return ec.fieldContext_GithubOrganizationMember_account(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganizationMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganization_repositories(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganization_repositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repositories(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Repository)
	fc.Result = res
	return ec.marshalORepository2githubcomfogoshgrackdbentRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganization_repositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganization",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "description":
				return ec.fieldContext_Repository_description(ctx, field)
			case "project":
				return ec.fieldContext_Repository_project(ctx, field)
			case "githubAccount":
				return ec.fieldContext_Repository_githubAccount(ctx, field)
			case "githubOrganization":
				return ec.fieldContext_Repository_githubOrganization(ctx, field)
			case "discordBots":
				return ec.fieldContext_Repository_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Repository_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Repository_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganizationConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganizationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganizationConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.GithubOrganizationEdge)
	fc.Result = res
	return ec.marshalOGithubOrganizationEdge2githubcomfogoshgrackdbentGithubOrganizationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganizationConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganizationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_GithubOrganizationEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_GithubOrganizationEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganizationEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganizationConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganizationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganizationConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganizationConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganizationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganizationConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganizationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganizationConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganizationConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganizationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganizationEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganizationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganizationEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GithubOrganization)
	fc.Result = res
	return ec.marshalOGithubOrganization2githubcomfogoshgrackdbentGithubOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganizationEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganizationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubOrganization_id(ctx, field)
			case "name":
				return ec.fieldContext_GithubOrganization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_GithubOrganization_displayName(ctx, field)
			case "members":
				return ec.fieldContext_GithubOrganization_members(ctx, field)
			case "repositories":
				return ec.fieldContext_GithubOrganization_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganizationEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganizationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganizationEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganizationEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganizationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganizationMember_id(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganizationMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganizationMember_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganizationMember_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganizationMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganizationMember_role(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganizationMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganizationMember_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(githuborganizationmember.Role)
	fc.Result = res
	return ec.marshalNGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganizationMember_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganizationMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GithubOrganizationMemberRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganizationMember_organization(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganizationMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganizationMember_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Organization(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubOrganization)
	fc.Result = res
	return ec.marshalNGithubOrganization2githubcomfogoshgrackdbentGithubOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganizationMember_organization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganizationMember",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubOrganization_id(ctx, field)
			case "name":
				return ec.fieldContext_GithubOrganization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_GithubOrganization_displayName(ctx, field)
			case "members":
				return ec.fieldContext_GithubOrganization_members(ctx, field)
			case "repositories":
				return ec.fieldContext_GithubOrganization_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganizationMember_account(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganizationMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganizationMember_account(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Account(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubAccount)
	fc.Result = res
	return ec.marshalNGithubAccount2githubcomfogoshgrackdbentGithubAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganizationMember_account(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganizationMember",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubAccount_id(ctx, field)
			case "username":
				return ec.fieldContext_GithubAccount_username(ctx, field)
			case "owner":
				return ec.fieldContext_GithubAccount_owner(ctx, field)
			case "organizationMemberships":
				return ec.fieldContext_GithubAccount_organizationMemberships(ctx, field)
			case "repositories":
				return ec.fieldContext_GithubAccount_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganizationMemberConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganizationMemberConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganizationMemberConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.GithubOrganizationMemberEdge)
	fc.Result = res
	return ec.marshalOGithubOrganizationMemberEdge2githubcomfogoshgrackdbentGithubOrganizationMemberEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganizationMemberConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganizationMemberConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_GithubOrganizationMemberEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_GithubOrganizationMemberEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganizationMemberEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganizationMemberConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganizationMemberConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganizationMemberConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganizationMemberConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganizationMemberConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganizationMemberConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganizationMemberConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganizationMemberConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganizationMemberConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganizationMemberConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganizationMemberEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganizationMemberEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganizationMemberEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GithubOrganizationMember)
	fc.Result = res
	return ec.marshalOGithubOrganizationMember2githubcomfogoshgrackdbentGithubOrganizationMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganizationMemberEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganizationMemberEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubOrganizationMember_id(ctx, field)
			case "role":
				return ec.fieldContext_GithubOrganizationMember_role(ctx, field)
			case "organization":
				return ec.fieldContext_GithubOrganizationMember_organization(ctx, field)
			case "account":
				return ec.fieldContext_GithubOrganizationMember_account(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganizationMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubOrganizationMemberEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.GithubOrganizationMemberEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubOrganizationMemberEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubOrganizationMemberEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubOrganizationMemberEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUser(rctx, fc.Args["input"].(ent.CreateUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomfogoshgrackdbentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatarURL":
				return ec.fieldContext_User_avatarURL(ctx, field)
			case "discordAccounts":
				return ec.fieldContext_User_discordAccounts(ctx, field)
			case "githubAccounts":
				return ec.fieldContext_User_githubAccounts(ctx, field)
			case "projectContributions":
				return ec.fieldContext_User_projectContributions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUser(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomfogoshgrackdbentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatarURL":
				return ec.fieldContext_User_avatarURL(ctx, field)
			case "discordAccounts":
				return ec.fieldContext_User_discordAccounts(ctx, field)
			case "githubAccounts":
				return ec.fieldContext_User_githubAccounts(ctx, field)
			case "projectContributions":
				return ec.fieldContext_User_projectContributions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteUser(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomfogoshgrackdbentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatarURL":
				return ec.fieldContext_User_avatarURL(ctx, field)
			case "discordAccounts":
				return ec.fieldContext_User_discordAccounts(ctx, field)
			case "githubAccounts":
				return ec.fieldContext_User_githubAccounts(ctx, field)
			case "projectContributions":
				return ec.fieldContext_User_projectContributions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createDiscordAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createDiscordAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateDiscordAccount(rctx, fc.Args["input"].(ent.CreateDiscordAccountInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.DiscordAccount)
	fc.Result = res
	return ec.marshalNDiscordAccount2githubcomfogoshgrackdbentDiscordAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createDiscordAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscordAccount_id(ctx, field)
			case "discordID":
				return ec.fieldContext_DiscordAccount_discordID(ctx, field)
			case "username":
				return ec.fieldContext_DiscordAccount_username(ctx, field)
			case "discriminator":
				return ec.fieldContext_DiscordAccount_discriminator(ctx, field)
			case "owner":
				return ec.fieldContext_DiscordAccount_owner(ctx, field)
			case "bot":
				return ec.fieldContext_DiscordAccount_bot(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordAccount", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createDiscordAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateDiscordAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateDiscordAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateDiscordAccount(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateDiscordAccountInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.DiscordAccount)
	fc.Result = res
	return ec.marshalNDiscordAccount2githubcomfogoshgrackdbentDiscordAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateDiscordAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscordAccount_id(ctx, field)
			case "discordID":
				return ec.fieldContext_DiscordAccount_discordID(ctx, field)
			case "username":
				return ec.fieldContext_DiscordAccount_username(ctx, field)
			case "discriminator":
				return ec.fieldContext_DiscordAccount_discriminator(ctx, field)
			case "owner":
				return ec.fieldContext_DiscordAccount_owner(ctx, field)
			case "bot":
				return ec.fieldContext_DiscordAccount_bot(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordAccount", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateDiscordAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteDiscordAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteDiscordAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteDiscordAccount(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.DiscordAccount)
	fc.Result = res
	return ec.marshalNDiscordAccount2githubcomfogoshgrackdbentDiscordAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteDiscordAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscordAccount_id(ctx, field)
			case "discordID":
				return ec.fieldContext_DiscordAccount_discordID(ctx, field)
			case "username":
				return ec.fieldContext_DiscordAccount_username(ctx, field)
			case "discriminator":
				return ec.fieldContext_DiscordAccount_discriminator(ctx, field)
			case "owner":
				return ec.fieldContext_DiscordAccount_owner(ctx, field)
			case "bot":
				return ec.fieldContext_DiscordAccount_bot(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordAccount", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteDiscordAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createDiscordBot(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createDiscordBot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateDiscordBot(rctx, fc.Args["input"].(ent.CreateDiscordBotInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.DiscordBot)
	fc.Result = res
	return ec.marshalNDiscordBot2githubcomfogoshgrackdbentDiscordBot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createDiscordBot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscordBot_id(ctx, field)
			case "account":
				return ec.fieldContext_DiscordBot_account(ctx, field)
			case "project":
				return ec.fieldContext_DiscordBot_project(ctx, field)
			case "repository":
				return ec.fieldContext_DiscordBot_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordBot", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createDiscordBot_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateDiscordBot(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateDiscordBot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateDiscordBot(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateDiscordBotInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.DiscordBot)
	fc.Result = res
	return ec.marshalNDiscordBot2githubcomfogoshgrackdbentDiscordBot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateDiscordBot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscordBot_id(ctx, field)
			case "account":
				return ec.fieldContext_DiscordBot_account(ctx, field)
			case "project":
				return ec.fieldContext_DiscordBot_project(ctx, field)
			case "repository":
				return ec.fieldContext_DiscordBot_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordBot", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateDiscordBot_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteDiscordBot(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteDiscordBot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteDiscordBot(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.DiscordBot)
	fc.Result = res
	return ec.marshalNDiscordBot2githubcomfogoshgrackdbentDiscordBot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteDiscordBot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscordBot_id(ctx, field)
			case "account":
				return ec.fieldContext_DiscordBot_account(ctx, field)
			case "project":
				return ec.fieldContext_DiscordBot_project(ctx, field)
			case "repository":
				return ec.fieldContext_DiscordBot_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordBot", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteDiscordBot_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createGithubAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createGithubAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateGithubAccount(rctx, fc.Args["input"].(ent.CreateGithubAccountInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubAccount)
	fc.Result = res
	return ec.marshalNGithubAccount2githubcomfogoshgrackdbentGithubAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createGithubAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubAccount_id(ctx, field)
			case "username":
				return ec.fieldContext_GithubAccount_username(ctx, field)
			case "owner":
				return ec.fieldContext_GithubAccount_owner(ctx, field)
			case "organizationMemberships":
				return ec.fieldContext_GithubAccount_organizationMemberships(ctx, field)
			case "repositories":
				return ec.fieldContext_GithubAccount_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAccount", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createGithubAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateGithubAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateGithubAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateGithubAccount(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateGithubAccountInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubAccount)
	fc.Result = res
	return ec.marshalNGithubAccount2githubcomfogoshgrackdbentGithubAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateGithubAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubAccount_id(ctx, field)
			case "username":
				return ec.fieldContext_GithubAccount_username(ctx, field)
			case "owner":
				return ec.fieldContext_GithubAccount_owner(ctx, field)
			case "organizationMemberships":
				return ec.fieldContext_GithubAccount_organizationMemberships(ctx, field)
			case "repositories":
				return ec.fieldContext_GithubAccount_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAccount", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateGithubAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteGithubAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteGithubAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteGithubAccount(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubAccount)
	fc.Result = res
	return ec.marshalNGithubAccount2githubcomfogoshgrackdbentGithubAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteGithubAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubAccount_id(ctx, field)
			case "username":
				return ec.fieldContext_GithubAccount_username(ctx, field)
			case "owner":
				return ec.fieldContext_GithubAccount_owner(ctx, field)
			case "organizationMemberships":
				return ec.fieldContext_GithubAccount_organizationMemberships(ctx, field)
			case "repositories":
				return ec.fieldContext_GithubAccount_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAccount", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteGithubAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createGithubOrganization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createGithubOrganization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateGithubOrganization(rctx, fc.Args["input"].(ent.CreateGithubOrganizationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubOrganization)
	fc.Result = res
	return ec.marshalNGithubOrganization2githubcomfogoshgrackdbentGithubOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createGithubOrganization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubOrganization_id(ctx, field)
			case "name":
				return ec.fieldContext_GithubOrganization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_GithubOrganization_displayName(ctx, field)
			case "members":
				return ec.fieldContext_GithubOrganization_members(ctx, field)
			case "repositories":
				return ec.fieldContext_GithubOrganization_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganization", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createGithubOrganization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateGithubOrganization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateGithubOrganization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateGithubOrganization(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateGithubOrganizationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubOrganization)
	fc.Result = res
	return ec.marshalNGithubOrganization2githubcomfogoshgrackdbentGithubOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateGithubOrganization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubOrganization_id(ctx, field)
			case "name":
				return ec.fieldContext_GithubOrganization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_GithubOrganization_displayName(ctx, field)
			case "members":
				return ec.fieldContext_GithubOrganization_members(ctx, field)
			case "repositories":
				return ec.fieldContext_GithubOrganization_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganization", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateGithubOrganization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteGithubOrganization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteGithubOrganization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteGithubOrganization(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubOrganization)
	fc.Result = res
	return ec.marshalNGithubOrganization2githubcomfogoshgrackdbentGithubOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteGithubOrganization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubOrganization_id(ctx, field)
			case "name":
				return ec.fieldContext_GithubOrganization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_GithubOrganization_displayName(ctx, field)
			case "members":
				return ec.fieldContext_GithubOrganization_members(ctx, field)
			case "repositories":
				return ec.fieldContext_GithubOrganization_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganization", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteGithubOrganization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createGithubOrganizationMember(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createGithubOrganizationMember(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateGithubOrganizationMember(rctx, fc.Args["input"].(ent.CreateGithubOrganizationMemberInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubOrganizationMember)
	fc.Result = res
	return ec.marshalNGithubOrganizationMember2githubcomfogoshgrackdbentGithubOrganizationMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createGithubOrganizationMember(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubOrganizationMember_id(ctx, field)
			case "role":
				return ec.fieldContext_GithubOrganizationMember_role(ctx, field)
			case "organization":
				return ec.fieldContext_GithubOrganizationMember_organization(ctx, field)
			case "account":
				return ec.fieldContext_GithubOrganizationMember_account(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganizationMember", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createGithubOrganizationMember_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateGithubOrganizationMember(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateGithubOrganizationMember(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateGithubOrganizationMember(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateGithubOrganizationMemberInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubOrganizationMember)
	fc.Result = res
	return ec.marshalNGithubOrganizationMember2githubcomfogoshgrackdbentGithubOrganizationMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateGithubOrganizationMember(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubOrganizationMember_id(ctx, field)
			case "role":
				return ec.fieldContext_GithubOrganizationMember_role(ctx, field)
			case "organization":
				return ec.fieldContext_GithubOrganizationMember_organization(ctx, field)
			case "account":
				return ec.fieldContext_GithubOrganizationMember_account(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganizationMember", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateGithubOrganizationMember_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteGithubOrganizationMember(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteGithubOrganizationMember(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteGithubOrganizationMember(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubOrganizationMember)
	fc.Result = res
	return ec.marshalNGithubOrganizationMember2githubcomfogoshgrackdbentGithubOrganizationMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteGithubOrganizationMember(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubOrganizationMember_id(ctx, field)
			case "role":
				return ec.fieldContext_GithubOrganizationMember_role(ctx, field)
			case "organization":
				return ec.fieldContext_GithubOrganizationMember_organization(ctx, field)
			case "account":
				return ec.fieldContext_GithubOrganizationMember_account(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganizationMember", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteGithubOrganizationMember_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateProject(rctx, fc.Args["input"].(ent.CreateProjectInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Project)
	fc.Result = res
	return ec.marshalNProject2githubcomfogoshgrackdbentProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "startDate":
				return ec.fieldContext_Project_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Project_endDate(ctx, field)
			case "contributors":
				return ec.fieldContext_Project_contributors(ctx, field)
			case "parentProjects":
				return ec.fieldContext_Project_parentProjects(ctx, field)
			case "childProjects":
				return ec.fieldContext_Project_childProjects(ctx, field)
			case "repositories":
				return ec.fieldContext_Project_repositories(ctx, field)
			case "discordBots":
				return ec.fieldContext_Project_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Project_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Project_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateProject(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateProjectInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Project)
	fc.Result = res
	return ec.marshalNProject2githubcomfogoshgrackdbentProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "startDate":
				return ec.fieldContext_Project_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Project_endDate(ctx, field)
			case "contributors":
				return ec.fieldContext_Project_contributors(ctx, field)
			case "parentProjects":
				return ec.fieldContext_Project_parentProjects(ctx, field)
			case "childProjects":
				return ec.fieldContext_Project_childProjects(ctx, field)
			case "repositories":
				return ec.fieldContext_Project_repositories(ctx, field)
			case "discordBots":
				return ec.fieldContext_Project_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Project_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Project_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteProject(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Project)
	fc.Result = res
	return ec.marshalNProject2githubcomfogoshgrackdbentProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "startDate":
				return ec.fieldContext_Project_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Project_endDate(ctx, field)
			case "contributors":
				return ec.fieldContext_Project_contributors(ctx, field)
			case "parentProjects":
				return ec.fieldContext_Project_parentProjects(ctx, field)
			case "childProjects":
				return ec.fieldContext_Project_childProjects(ctx, field)
			case "repositories":
				return ec.fieldContext_Project_repositories(ctx, field)
			case "discordBots":
				return ec.fieldContext_Project_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Project_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Project_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createProjectContributor(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createProjectContributor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateProjectContributor(rctx, fc.Args["input"].(ent.CreateProjectContributorInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectContributor)
	fc.Result = res
	return ec.marshalNProjectContributor2githubcomfogoshgrackdbentProjectContributor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createProjectContributor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectContributor_id(ctx, field)
			case "role":
				return ec.fieldContext_ProjectContributor_role(ctx, field)
			case "project":
				return ec.fieldContext_ProjectContributor_project(ctx, field)
			case "user":
				return ec.fieldContext_ProjectContributor_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectContributor", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createProjectContributor_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateProjectContributor(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateProjectContributor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateProjectContributor(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateProjectContributorInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectContributor)
	fc.Result = res
	return ec.marshalNProjectContributor2githubcomfogoshgrackdbentProjectContributor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateProjectContributor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectContributor_id(ctx, field)
			case "role":
				return ec.fieldContext_ProjectContributor_role(ctx, field)
			case "project":
				return ec.fieldContext_ProjectContributor_project(ctx, field)
			case "user":
				return ec.fieldContext_ProjectContributor_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectContributor", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateProjectContributor_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteProjectContributor(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteProjectContributor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteProjectContributor(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectContributor)
	fc.Result = res
	return ec.marshalNProjectContributor2githubcomfogoshgrackdbentProjectContributor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteProjectContributor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectContributor_id(ctx, field)
			case "role":
				return ec.fieldContext_ProjectContributor_role(ctx, field)
			case "project":
				return ec.fieldContext_ProjectContributor_project(ctx, field)
			case "user":
				return ec.fieldContext_ProjectContributor_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectContributor", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteProjectContributor_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createProjectAssociation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createProjectAssociation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateProjectAssociation(rctx, fc.Args["input"].(ent.CreateProjectAssociationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectAssociation)
	fc.Result = res
	return ec.marshalNProjectAssociation2githubcomfogoshgrackdbentProjectAssociation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createProjectAssociation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAssociation_id(ctx, field)
			case "type":
				return ec.fieldContext_ProjectAssociation_type(ctx, field)
			case "parent":
				return ec.fieldContext_ProjectAssociation_parent(ctx, field)
			case "child":
				return ec.fieldContext_ProjectAssociation_child(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAssociation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createProjectAssociation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateProjectAssociation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateProjectAssociation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateProjectAssociation(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateProjectAssociationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectAssociation)
	fc.Result = res
	return ec.marshalNProjectAssociation2githubcomfogoshgrackdbentProjectAssociation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateProjectAssociation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAssociation_id(ctx, field)
			case "type":
				return ec.fieldContext_ProjectAssociation_type(ctx, field)
			case "parent":
				return ec.fieldContext_ProjectAssociation_parent(ctx, field)
			case "child":
				return ec.fieldContext_ProjectAssociation_child(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAssociation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateProjectAssociation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteProjectAssociation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteProjectAssociation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteProjectAssociation(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectAssociation)
	fc.Result = res
	return ec.marshalNProjectAssociation2githubcomfogoshgrackdbentProjectAssociation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteProjectAssociation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAssociation_id(ctx, field)
			case "type":
				return ec.fieldContext_ProjectAssociation_type(ctx, field)
			case "parent":
				return ec.fieldContext_ProjectAssociation_parent(ctx, field)
			case "child":
				return ec.fieldContext_ProjectAssociation_child(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAssociation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteProjectAssociation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createRepository(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createRepository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateRepository(rctx, fc.Args["input"].(ent.CreateRepositoryInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Repository)
	fc.Result = res
	return ec.marshalNRepository2githubcomfogoshgrackdbentRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createRepository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "description":
				return ec.fieldContext_Repository_description(ctx, field)
			case "project":
				return ec.fieldContext_Repository_project(ctx, field)
			case "githubAccount":
				return ec.fieldContext_Repository_githubAccount(ctx, field)
			case "githubOrganization":
				return ec.fieldContext_Repository_githubOrganization(ctx, field)
			case "discordBots":
				return ec.fieldContext_Repository_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Repository_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Repository_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createRepository_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRepository(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateRepository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateRepository(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateRepositoryInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Repository)
	fc.Result = res
	return ec.marshalNRepository2githubcomfogoshgrackdbentRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateRepository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "description":
				return ec.fieldContext_Repository_description(ctx, field)
			case "project":
				return ec.fieldContext_Repository_project(ctx, field)
			case "githubAccount":
				return ec.fieldContext_Repository_githubAccount(ctx, field)
			case "githubOrganization":
				return ec.fieldContext_Repository_githubOrganization(ctx, field)
			case "discordBots":
				return ec.fieldContext_Repository_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Repository_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Repository_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRepository_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteRepository(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteRepository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteRepository(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Repository)
	fc.Result = res
	return ec.marshalNRepository2githubcomfogoshgrackdbentRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteRepository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "description":
				return ec.fieldContext_Repository_description(ctx, field)
			case "project":
				return ec.fieldContext_Repository_project(ctx, field)
			case "githubAccount":
				return ec.fieldContext_Repository_githubAccount(ctx, field)
			case "githubOrganization":
				return ec.fieldContext_Repository_githubOrganization(ctx, field)
			case "discordBots":
				return ec.fieldContext_Repository_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Repository_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Repository_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteRepository_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSite(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createSite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateSite(rctx, fc.Args["input"].(ent.CreateSiteInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Site)
	fc.Result = res
	return ec.marshalNSite2githubcomfogoshgrackdbentSite(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createSite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Site_id(ctx, field)
			case "url":
				return ec.fieldContext_Site_url(ctx, field)
			case "project":
				return ec.fieldContext_Site_project(ctx, field)
			case "repository":
				return ec.fieldContext_Site_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Site", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSite_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSite(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateSite(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateSiteInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Site)
	fc.Result = res
	return ec.marshalNSite2githubcomfogoshgrackdbentSite(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Site_id(ctx, field)
			case "url":
				return ec.fieldContext_Site_url(ctx, field)
			case "project":
				return ec.fieldContext_Site_project(ctx, field)
			case "repository":
				return ec.fieldContext_Site_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Site", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSite_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSite(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteSite(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Site)
	fc.Result = res
	return ec.marshalNSite2githubcomfogoshgrackdbentSite(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Site_id(ctx, field)
			case "url":
				return ec.fieldContext_Site_url(ctx, field)
			case "project":
				return ec.fieldContext_Site_project(ctx, field)
			case "repository":
				return ec.fieldContext_Site_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Site", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSite_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTechnology(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTechnology(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTechnology(rctx, fc.Args["input"].(ent.CreateTechnologyInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Technology)
	fc.Result = res
	return ec.marshalNTechnology2githubcomfogoshgrackdbentTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTechnology(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Technology_id(ctx, field)
			case "name":
				return ec.fieldContext_Technology_name(ctx, field)
			case "description":
				return ec.fieldContext_Technology_description(ctx, field)
			case "colour":
				return ec.fieldContext_Technology_colour(ctx, field)
			case "type":
				return ec.fieldContext_Technology_type(ctx, field)
			case "parentTechnologies":
				return ec.fieldContext_Technology_parentTechnologies(ctx, field)
			case "childTechnologies":
				return ec.fieldContext_Technology_childTechnologies(ctx, field)
			case "projects":
				return ec.fieldContext_Technology_projects(ctx, field)
			case "repositories":
				return ec.fieldContext_Technology_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Technology", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTechnology_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTechnology(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTechnology(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateTechnology(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateTechnologyInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Technology)
	fc.Result = res
	return ec.marshalNTechnology2githubcomfogoshgrackdbentTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTechnology(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Technology_id(ctx, field)
			case "name":
				return ec.fieldContext_Technology_name(ctx, field)
			case "description":
				return ec.fieldContext_Technology_description(ctx, field)
			case "colour":
				return ec.fieldContext_Technology_colour(ctx, field)
			case "type":
				return ec.fieldContext_Technology_type(ctx, field)
			case "parentTechnologies":
				return ec.fieldContext_Technology_parentTechnologies(ctx, field)
			case "childTechnologies":
				return ec.fieldContext_Technology_childTechnologies(ctx, field)
			case "projects":
				return ec.fieldContext_Technology_projects(ctx, field)
			case "repositories":
				return ec.fieldContext_Technology_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Technology", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTechnology_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTechnology(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTechnology(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteTechnology(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Technology)
	fc.Result = res
	return ec.marshalNTechnology2githubcomfogoshgrackdbentTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTechnology(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Technology_id(ctx, field)
			case "name":
				return ec.fieldContext_Technology_name(ctx, field)
			case "description":
				return ec.fieldContext_Technology_description(ctx, field)
			case "colour":
				return ec.fieldContext_Technology_colour(ctx, field)
			case "type":
				return ec.fieldContext_Technology_type(ctx, field)
			case "parentTechnologies":
				return ec.fieldContext_Technology_parentTechnologies(ctx, field)
			case "childTechnologies":
				return ec.fieldContext_Technology_childTechnologies(ctx, field)
			case "projects":
				return ec.fieldContext_Technology_projects(ctx, field)
			case "repositories":
				return ec.fieldContext_Technology_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Technology", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTechnology_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTechnologyAssociation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTechnologyAssociation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTechnologyAssociation(rctx, fc.Args["input"].(ent.CreateTechnologyAssociationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.TechnologyAssociation)
	fc.Result = res
	return ec.marshalNTechnologyAssociation2githubcomfogoshgrackdbentTechnologyAssociation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTechnologyAssociation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TechnologyAssociation_id(ctx, field)
			case "type":
				return ec.fieldContext_TechnologyAssociation_type(ctx, field)
			case "parent":
				return ec.fieldContext_TechnologyAssociation_parent(ctx, field)
			case "child":
				return ec.fieldContext_TechnologyAssociation_child(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TechnologyAssociation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTechnologyAssociation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTechnologyAssociation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTechnologyAssociation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateTechnologyAssociation(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateTechnologyAssociationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.TechnologyAssociation)
	fc.Result = res
	return ec.marshalNTechnologyAssociation2githubcomfogoshgrackdbentTechnologyAssociation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTechnologyAssociation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TechnologyAssociation_id(ctx, field)
			case "type":
				return ec.fieldContext_TechnologyAssociation_type(ctx, field)
			case "parent":
				return ec.fieldContext_TechnologyAssociation_parent(ctx, field)
			case "child":
				return ec.fieldContext_TechnologyAssociation_child(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TechnologyAssociation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTechnologyAssociation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTechnologyAssociation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTechnologyAssociation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteTechnologyAssociation(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.TechnologyAssociation)
	fc.Result = res
	return ec.marshalNTechnologyAssociation2githubcomfogoshgrackdbentTechnologyAssociation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTechnologyAssociation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TechnologyAssociation_id(ctx, field)
			case "type":
				return ec.fieldContext_TechnologyAssociation_type(ctx, field)
			case "parent":
				return ec.fieldContext_TechnologyAssociation_parent(ctx, field)
			case "child":
				return ec.fieldContext_TechnologyAssociation_child(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TechnologyAssociation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTechnologyAssociation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createProjectTechnology(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createProjectTechnology(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateProjectTechnology(rctx, fc.Args["input"].(ent.CreateProjectTechnologyInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectTechnology)
	fc.Result = res
	return ec.marshalNProjectTechnology2githubcomfogoshgrackdbentProjectTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createProjectTechnology(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectTechnology_id(ctx, field)
			case "type":
				return ec.fieldContext_ProjectTechnology_type(ctx, field)
			case "project":
				return ec.fieldContext_ProjectTechnology_project(ctx, field)
			case "technology":
				return ec.fieldContext_ProjectTechnology_technology(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectTechnology", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createProjectTechnology_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateProjectTechnology(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateProjectTechnology(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateProjectTechnology(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateProjectTechnologyInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectTechnology)
	fc.Result = res
	return ec.marshalNProjectTechnology2githubcomfogoshgrackdbentProjectTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateProjectTechnology(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectTechnology_id(ctx, field)
			case "type":
				return ec.fieldContext_ProjectTechnology_type(ctx, field)
			case "project":
				return ec.fieldContext_ProjectTechnology_project(ctx, field)
			case "technology":
				return ec.fieldContext_ProjectTechnology_technology(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectTechnology", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateProjectTechnology_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteProjectTechnology(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteProjectTechnology(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteProjectTechnology(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectTechnology)
	fc.Result = res
	return ec.marshalNProjectTechnology2githubcomfogoshgrackdbentProjectTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteProjectTechnology(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectTechnology_id(ctx, field)
			case "type":
				return ec.fieldContext_ProjectTechnology_type(ctx, field)
			case "project":
				return ec.fieldContext_ProjectTechnology_project(ctx, field)
			case "technology":
				return ec.fieldContext_ProjectTechnology_technology(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectTechnology", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteProjectTechnology_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createRepositoryTechnology(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createRepositoryTechnology(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateRepositoryTechnology(rctx, fc.Args["input"].(ent.CreateRepositoryTechnologyInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.RepositoryTechnology)
	fc.Result = res
	return ec.marshalNRepositoryTechnology2githubcomfogoshgrackdbentRepositoryTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createRepositoryTechnology(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepositoryTechnology_id(ctx, field)
			case "type":
				return ec.fieldContext_RepositoryTechnology_type(ctx, field)
			case "repository":
				return ec.fieldContext_RepositoryTechnology_repository(ctx, field)
			case "technology":
				return ec.fieldContext_RepositoryTechnology_technology(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryTechnology", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createRepositoryTechnology_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRepositoryTechnology(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateRepositoryTechnology(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateRepositoryTechnology(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateRepositoryTechnologyInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.RepositoryTechnology)
	fc.Result = res
	return ec.marshalNRepositoryTechnology2githubcomfogoshgrackdbentRepositoryTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateRepositoryTechnology(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepositoryTechnology_id(ctx, field)
			case "type":
				return ec.fieldContext_RepositoryTechnology_type(ctx, field)
			case "repository":
				return ec.fieldContext_RepositoryTechnology_repository(ctx, field)
			case "technology":
				return ec.fieldContext_RepositoryTechnology_technology(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryTechnology", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRepositoryTechnology_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteRepositoryTechnology(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteRepositoryTechnology(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteRepositoryTechnology(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.RepositoryTechnology)
	fc.Result = res
	return ec.marshalNRepositoryTechnology2githubcomfogoshgrackdbentRepositoryTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteRepositoryTechnology(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepositoryTechnology_id(ctx, field)
			case "type":
				return ec.fieldContext_RepositoryTechnology_type(ctx, field)
			case "repository":
				return ec.fieldContext_RepositoryTechnology_repository(ctx, field)
			case "technology":
				return ec.fieldContext_RepositoryTechnology_technology(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryTechnology", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteRepositoryTechnology_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_assumeDevelopmentUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_assumeDevelopmentUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AssumeDevelopmentUser(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomfogoshgrackdbentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_assumeDevelopmentUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatarURL":
				return ec.fieldContext_User_avatarURL(ctx, field)
			case "discordAccounts":
				return ec.fieldContext_User_discordAccounts(ctx, field)
			case "githubAccounts":
				return ec.fieldContext_User_githubAccounts(ctx, field)
			case "projectContributions":
				return ec.fieldContext_User_projectContributions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_assumeDevelopmentUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Cursor)
	fc.Result = res
	return ec.marshalOCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Cursor)
	fc.Result = res
	return ec.marshalOCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_id(ctx context.Context, field graphql.CollectedField, obj *ent.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_name(ctx context.Context, field graphql.CollectedField, obj *ent.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_description(ctx context.Context, field graphql.CollectedField, obj *ent.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_startDate(ctx context.Context, field graphql.CollectedField, obj *ent.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_endDate(ctx context.Context, field graphql.CollectedField, obj *ent.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_contributors(ctx context.Context, field graphql.CollectedField, obj *ent.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_contributors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Contributors(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ProjectContributor)
	fc.Result = res
	return ec.marshalOProjectContributor2githubcomfogoshgrackdbentProjectContributor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_contributors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectContributor_id(ctx, field)
			case "role":
				return ec.fieldContext_ProjectContributor_role(ctx, field)
			case "project":
				return ec.fieldContext_ProjectContributor_project(ctx, field)
			case "user":
				return ec.fieldContext_ProjectContributor_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectContributor", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_parentProjects(ctx context.Context, field graphql.CollectedField, obj *ent.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_parentProjects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentProjects(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ProjectAssociation)
	fc.Result = res
	return ec.marshalOProjectAssociation2githubcomfogoshgrackdbentProjectAssociation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_parentProjects(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAssociation_id(ctx, field)
			case "type":
				return ec.fieldContext_ProjectAssociation_type(ctx, field)
			case "parent":
				return ec.fieldContext_ProjectAssociation_parent(ctx, field)
			case "child":
				return ec.fieldContext_ProjectAssociation_child(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAssociation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_childProjects(ctx context.Context, field graphql.CollectedField, obj *ent.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_childProjects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildProjects(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ProjectAssociation)
	fc.Result = res
	return ec.marshalOProjectAssociation2githubcomfogoshgrackdbentProjectAssociation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_childProjects(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAssociation_id(ctx, field)
			case "type":
				return ec.fieldContext_ProjectAssociation_type(ctx, field)
			case "parent":
				return ec.fieldContext_ProjectAssociation_parent(ctx, field)
			case "child":
				return ec.fieldContext_ProjectAssociation_child(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAssociation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repositories(ctx context.Context, field graphql.CollectedField, obj *ent.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_repositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repositories(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Repository)
	fc.Result = res
	return ec.marshalORepository2githubcomfogoshgrackdbentRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_repositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "description":
				return ec.fieldContext_Repository_description(ctx, field)
			case "project":
				return ec.fieldContext_Repository_project(ctx, field)
			case "githubAccount":
				return ec.fieldContext_Repository_githubAccount(ctx, field)
			case "githubOrganization":
				return ec.fieldContext_Repository_githubOrganization(ctx, field)
			case "discordBots":
				return ec.fieldContext_Repository_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Repository_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Repository_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_discordBots(ctx context.Context, field graphql.CollectedField, obj *ent.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_discordBots(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiscordBots(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.DiscordBot)
	fc.Result = res
	return ec.marshalODiscordBot2githubcomfogoshgrackdbentDiscordBot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_discordBots(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscordBot_id(ctx, field)
			case "account":
				return ec.fieldContext_DiscordBot_account(ctx, field)
			case "project":
				return ec.fieldContext_DiscordBot_project(ctx, field)
			case "repository":
				return ec.fieldContext_DiscordBot_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordBot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_sites(ctx context.Context, field graphql.CollectedField, obj *ent.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_sites(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sites(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Site)
	fc.Result = res
	return ec.marshalOSite2githubcomfogoshgrackdbentSite(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_sites(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Site_id(ctx, field)
			case "url":
				return ec.fieldContext_Site_url(ctx, field)
			case "project":
				return ec.fieldContext_Site_project(ctx, field)
			case "repository":
				return ec.fieldContext_Site_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Site", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_technologies(ctx context.Context, field graphql.CollectedField, obj *ent.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_technologies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Technologies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ProjectTechnology)
	fc.Result = res
	return ec.marshalOProjectTechnology2githubcomfogoshgrackdbentProjectTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_technologies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectTechnology_id(ctx, field)
			case "type":
				return ec.fieldContext_ProjectTechnology_type(ctx, field)
			case "project":
				return ec.fieldContext_ProjectTechnology_project(ctx, field)
			case "technology":
				return ec.fieldContext_ProjectTechnology_technology(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectTechnology", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAssociation_id(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectAssociation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAssociation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAssociation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAssociation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAssociation_type(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectAssociation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAssociation_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(projectassociation.Type)
	fc.Result = res
	return ec.marshalNProjectAssociationType2githubcomfogoshgrackdbentprojectassociationType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAssociation_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAssociation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProjectAssociationType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAssociation_parent(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectAssociation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAssociation_parent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parent(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Project)
	fc.Result = res
	return ec.marshalNProject2githubcomfogoshgrackdbentProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAssociation_parent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAssociation",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "startDate":
				return ec.fieldContext_Project_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Project_endDate(ctx, field)
			case "contributors":
				return ec.fieldContext_Project_contributors(ctx, field)
			case "parentProjects":
				return ec.fieldContext_Project_parentProjects(ctx, field)
			case "childProjects":
				return ec.fieldContext_Project_childProjects(ctx, field)
			case "repositories":
				return ec.fieldContext_Project_repositories(ctx, field)
			case "discordBots":
				return ec.fieldContext_Project_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Project_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Project_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAssociation_child(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectAssociation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAssociation_child(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Child(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Project)
	fc.Result = res
	return ec.marshalNProject2githubcomfogoshgrackdbentProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAssociation_child(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAssociation",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "startDate":
				return ec.fieldContext_Project_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Project_endDate(ctx, field)
			case "contributors":
				return ec.fieldContext_Project_contributors(ctx, field)
			case "parentProjects":
				return ec.fieldContext_Project_parentProjects(ctx, field)
			case "childProjects":
				return ec.fieldContext_Project_childProjects(ctx, field)
			case "repositories":
				return ec.fieldContext_Project_repositories(ctx, field)
			case "discordBots":
				return ec.fieldContext_Project_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Project_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Project_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAssociationConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectAssociationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAssociationConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ProjectAssociationEdge)
	fc.Result = res
	return ec.marshalOProjectAssociationEdge2githubcomfogoshgrackdbentProjectAssociationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAssociationConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAssociationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_ProjectAssociationEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_ProjectAssociationEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAssociationEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAssociationConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectAssociationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAssociationConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAssociationConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAssociationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAssociationConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectAssociationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAssociationConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAssociationConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAssociationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAssociationEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectAssociationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAssociationEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectAssociation)
	fc.Result = res
	return ec.marshalOProjectAssociation2githubcomfogoshgrackdbentProjectAssociation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAssociationEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAssociationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAssociation_id(ctx, field)
			case "type":
				return ec.fieldContext_ProjectAssociation_type(ctx, field)
			case "parent":
				return ec.fieldContext_ProjectAssociation_parent(ctx, field)
			case "child":
				return ec.fieldContext_ProjectAssociation_child(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAssociation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAssociationEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectAssociationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAssociationEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAssociationEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAssociationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ProjectEdge)
	fc.Result = res
	return ec.marshalOProjectEdge2githubcomfogoshgrackdbentProjectEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_ProjectEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_ProjectEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectContributor_id(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectContributor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectContributor_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectContributor_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectContributor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectContributor_role(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectContributor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectContributor_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(projectcontributor.Role)
	fc.Result = res
	return ec.marshalNProjectContributorRole2githubcomfogoshgrackdbentprojectcontributorRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectContributor_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectContributor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProjectContributorRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectContributor_project(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectContributor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectContributor_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Project)
	fc.Result = res
	return ec.marshalNProject2githubcomfogoshgrackdbentProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectContributor_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectContributor",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "startDate":
				return ec.fieldContext_Project_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Project_endDate(ctx, field)
			case "contributors":
				return ec.fieldContext_Project_contributors(ctx, field)
			case "parentProjects":
				return ec.fieldContext_Project_parentProjects(ctx, field)
			case "childProjects":
				return ec.fieldContext_Project_childProjects(ctx, field)
			case "repositories":
				return ec.fieldContext_Project_repositories(ctx, field)
			case "discordBots":
				return ec.fieldContext_Project_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Project_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Project_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectContributor_user(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectContributor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectContributor_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomfogoshgrackdbentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectContributor_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectContributor",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatarURL":
				return ec.fieldContext_User_avatarURL(ctx, field)
			case "discordAccounts":
				return ec.fieldContext_User_discordAccounts(ctx, field)
			case "githubAccounts":
				return ec.fieldContext_User_githubAccounts(ctx, field)
			case "projectContributions":
				return ec.fieldContext_User_projectContributions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectContributorConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectContributorConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectContributorConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ProjectContributorEdge)
	fc.Result = res
	return ec.marshalOProjectContributorEdge2githubcomfogoshgrackdbentProjectContributorEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectContributorConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectContributorConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_ProjectContributorEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_ProjectContributorEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectContributorEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectContributorConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectContributorConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectContributorConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectContributorConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectContributorConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectContributorConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectContributorConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectContributorConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectContributorConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectContributorConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectContributorEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectContributorEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectContributorEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectContributor)
	fc.Result = res
	return ec.marshalOProjectContributor2githubcomfogoshgrackdbentProjectContributor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectContributorEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectContributorEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectContributor_id(ctx, field)
			case "role":
				return ec.fieldContext_ProjectContributor_role(ctx, field)
			case "project":
				return ec.fieldContext_ProjectContributor_project(ctx, field)
			case "user":
				return ec.fieldContext_ProjectContributor_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectContributor", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectContributorEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectContributorEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectContributorEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectContributorEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectContributorEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Project)
	fc.Result = res
	return ec.marshalOProject2githubcomfogoshgrackdbentProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "startDate":
				return ec.fieldContext_Project_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Project_endDate(ctx, field)
			case "contributors":
				return ec.fieldContext_Project_contributors(ctx, field)
			case "parentProjects":
				return ec.fieldContext_Project_parentProjects(ctx, field)
			case "childProjects":
				return ec.fieldContext_Project_childProjects(ctx, field)
			case "repositories":
				return ec.fieldContext_Project_repositories(ctx, field)
			case "discordBots":
				return ec.fieldContext_Project_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Project_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Project_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTechnology_id(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectTechnology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectTechnology_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectTechnology_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTechnology",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTechnology_type(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectTechnology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectTechnology_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(projecttechnology.Type)
	fc.Result = res
	return ec.marshalNProjectTechnologyType2githubcomfogoshgrackdbentprojecttechnologyType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectTechnology_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTechnology",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProjectTechnologyType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTechnology_project(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectTechnology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectTechnology_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Project)
	fc.Result = res
	return ec.marshalNProject2githubcomfogoshgrackdbentProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectTechnology_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTechnology",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "startDate":
				return ec.fieldContext_Project_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Project_endDate(ctx, field)
			case "contributors":
				return ec.fieldContext_Project_contributors(ctx, field)
			case "parentProjects":
				return ec.fieldContext_Project_parentProjects(ctx, field)
			case "childProjects":
				return ec.fieldContext_Project_childProjects(ctx, field)
			case "repositories":
				return ec.fieldContext_Project_repositories(ctx, field)
			case "discordBots":
				return ec.fieldContext_Project_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Project_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Project_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTechnology_technology(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectTechnology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectTechnology_technology(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Technology(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Technology)
	fc.Result = res
	return ec.marshalNTechnology2githubcomfogoshgrackdbentTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectTechnology_technology(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTechnology",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Technology_id(ctx, field)
			case "name":
				return ec.fieldContext_Technology_name(ctx, field)
			case "description":
				return ec.fieldContext_Technology_description(ctx, field)
			case "colour":
				return ec.fieldContext_Technology_colour(ctx, field)
			case "type":
				return ec.fieldContext_Technology_type(ctx, field)
			case "parentTechnologies":
				return ec.fieldContext_Technology_parentTechnologies(ctx, field)
			case "childTechnologies":
				return ec.fieldContext_Technology_childTechnologies(ctx, field)
			case "projects":
				return ec.fieldContext_Technology_projects(ctx, field)
			case "repositories":
				return ec.fieldContext_Technology_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Technology", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTechnologyConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectTechnologyConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectTechnologyConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ProjectTechnologyEdge)
	fc.Result = res
	return ec.marshalOProjectTechnologyEdge2githubcomfogoshgrackdbentProjectTechnologyEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectTechnologyConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTechnologyConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_ProjectTechnologyEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_ProjectTechnologyEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectTechnologyEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTechnologyConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectTechnologyConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectTechnologyConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectTechnologyConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTechnologyConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTechnologyConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectTechnologyConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectTechnologyConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectTechnologyConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTechnologyConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTechnologyEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectTechnologyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectTechnologyEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectTechnology)
	fc.Result = res
	return ec.marshalOProjectTechnology2githubcomfogoshgrackdbentProjectTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectTechnologyEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTechnologyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectTechnology_id(ctx, field)
			case "type":
				return ec.fieldContext_ProjectTechnology_type(ctx, field)
			case "project":
				return ec.fieldContext_ProjectTechnology_project(ctx, field)
			case "technology":
				return ec.fieldContext_ProjectTechnology_technology(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectTechnology", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTechnologyEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.ProjectTechnologyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectTechnologyEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectTechnologyEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTechnologyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(ent.Noder)
	fc.Result = res
	return ec.marshalONode2githubcomfogoshgrackdbentNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Nodes(rctx, fc.Args["ids"].([]int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ent.Noder)
	fc.Result = res
	return ec.marshalNNode2githubcomfogoshgrackdbentNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_discordAccounts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_discordAccounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DiscordAccounts(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.DiscordAccountOrder), fc.Args["where"].(*ent.DiscordAccountWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.DiscordAccountConnection)
	fc.Result = res
	return ec.marshalNDiscordAccountConnection2githubcomfogoshgrackdbentDiscordAccountConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_discordAccounts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_DiscordAccountConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_DiscordAccountConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_DiscordAccountConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordAccountConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_discordAccounts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_discordBots(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_discordBots(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DiscordBots(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["where"].(*ent.DiscordBotWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.DiscordBotConnection)
	fc.Result = res
	return ec.marshalNDiscordBotConnection2githubcomfogoshgrackdbentDiscordBotConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_discordBots(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_DiscordBotConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_DiscordBotConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_DiscordBotConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordBotConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_discordBots_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_githubAccounts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_githubAccounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GithubAccounts(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.GithubAccountOrder), fc.Args["where"].(*ent.GithubAccountWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubAccountConnection)
	fc.Result = res
	return ec.marshalNGithubAccountConnection2githubcomfogoshgrackdbentGithubAccountConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_githubAccounts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GithubAccountConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GithubAccountConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_GithubAccountConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAccountConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_githubAccounts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_githubOrganizations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_githubOrganizations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GithubOrganizations(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.GithubOrganizationOrder), fc.Args["where"].(*ent.GithubOrganizationWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubOrganizationConnection)
	fc.Result = res
	return ec.marshalNGithubOrganizationConnection2githubcomfogoshgrackdbentGithubOrganizationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_githubOrganizations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GithubOrganizationConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GithubOrganizationConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_GithubOrganizationConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganizationConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_githubOrganizations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_githubOrganizationMembers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_githubOrganizationMembers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GithubOrganizationMembers(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.GithubOrganizationMemberOrder), fc.Args["where"].(*ent.GithubOrganizationMemberWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubOrganizationMemberConnection)
	fc.Result = res
	return ec.marshalNGithubOrganizationMemberConnection2githubcomfogoshgrackdbentGithubOrganizationMemberConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_githubOrganizationMembers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GithubOrganizationMemberConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GithubOrganizationMemberConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_GithubOrganizationMemberConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganizationMemberConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_githubOrganizationMembers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_projects(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_projects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Projects(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.ProjectOrder), fc.Args["where"].(*ent.ProjectWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectConnection)
	fc.Result = res
	return ec.marshalNProjectConnection2githubcomfogoshgrackdbentProjectConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_projects(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ProjectConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ProjectConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ProjectConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_projects_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_projectAssociations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_projectAssociations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ProjectAssociations(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.ProjectAssociationOrder), fc.Args["where"].(*ent.ProjectAssociationWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectAssociationConnection)
	fc.Result = res
	return ec.marshalNProjectAssociationConnection2githubcomfogoshgrackdbentProjectAssociationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_projectAssociations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ProjectAssociationConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ProjectAssociationConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ProjectAssociationConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAssociationConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_projectAssociations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_projectContributors(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_projectContributors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ProjectContributors(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.ProjectContributorOrder), fc.Args["where"].(*ent.ProjectContributorWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectContributorConnection)
	fc.Result = res
	return ec.marshalNProjectContributorConnection2githubcomfogoshgrackdbentProjectContributorConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_projectContributors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ProjectContributorConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ProjectContributorConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ProjectContributorConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectContributorConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_projectContributors_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_projectTechnologies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_projectTechnologies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ProjectTechnologies(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.ProjectTechnologyOrder), fc.Args["where"].(*ent.ProjectTechnologyWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProjectTechnologyConnection)
	fc.Result = res
	return ec.marshalNProjectTechnologyConnection2githubcomfogoshgrackdbentProjectTechnologyConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_projectTechnologies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ProjectTechnologyConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ProjectTechnologyConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ProjectTechnologyConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectTechnologyConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_projectTechnologies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_repositories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_repositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Repositories(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.RepositoryOrder), fc.Args["where"].(*ent.RepositoryWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.RepositoryConnection)
	fc.Result = res
	return ec.marshalNRepositoryConnection2githubcomfogoshgrackdbentRepositoryConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_repositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_RepositoryConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_RepositoryConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_RepositoryConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_repositories_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_repositoryTechnologies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_repositoryTechnologies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RepositoryTechnologies(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.RepositoryTechnologyOrder), fc.Args["where"].(*ent.RepositoryTechnologyWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.RepositoryTechnologyConnection)
	fc.Result = res
	return ec.marshalNRepositoryTechnologyConnection2githubcomfogoshgrackdbentRepositoryTechnologyConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_repositoryTechnologies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_RepositoryTechnologyConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_RepositoryTechnologyConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_RepositoryTechnologyConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryTechnologyConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_repositoryTechnologies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_sites(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_sites(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Sites(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.SiteOrder), fc.Args["where"].(*ent.SiteWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.SiteConnection)
	fc.Result = res
	return ec.marshalNSiteConnection2githubcomfogoshgrackdbentSiteConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_sites(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_SiteConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_SiteConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_SiteConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SiteConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_sites_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_technologies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_technologies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Technologies(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.TechnologyOrder), fc.Args["where"].(*ent.TechnologyWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.TechnologyConnection)
	fc.Result = res
	return ec.marshalNTechnologyConnection2githubcomfogoshgrackdbentTechnologyConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_technologies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TechnologyConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TechnologyConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TechnologyConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TechnologyConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_technologies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_technologyAssociations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_technologyAssociations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TechnologyAssociations(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.TechnologyAssociationOrder), fc.Args["where"].(*ent.TechnologyAssociationWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.TechnologyAssociationConnection)
	fc.Result = res
	return ec.marshalNTechnologyAssociationConnection2githubcomfogoshgrackdbentTechnologyAssociationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_technologyAssociations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TechnologyAssociationConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TechnologyAssociationConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TechnologyAssociationConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TechnologyAssociationConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_technologyAssociations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.UserOrder), fc.Args["where"].(*ent.UserWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.UserConnection)
	fc.Result = res
	return ec.marshalNUserConnection2githubcomfogoshgrackdbentUserConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_UserConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_UserConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_UserConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_users_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_availableAuthProviders(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_availableAuthProviders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AvailableAuthProviders(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AuthProvider)
	fc.Result = res
	return ec.marshalOAuthProvider2githubcomfogoshgrackdbgraphqlAuthProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_availableAuthProviders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_AuthProvider_type(ctx, field)
			case "url":
				return ec.fieldContext_AuthProvider_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthProvider", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_currentUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_currentUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CurrentUser(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalOUser2githubcomfogoshgrackdbentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_currentUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatarURL":
				return ec.fieldContext_User_avatarURL(ctx, field)
			case "discordAccounts":
				return ec.fieldContext_User_discordAccounts(ctx, field)
			case "githubAccounts":
				return ec.fieldContext_User_githubAccounts(ctx, field)
			case "projectContributions":
				return ec.fieldContext_User_projectContributions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_developmentMode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_developmentMode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DevelopmentMode(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_developmentMode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_id(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_name(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_description(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_project(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Project)
	fc.Result = res
	return ec.marshalNProject2githubcomfogoshgrackdbentProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "startDate":
				return ec.fieldContext_Project_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Project_endDate(ctx, field)
			case "contributors":
				return ec.fieldContext_Project_contributors(ctx, field)
			case "parentProjects":
				return ec.fieldContext_Project_parentProjects(ctx, field)
			case "childProjects":
				return ec.fieldContext_Project_childProjects(ctx, field)
			case "repositories":
				return ec.fieldContext_Project_repositories(ctx, field)
			case "discordBots":
				return ec.fieldContext_Project_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Project_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Project_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_githubAccount(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_githubAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubAccount(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GithubAccount)
	fc.Result = res
	return ec.marshalOGithubAccount2githubcomfogoshgrackdbentGithubAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_githubAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubAccount_id(ctx, field)
			case "username":
				return ec.fieldContext_GithubAccount_username(ctx, field)
			case "owner":
				return ec.fieldContext_GithubAccount_owner(ctx, field)
			case "organizationMemberships":
				return ec.fieldContext_GithubAccount_organizationMemberships(ctx, field)
			case "repositories":
				return ec.fieldContext_GithubAccount_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_githubOrganization(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_githubOrganization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubOrganization(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GithubOrganization)
	fc.Result = res
	return ec.marshalOGithubOrganization2githubcomfogoshgrackdbentGithubOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_githubOrganization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubOrganization_id(ctx, field)
			case "name":
				return ec.fieldContext_GithubOrganization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_GithubOrganization_displayName(ctx, field)
			case "members":
				return ec.fieldContext_GithubOrganization_members(ctx, field)
			case "repositories":
				return ec.fieldContext_GithubOrganization_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubOrganization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_discordBots(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_discordBots(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiscordBots(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.DiscordBot)
	fc.Result = res
	return ec.marshalODiscordBot2githubcomfogoshgrackdbentDiscordBot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_discordBots(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscordBot_id(ctx, field)
			case "account":
				return ec.fieldContext_DiscordBot_account(ctx, field)
			case "project":
				return ec.fieldContext_DiscordBot_project(ctx, field)
			case "repository":
				return ec.fieldContext_DiscordBot_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordBot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_sites(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_sites(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sites(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Site)
	fc.Result = res
	return ec.marshalOSite2githubcomfogoshgrackdbentSite(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_sites(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Site_id(ctx, field)
			case "url":
				return ec.fieldContext_Site_url(ctx, field)
			case "project":
				return ec.fieldContext_Site_project(ctx, field)
			case "repository":
				return ec.fieldContext_Site_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Site", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_technologies(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_technologies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Technologies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.RepositoryTechnology)
	fc.Result = res
	return ec.marshalORepositoryTechnology2githubcomfogoshgrackdbentRepositoryTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_technologies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepositoryTechnology_id(ctx, field)
			case "type":
				return ec.fieldContext_RepositoryTechnology_type(ctx, field)
			case "repository":
				return ec.fieldContext_RepositoryTechnology_repository(ctx, field)
			case "technology":
				return ec.fieldContext_RepositoryTechnology_technology(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryTechnology", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.RepositoryConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.RepositoryEdge)
	fc.Result = res
	return ec.marshalORepositoryEdge2githubcomfogoshgrackdbentRepositoryEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_RepositoryEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_RepositoryEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.RepositoryConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.RepositoryConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.RepositoryEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Repository)
	fc.Result = res
	return ec.marshalORepository2githubcomfogoshgrackdbentRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "description":
				return ec.fieldContext_Repository_description(ctx, field)
			case "project":
				return ec.fieldContext_Repository_project(ctx, field)
			case "githubAccount":
				return ec.fieldContext_Repository_githubAccount(ctx, field)
			case "githubOrganization":
				return ec.fieldContext_Repository_githubOrganization(ctx, field)
			case "discordBots":
				return ec.fieldContext_Repository_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Repository_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Repository_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.RepositoryEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryTechnology_id(ctx context.Context, field graphql.CollectedField, obj *ent.RepositoryTechnology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryTechnology_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryTechnology_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryTechnology",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryTechnology_type(ctx context.Context, field graphql.CollectedField, obj *ent.RepositoryTechnology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryTechnology_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(repositorytechnology.Type)
	fc.Result = res
	return ec.marshalNRepositoryTechnologyType2githubcomfogoshgrackdbentrepositorytechnologyType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryTechnology_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryTechnology",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RepositoryTechnologyType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryTechnology_repository(ctx context.Context, field graphql.CollectedField, obj *ent.RepositoryTechnology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryTechnology_repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Repository)
	fc.Result = res
	return ec.marshalNRepository2githubcomfogoshgrackdbentRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryTechnology_repository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryTechnology",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "description":
				return ec.fieldContext_Repository_description(ctx, field)
			case "project":
				return ec.fieldContext_Repository_project(ctx, field)
			case "githubAccount":
				return ec.fieldContext_Repository_githubAccount(ctx, field)
			case "githubOrganization":
				return ec.fieldContext_Repository_githubOrganization(ctx, field)
			case "discordBots":
				return ec.fieldContext_Repository_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Repository_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Repository_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryTechnology_technology(ctx context.Context, field graphql.CollectedField, obj *ent.RepositoryTechnology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryTechnology_technology(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Technology(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Technology)
	fc.Result = res
	return ec.marshalNTechnology2githubcomfogoshgrackdbentTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryTechnology_technology(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryTechnology",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Technology_id(ctx, field)
			case "name":
				return ec.fieldContext_Technology_name(ctx, field)
			case "description":
				return ec.fieldContext_Technology_description(ctx, field)
			case "colour":
				return ec.fieldContext_Technology_colour(ctx, field)
			case "type":
				return ec.fieldContext_Technology_type(ctx, field)
			case "parentTechnologies":
				return ec.fieldContext_Technology_parentTechnologies(ctx, field)
			case "childTechnologies":
				return ec.fieldContext_Technology_childTechnologies(ctx, field)
			case "projects":
				return ec.fieldContext_Technology_projects(ctx, field)
			case "repositories":
				return ec.fieldContext_Technology_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Technology", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryTechnologyConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.RepositoryTechnologyConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryTechnologyConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.RepositoryTechnologyEdge)
	fc.Result = res
	return ec.marshalORepositoryTechnologyEdge2githubcomfogoshgrackdbentRepositoryTechnologyEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryTechnologyConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryTechnologyConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_RepositoryTechnologyEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_RepositoryTechnologyEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryTechnologyEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryTechnologyConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.RepositoryTechnologyConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryTechnologyConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryTechnologyConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryTechnologyConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryTechnologyConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.RepositoryTechnologyConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryTechnologyConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryTechnologyConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryTechnologyConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryTechnologyEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.RepositoryTechnologyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryTechnologyEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.RepositoryTechnology)
	fc.Result = res
	return ec.marshalORepositoryTechnology2githubcomfogoshgrackdbentRepositoryTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryTechnologyEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryTechnologyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepositoryTechnology_id(ctx, field)
			case "type":
				return ec.fieldContext_RepositoryTechnology_type(ctx, field)
			case "repository":
				return ec.fieldContext_RepositoryTechnology_repository(ctx, field)
			case "technology":
				return ec.fieldContext_RepositoryTechnology_technology(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryTechnology", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryTechnologyEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.RepositoryTechnologyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryTechnologyEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryTechnologyEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryTechnologyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Site_id(ctx context.Context, field graphql.CollectedField, obj *ent.Site) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Site_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Site_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Site",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Site_url(ctx context.Context, field graphql.CollectedField, obj *ent.Site) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Site_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Site_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Site",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Site_project(ctx context.Context, field graphql.CollectedField, obj *ent.Site) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Site_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Project)
	fc.Result = res
	return ec.marshalNProject2githubcomfogoshgrackdbentProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Site_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Site",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "description":
				return ec.fieldContext_Project_description(ctx, field)
			case "startDate":
				return ec.fieldContext_Project_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Project_endDate(ctx, field)
			case "contributors":
				return ec.fieldContext_Project_contributors(ctx, field)
			case "parentProjects":
				return ec.fieldContext_Project_parentProjects(ctx, field)
			case "childProjects":
				return ec.fieldContext_Project_childProjects(ctx, field)
			case "repositories":
				return ec.fieldContext_Project_repositories(ctx, field)
			case "discordBots":
				return ec.fieldContext_Project_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Project_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Project_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Site_repository(ctx context.Context, field graphql.CollectedField, obj *ent.Site) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Site_repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Repository)
	fc.Result = res
	return ec.marshalORepository2githubcomfogoshgrackdbentRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Site_repository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Site",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "description":
				return ec.fieldContext_Repository_description(ctx, field)
			case "project":
				return ec.fieldContext_Repository_project(ctx, field)
			case "githubAccount":
				return ec.fieldContext_Repository_githubAccount(ctx, field)
			case "githubOrganization":
				return ec.fieldContext_Repository_githubOrganization(ctx, field)
			case "discordBots":
				return ec.fieldContext_Repository_discordBots(ctx, field)
			case "sites":
				return ec.fieldContext_Repository_sites(ctx, field)
			case "technologies":
				return ec.fieldContext_Repository_technologies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SiteConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.SiteConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SiteConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.SiteEdge)
	fc.Result = res
	return ec.marshalOSiteEdge2githubcomfogoshgrackdbentSiteEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SiteConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SiteConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_SiteEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_SiteEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SiteEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SiteConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.SiteConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SiteConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SiteConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SiteConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SiteConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.SiteConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SiteConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SiteConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SiteConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SiteEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.SiteEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SiteEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Site)
	fc.Result = res
	return ec.marshalOSite2githubcomfogoshgrackdbentSite(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SiteEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SiteEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Site_id(ctx, field)
			case "url":
				return ec.fieldContext_Site_url(ctx, field)
			case "project":
				return ec.fieldContext_Site_project(ctx, field)
			case "repository":
				return ec.fieldContext_Site_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Site", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SiteEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.SiteEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SiteEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SiteEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SiteEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technology_id(ctx context.Context, field graphql.CollectedField, obj *ent.Technology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technology_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technology_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technology",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technology_name(ctx context.Context, field graphql.CollectedField, obj *ent.Technology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technology_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technology_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technology",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technology_description(ctx context.Context, field graphql.CollectedField, obj *ent.Technology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technology_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technology_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technology",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technology_colour(ctx context.Context, field graphql.CollectedField, obj *ent.Technology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technology_colour(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Colour, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technology_colour(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technology",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technology_type(ctx context.Context, field graphql.CollectedField, obj *ent.Technology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technology_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(technology.Type)
	fc.Result = res
	return ec.marshalNTechnologyType2githubcomfogoshgrackdbenttechnologyType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technology_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technology",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TechnologyType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technology_parentTechnologies(ctx context.Context, field graphql.CollectedField, obj *ent.Technology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technology_parentTechnologies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentTechnologies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.TechnologyAssociation)
	fc.Result = res
	return ec.marshalOTechnologyAssociation2githubcomfogoshgrackdbentTechnologyAssociation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technology_parentTechnologies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technology",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TechnologyAssociation_id(ctx, field)
			case "type":
				return ec.fieldContext_TechnologyAssociation_type(ctx, field)
			case "parent":
				return ec.fieldContext_TechnologyAssociation_parent(ctx, field)
			case "child":
				return ec.fieldContext_TechnologyAssociation_child(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TechnologyAssociation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technology_childTechnologies(ctx context.Context, field graphql.CollectedField, obj *ent.Technology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technology_childTechnologies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildTechnologies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.TechnologyAssociation)
	fc.Result = res
	return ec.marshalOTechnologyAssociation2githubcomfogoshgrackdbentTechnologyAssociation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technology_childTechnologies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technology",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TechnologyAssociation_id(ctx, field)
			case "type":
				return ec.fieldContext_TechnologyAssociation_type(ctx, field)
			case "parent":
				return ec.fieldContext_TechnologyAssociation_parent(ctx, field)
			case "child":
				return ec.fieldContext_TechnologyAssociation_child(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TechnologyAssociation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technology_projects(ctx context.Context, field graphql.CollectedField, obj *ent.Technology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technology_projects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Projects(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ProjectTechnology)
	fc.Result = res
	return ec.marshalOProjectTechnology2githubcomfogoshgrackdbentProjectTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technology_projects(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technology",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectTechnology_id(ctx, field)
			case "type":
				return ec.fieldContext_ProjectTechnology_type(ctx, field)
			case "project":
				return ec.fieldContext_ProjectTechnology_project(ctx, field)
			case "technology":
				return ec.fieldContext_ProjectTechnology_technology(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectTechnology", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technology_repositories(ctx context.Context, field graphql.CollectedField, obj *ent.Technology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technology_repositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repositories(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.RepositoryTechnology)
	fc.Result = res
	return ec.marshalORepositoryTechnology2githubcomfogoshgrackdbentRepositoryTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technology_repositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technology",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepositoryTechnology_id(ctx, field)
			case "type":
				return ec.fieldContext_RepositoryTechnology_type(ctx, field)
			case "repository":
				return ec.fieldContext_RepositoryTechnology_repository(ctx, field)
			case "technology":
				return ec.fieldContext_RepositoryTechnology_technology(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryTechnology", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechnologyAssociation_id(ctx context.Context, field graphql.CollectedField, obj *ent.TechnologyAssociation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechnologyAssociation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechnologyAssociation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechnologyAssociation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechnologyAssociation_type(ctx context.Context, field graphql.CollectedField, obj *ent.TechnologyAssociation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechnologyAssociation_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(technologyassociation.Type)
	fc.Result = res
	return ec.marshalNTechnologyAssociationType2githubcomfogoshgrackdbenttechnologyassociationType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechnologyAssociation_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechnologyAssociation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TechnologyAssociationType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechnologyAssociation_parent(ctx context.Context, field graphql.CollectedField, obj *ent.TechnologyAssociation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechnologyAssociation_parent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parent(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Technology)
	fc.Result = res
	return ec.marshalNTechnology2githubcomfogoshgrackdbentTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechnologyAssociation_parent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechnologyAssociation",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Technology_id(ctx, field)
			case "name":
				return ec.fieldContext_Technology_name(ctx, field)
			case "description":
				return ec.fieldContext_Technology_description(ctx, field)
			case "colour":
				return ec.fieldContext_Technology_colour(ctx, field)
			case "type":
				return ec.fieldContext_Technology_type(ctx, field)
			case "parentTechnologies":
				return ec.fieldContext_Technology_parentTechnologies(ctx, field)
			case "childTechnologies":
				return ec.fieldContext_Technology_childTechnologies(ctx, field)
			case "projects":
				return ec.fieldContext_Technology_projects(ctx, field)
			case "repositories":
				return ec.fieldContext_Technology_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Technology", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechnologyAssociation_child(ctx context.Context, field graphql.CollectedField, obj *ent.TechnologyAssociation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechnologyAssociation_child(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Child(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Technology)
	fc.Result = res
	return ec.marshalNTechnology2githubcomfogoshgrackdbentTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechnologyAssociation_child(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechnologyAssociation",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Technology_id(ctx, field)
			case "name":
				return ec.fieldContext_Technology_name(ctx, field)
			case "description":
				return ec.fieldContext_Technology_description(ctx, field)
			case "colour":
				return ec.fieldContext_Technology_colour(ctx, field)
			case "type":
				return ec.fieldContext_Technology_type(ctx, field)
			case "parentTechnologies":
				return ec.fieldContext_Technology_parentTechnologies(ctx, field)
			case "childTechnologies":
				return ec.fieldContext_Technology_childTechnologies(ctx, field)
			case "projects":
				return ec.fieldContext_Technology_projects(ctx, field)
			case "repositories":
				return ec.fieldContext_Technology_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Technology", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechnologyAssociationConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.TechnologyAssociationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechnologyAssociationConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.TechnologyAssociationEdge)
	fc.Result = res
	return ec.marshalOTechnologyAssociationEdge2githubcomfogoshgrackdbentTechnologyAssociationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechnologyAssociationConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechnologyAssociationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TechnologyAssociationEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TechnologyAssociationEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TechnologyAssociationEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechnologyAssociationConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.TechnologyAssociationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechnologyAssociationConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechnologyAssociationConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechnologyAssociationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechnologyAssociationConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.TechnologyAssociationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechnologyAssociationConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechnologyAssociationConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechnologyAssociationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechnologyAssociationEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.TechnologyAssociationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechnologyAssociationEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.TechnologyAssociation)
	fc.Result = res
	return ec.marshalOTechnologyAssociation2githubcomfogoshgrackdbentTechnologyAssociation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechnologyAssociationEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechnologyAssociationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TechnologyAssociation_id(ctx, field)
			case "type":
				return ec.fieldContext_TechnologyAssociation_type(ctx, field)
			case "parent":
				return ec.fieldContext_TechnologyAssociation_parent(ctx, field)
			case "child":
				return ec.fieldContext_TechnologyAssociation_child(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TechnologyAssociation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechnologyAssociationEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.TechnologyAssociationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechnologyAssociationEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechnologyAssociationEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechnologyAssociationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechnologyConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.TechnologyConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechnologyConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.TechnologyEdge)
	fc.Result = res
	return ec.marshalOTechnologyEdge2githubcomfogoshgrackdbentTechnologyEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechnologyConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechnologyConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TechnologyEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TechnologyEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TechnologyEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechnologyConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.TechnologyConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechnologyConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechnologyConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechnologyConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechnologyConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.TechnologyConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechnologyConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechnologyConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechnologyConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechnologyEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.TechnologyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechnologyEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Technology)
	fc.Result = res
	return ec.marshalOTechnology2githubcomfogoshgrackdbentTechnology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechnologyEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechnologyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Technology_id(ctx, field)
			case "name":
				return ec.fieldContext_Technology_name(ctx, field)
			case "description":
				return ec.fieldContext_Technology_description(ctx, field)
			case "colour":
				return ec.fieldContext_Technology_colour(ctx, field)
			case "type":
				return ec.fieldContext_Technology_type(ctx, field)
			case "parentTechnologies":
				return ec.fieldContext_Technology_parentTechnologies(ctx, field)
			case "childTechnologies":
				return ec.fieldContext_Technology_childTechnologies(ctx, field)
			case "projects":
				return ec.fieldContext_Technology_projects(ctx, field)
			case "repositories":
				return ec.fieldContext_Technology_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Technology", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechnologyEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.TechnologyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechnologyEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechnologyEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechnologyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_username(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_avatarURL(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_avatarURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_avatarURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_discordAccounts(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_discordAccounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiscordAccounts(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.DiscordAccount)
	fc.Result = res
	return ec.marshalODiscordAccount2githubcomfogoshgrackdbentDiscordAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_discordAccounts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscordAccount_id(ctx, field)
			case "discordID":
				return ec.fieldContext_DiscordAccount_discordID(ctx, field)
			case "username":
				return ec.fieldContext_DiscordAccount_username(ctx, field)
			case "discriminator":
				return ec.fieldContext_DiscordAccount_discriminator(ctx, field)
			case "owner":
				return ec.fieldContext_DiscordAccount_owner(ctx, field)
			case "bot":
				return ec.fieldContext_DiscordAccount_bot(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscordAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_githubAccounts(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_githubAccounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubAccounts(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.GithubAccount)
	fc.Result = res
	return ec.marshalOGithubAccount2githubcomfogoshgrackdbentGithubAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_githubAccounts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubAccount_id(ctx, field)
			case "username":
				return ec.fieldContext_GithubAccount_username(ctx, field)
			case "owner":
				return ec.fieldContext_GithubAccount_owner(ctx, field)
			case "organizationMemberships":
				return ec.fieldContext_GithubAccount_organizationMemberships(ctx, field)
			case "repositories":
				return ec.fieldContext_GithubAccount_repositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_projectContributions(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_projectContributions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectContributions(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ProjectContributor)
	fc.Result = res
	return ec.marshalOProjectContributor2githubcomfogoshgrackdbentProjectContributor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_projectContributions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectContributor_id(ctx, field)
			case "role":
				return ec.fieldContext_ProjectContributor_role(ctx, field)
			case "project":
				return ec.fieldContext_ProjectContributor_project(ctx, field)
			case "user":
				return ec.fieldContext_ProjectContributor_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectContributor", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.UserConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.UserEdge)
	fc.Result = res
	return ec.marshalOUserEdge2githubcomfogoshgrackdbentUserEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_UserEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_UserEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.UserConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.UserConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.UserEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalOUser2githubcomfogoshgrackdbentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatarURL":
				return ec.fieldContext_User_avatarURL(ctx, field)
			case "discordAccounts":
				return ec.fieldContext_User_discordAccounts(ctx, field)
			case "githubAccounts":
				return ec.fieldContext_User_githubAccounts(ctx, field)
			case "projectContributions":
				return ec.fieldContext_User_projectContributions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.UserEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomfogoshgrackdbentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCreateDiscordAccountInput(ctx context.Context, obj interface{}) (ent.CreateDiscordAccountInput, error) {
	var it ent.CreateDiscordAccountInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"discordId", "username", "discriminator", "owner"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "discordId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discordId"))
			it.DiscordID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			it.Username, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discriminator":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discriminator"))
			it.Discriminator, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "owner":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			it.Owner, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateDiscordBotInput(ctx context.Context, obj interface{}) (ent.CreateDiscordBotInput, error) {
	var it ent.CreateDiscordBotInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"account", "project", "repository"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "account":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("account"))
			it.Account, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "project":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			it.Project, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "repository":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repository"))
			it.Repository, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateGithubAccountInput(ctx context.Context, obj interface{}) (ent.CreateGithubAccountInput, error) {
	var it ent.CreateGithubAccountInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "owner"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			it.Username, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "owner":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			it.Owner, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateGithubOrganizationInput(ctx context.Context, obj interface{}) (ent.CreateGithubOrganizationInput, error) {
	var it ent.CreateGithubOrganizationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "displayName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			it.DisplayName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateGithubOrganizationMemberInput(ctx context.Context, obj interface{}) (ent.CreateGithubOrganizationMemberInput, error) {
	var it ent.CreateGithubOrganizationMemberInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"role", "account", "organization"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "role":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			it.Role, err = ec.unmarshalNGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx, v)
			if err != nil {
				return it, err
			}
		case "account":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("account"))
			it.Account, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "organization":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organization"))
			it.Organization, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateProjectAssociationInput(ctx context.Context, obj interface{}) (ent.CreateProjectAssociationInput, error) {
	var it ent.CreateProjectAssociationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "parent", "child"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalNProjectAssociationType2githubcomfogoshgrackdbentprojectassociationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "parent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parent"))
			it.Parent, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "child":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("child"))
			it.Child, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateProjectContributorInput(ctx context.Context, obj interface{}) (ent.CreateProjectContributorInput, error) {
	var it ent.CreateProjectContributorInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"role", "project", "user"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "role":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			it.Role, err = ec.unmarshalNProjectContributorRole2githubcomfogoshgrackdbentprojectcontributorRole(ctx, v)
			if err != nil {
				return it, err
			}
		case "project":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			it.Project, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "user":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user"))
			it.User, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateProjectInput(ctx context.Context, obj interface{}) (ent.CreateProjectInput, error) {
	var it ent.CreateProjectInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "startDate", "endDate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			it.StartDate, err = ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))
			it.EndDate, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateProjectTechnologyInput(ctx context.Context, obj interface{}) (ent.CreateProjectTechnologyInput, error) {
	var it ent.CreateProjectTechnologyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "technology", "project"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalNProjectTechnologyType2githubcomfogoshgrackdbentprojecttechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "technology":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("technology"))
			it.Technology, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "project":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			it.Project, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateRepositoryInput(ctx context.Context, obj interface{}) (ent.CreateRepositoryInput, error) {
	var it ent.CreateRepositoryInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "project", "githubAccount", "githubOrganization"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "project":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			it.Project, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubAccount"))
			it.GithubAccount, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubOrganization":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubOrganization"))
			it.GithubOrganization, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateRepositoryTechnologyInput(ctx context.Context, obj interface{}) (ent.CreateRepositoryTechnologyInput, error) {
	var it ent.CreateRepositoryTechnologyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "technology", "repository"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalNRepositoryTechnologyType2githubcomfogoshgrackdbentrepositorytechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "technology":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("technology"))
			it.Technology, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "repository":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repository"))
			it.Repository, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateSiteInput(ctx context.Context, obj interface{}) (ent.CreateSiteInput, error) {
	var it ent.CreateSiteInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url", "project", "repository"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			it.URL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "project":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			it.Project, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "repository":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repository"))
			it.Repository, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTechnologyAssociationInput(ctx context.Context, obj interface{}) (ent.CreateTechnologyAssociationInput, error) {
	var it ent.CreateTechnologyAssociationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "parent", "child"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalNTechnologyAssociationType2githubcomfogoshgrackdbenttechnologyassociationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "parent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parent"))
			it.Parent, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "child":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("child"))
			it.Child, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTechnologyInput(ctx context.Context, obj interface{}) (ent.CreateTechnologyInput, error) {
	var it ent.CreateTechnologyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "colour", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "colour":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colour"))
			it.Colour, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalNTechnologyType2githubcomfogoshgrackdbenttechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateUserInput(ctx context.Context, obj interface{}) (ent.CreateUserInput, error) {
	var it ent.CreateUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "avatarUrl"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			it.Username, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarUrl":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUrl"))
			it.AvatarURL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDiscordAccountOrder(ctx context.Context, obj interface{}) (ent.DiscordAccountOrder, error) {
	var it ent.DiscordAccountOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNDiscordAccountOrderField2githubcomfogoshgrackdbentDiscordAccountOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDiscordAccountWhereInput(ctx context.Context, obj interface{}) (ent.DiscordAccountWhereInput, error) {
	var it ent.DiscordAccountWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "discordID", "discordIDNEQ", "discordIDIn", "discordIDNotIn", "discordIDGT", "discordIDGTE", "discordIDLT", "discordIDLTE", "discordIDContains", "discordIDHasPrefix", "discordIDHasSuffix", "discordIDEqualFold", "discordIDContainsFold", "username", "usernameNEQ", "usernameIn", "usernameNotIn", "usernameGT", "usernameGTE", "usernameLT", "usernameLTE", "usernameContains", "usernameHasPrefix", "usernameHasSuffix", "usernameEqualFold", "usernameContainsFold", "discriminator", "discriminatorNEQ", "discriminatorIn", "discriminatorNotIn", "discriminatorGT", "discriminatorGTE", "discriminatorLT", "discriminatorLTE", "discriminatorContains", "discriminatorHasPrefix", "discriminatorHasSuffix", "discriminatorEqualFold", "discriminatorContainsFold", "hasOwner", "hasOwnerWith", "hasBot", "hasBotWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalODiscordAccountWhereInput2githubcomfogoshgrackdbentDiscordAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalODiscordAccountWhereInput2githubcomfogoshgrackdbentDiscordAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalODiscordAccountWhereInput2githubcomfogoshgrackdbentDiscordAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "discordID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discordID"))
			it.DiscordID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discordIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discordIDNEQ"))
			it.DiscordIDNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discordIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discordIDIn"))
			it.DiscordIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discordIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discordIDNotIn"))
			it.DiscordIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discordIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discordIDGT"))
			it.DiscordIDGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discordIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discordIDGTE"))
			it.DiscordIDGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discordIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discordIDLT"))
			it.DiscordIDLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discordIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discordIDLTE"))
			it.DiscordIDLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discordIDContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discordIDContains"))
			it.DiscordIDContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discordIDHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discordIDHasPrefix"))
			it.DiscordIDHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discordIDHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discordIDHasSuffix"))
			it.DiscordIDHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discordIDEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discordIDEqualFold"))
			it.DiscordIDEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discordIDContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discordIDContainsFold"))
			it.DiscordIDContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			it.Username, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameNEQ"))
			it.UsernameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameIn"))
			it.UsernameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameNotIn"))
			it.UsernameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameGT"))
			it.UsernameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameGTE"))
			it.UsernameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameLT"))
			it.UsernameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameLTE"))
			it.UsernameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameContains"))
			it.UsernameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameHasPrefix"))
			it.UsernameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameHasSuffix"))
			it.UsernameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameEqualFold"))
			it.UsernameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameContainsFold"))
			it.UsernameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discriminator":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discriminator"))
			it.Discriminator, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discriminatorNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discriminatorNEQ"))
			it.DiscriminatorNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discriminatorIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discriminatorIn"))
			it.DiscriminatorIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discriminatorNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discriminatorNotIn"))
			it.DiscriminatorNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discriminatorGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discriminatorGT"))
			it.DiscriminatorGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discriminatorGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discriminatorGTE"))
			it.DiscriminatorGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discriminatorLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discriminatorLT"))
			it.DiscriminatorLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discriminatorLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discriminatorLTE"))
			it.DiscriminatorLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discriminatorContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discriminatorContains"))
			it.DiscriminatorContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discriminatorHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discriminatorHasPrefix"))
			it.DiscriminatorHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discriminatorHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discriminatorHasSuffix"))
			it.DiscriminatorHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discriminatorEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discriminatorEqualFold"))
			it.DiscriminatorEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discriminatorContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discriminatorContainsFold"))
			it.DiscriminatorContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOwner":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwner"))
			it.HasOwner, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOwnerWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwnerWith"))
			it.HasOwnerWith, err = ec.unmarshalOUserWhereInput2githubcomfogoshgrackdbentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasBot":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBot"))
			it.HasBot, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasBotWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBotWith"))
			it.HasBotWith, err = ec.unmarshalODiscordBotWhereInput2githubcomfogoshgrackdbentDiscordBotWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDiscordBotWhereInput(ctx context.Context, obj interface{}) (ent.DiscordBotWhereInput, error) {
	var it ent.DiscordBotWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "hasAccount", "hasAccountWith", "hasProject", "hasProjectWith", "hasRepository", "hasRepositoryWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalODiscordBotWhereInput2githubcomfogoshgrackdbentDiscordBotWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalODiscordBotWhereInput2githubcomfogoshgrackdbentDiscordBotWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalODiscordBotWhereInput2githubcomfogoshgrackdbentDiscordBotWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAccount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccount"))
			it.HasAccount, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAccountWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccountWith"))
			it.HasAccountWith, err = ec.unmarshalODiscordAccountWhereInput2githubcomfogoshgrackdbentDiscordAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProject":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProject"))
			it.HasProject, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProjectWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProjectWith"))
			it.HasProjectWith, err = ec.unmarshalOProjectWhereInput2githubcomfogoshgrackdbentProjectWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepository":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepository"))
			it.HasRepository, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepositoryWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepositoryWith"))
			it.HasRepositoryWith, err = ec.unmarshalORepositoryWhereInput2githubcomfogoshgrackdbentRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubAccountOrder(ctx context.Context, obj interface{}) (ent.GithubAccountOrder, error) {
	var it ent.GithubAccountOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNGithubAccountOrderField2githubcomfogoshgrackdbentGithubAccountOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubAccountWhereInput(ctx context.Context, obj interface{}) (ent.GithubAccountWhereInput, error) {
	var it ent.GithubAccountWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "username", "usernameNEQ", "usernameIn", "usernameNotIn", "usernameGT", "usernameGTE", "usernameLT", "usernameLTE", "usernameContains", "usernameHasPrefix", "usernameHasSuffix", "usernameEqualFold", "usernameContainsFold", "hasOwner", "hasOwnerWith", "hasOrganizationMemberships", "hasOrganizationMembershipsWith", "hasRepositories", "hasRepositoriesWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOGithubAccountWhereInput2githubcomfogoshgrackdbentGithubAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOGithubAccountWhereInput2githubcomfogoshgrackdbentGithubAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOGithubAccountWhereInput2githubcomfogoshgrackdbentGithubAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			it.Username, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameNEQ"))
			it.UsernameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameIn"))
			it.UsernameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameNotIn"))
			it.UsernameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameGT"))
			it.UsernameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameGTE"))
			it.UsernameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameLT"))
			it.UsernameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameLTE"))
			it.UsernameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameContains"))
			it.UsernameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameHasPrefix"))
			it.UsernameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameHasSuffix"))
			it.UsernameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameEqualFold"))
			it.UsernameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameContainsFold"))
			it.UsernameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOwner":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwner"))
			it.HasOwner, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOwnerWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwnerWith"))
			it.HasOwnerWith, err = ec.unmarshalOUserWhereInput2githubcomfogoshgrackdbentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOrganizationMemberships":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOrganizationMemberships"))
			it.HasOrganizationMemberships, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOrganizationMembershipsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOrganizationMembershipsWith"))
			it.HasOrganizationMembershipsWith, err = ec.unmarshalOGithubOrganizationMemberWhereInput2githubcomfogoshgrackdbentGithubOrganizationMemberWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepositories":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepositories"))
			it.HasRepositories, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepositoriesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepositoriesWith"))
			it.HasRepositoriesWith, err = ec.unmarshalORepositoryWhereInput2githubcomfogoshgrackdbentRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubOrganizationMemberOrder(ctx context.Context, obj interface{}) (ent.GithubOrganizationMemberOrder, error) {
	var it ent.GithubOrganizationMemberOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNGithubOrganizationMemberOrderField2githubcomfogoshgrackdbentGithubOrganizationMemberOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubOrganizationMemberWhereInput(ctx context.Context, obj interface{}) (ent.GithubOrganizationMemberWhereInput, error) {
	var it ent.GithubOrganizationMemberWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "role", "roleNEQ", "roleIn", "roleNotIn", "hasOrganization", "hasOrganizationWith", "hasAccount", "hasAccountWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOGithubOrganizationMemberWhereInput2githubcomfogoshgrackdbentGithubOrganizationMemberWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOGithubOrganizationMemberWhereInput2githubcomfogoshgrackdbentGithubOrganizationMemberWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOGithubOrganizationMemberWhereInput2githubcomfogoshgrackdbentGithubOrganizationMemberWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "role":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			it.Role, err = ec.unmarshalOGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx, v)
			if err != nil {
				return it, err
			}
		case "roleNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleNEQ"))
			it.RoleNEQ, err = ec.unmarshalOGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx, v)
			if err != nil {
				return it, err
			}
		case "roleIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleIn"))
			it.RoleIn, err = ec.unmarshalOGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx, v)
			if err != nil {
				return it, err
			}
		case "roleNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleNotIn"))
			it.RoleNotIn, err = ec.unmarshalOGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOrganization":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOrganization"))
			it.HasOrganization, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOrganizationWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOrganizationWith"))
			it.HasOrganizationWith, err = ec.unmarshalOGithubOrganizationWhereInput2githubcomfogoshgrackdbentGithubOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAccount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccount"))
			it.HasAccount, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAccountWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccountWith"))
			it.HasAccountWith, err = ec.unmarshalOGithubAccountWhereInput2githubcomfogoshgrackdbentGithubAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubOrganizationOrder(ctx context.Context, obj interface{}) (ent.GithubOrganizationOrder, error) {
	var it ent.GithubOrganizationOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNGithubOrganizationOrderField2githubcomfogoshgrackdbentGithubOrganizationOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubOrganizationWhereInput(ctx context.Context, obj interface{}) (ent.GithubOrganizationWhereInput, error) {
	var it ent.GithubOrganizationWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "displayName", "displayNameNEQ", "displayNameIn", "displayNameNotIn", "displayNameGT", "displayNameGTE", "displayNameLT", "displayNameLTE", "displayNameContains", "displayNameHasPrefix", "displayNameHasSuffix", "displayNameIsNil", "displayNameNotNil", "displayNameEqualFold", "displayNameContainsFold", "hasMembers", "hasMembersWith", "hasRepositories", "hasRepositoriesWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOGithubOrganizationWhereInput2githubcomfogoshgrackdbentGithubOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOGithubOrganizationWhereInput2githubcomfogoshgrackdbentGithubOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOGithubOrganizationWhereInput2githubcomfogoshgrackdbentGithubOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			it.DisplayName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayNameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameNEQ"))
			it.DisplayNameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayNameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameIn"))
			it.DisplayNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayNameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameNotIn"))
			it.DisplayNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayNameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameGT"))
			it.DisplayNameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayNameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameGTE"))
			it.DisplayNameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayNameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameLT"))
			it.DisplayNameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayNameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameLTE"))
			it.DisplayNameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayNameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameContains"))
			it.DisplayNameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayNameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameHasPrefix"))
			it.DisplayNameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayNameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameHasSuffix"))
			it.DisplayNameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayNameIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameIsNil"))
			it.DisplayNameIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayNameNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameNotNil"))
			it.DisplayNameNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayNameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameEqualFold"))
			it.DisplayNameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayNameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameContainsFold"))
			it.DisplayNameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasMembers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasMembers"))
			it.HasMembers, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasMembersWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasMembersWith"))
			it.HasMembersWith, err = ec.unmarshalOGithubOrganizationMemberWhereInput2githubcomfogoshgrackdbentGithubOrganizationMemberWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepositories":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepositories"))
			it.HasRepositories, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepositoriesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepositoriesWith"))
			it.HasRepositoriesWith, err = ec.unmarshalORepositoryWhereInput2githubcomfogoshgrackdbentRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectAssociationOrder(ctx context.Context, obj interface{}) (ent.ProjectAssociationOrder, error) {
	var it ent.ProjectAssociationOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNProjectAssociationOrderField2githubcomfogoshgrackdbentProjectAssociationOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectAssociationWhereInput(ctx context.Context, obj interface{}) (ent.ProjectAssociationWhereInput, error) {
	var it ent.ProjectAssociationWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "type", "typeNEQ", "typeIn", "typeNotIn", "hasParent", "hasParentWith", "hasChild", "hasChildWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOProjectAssociationWhereInput2githubcomfogoshgrackdbentProjectAssociationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOProjectAssociationWhereInput2githubcomfogoshgrackdbentProjectAssociationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOProjectAssociationWhereInput2githubcomfogoshgrackdbentProjectAssociationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOProjectAssociationType2githubcomfogoshgrackdbentprojectassociationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			it.TypeNEQ, err = ec.unmarshalOProjectAssociationType2githubcomfogoshgrackdbentprojectassociationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			it.TypeIn, err = ec.unmarshalOProjectAssociationType2githubcomfogoshgrackdbentprojectassociationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			it.TypeNotIn, err = ec.unmarshalOProjectAssociationType2githubcomfogoshgrackdbentprojectassociationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasParent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasParent"))
			it.HasParent, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasParentWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasParentWith"))
			it.HasParentWith, err = ec.unmarshalOProjectWhereInput2githubcomfogoshgrackdbentProjectWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasChild":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasChild"))
			it.HasChild, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasChildWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasChildWith"))
			it.HasChildWith, err = ec.unmarshalOProjectWhereInput2githubcomfogoshgrackdbentProjectWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectContributorOrder(ctx context.Context, obj interface{}) (ent.ProjectContributorOrder, error) {
	var it ent.ProjectContributorOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNProjectContributorOrderField2githubcomfogoshgrackdbentProjectContributorOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectContributorWhereInput(ctx context.Context, obj interface{}) (ent.ProjectContributorWhereInput, error) {
	var it ent.ProjectContributorWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "role", "roleNEQ", "roleIn", "roleNotIn", "hasProject", "hasProjectWith", "hasUser", "hasUserWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOProjectContributorWhereInput2githubcomfogoshgrackdbentProjectContributorWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOProjectContributorWhereInput2githubcomfogoshgrackdbentProjectContributorWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOProjectContributorWhereInput2githubcomfogoshgrackdbentProjectContributorWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "role":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			it.Role, err = ec.unmarshalOProjectContributorRole2githubcomfogoshgrackdbentprojectcontributorRole(ctx, v)
			if err != nil {
				return it, err
			}
		case "roleNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleNEQ"))
			it.RoleNEQ, err = ec.unmarshalOProjectContributorRole2githubcomfogoshgrackdbentprojectcontributorRole(ctx, v)
			if err != nil {
				return it, err
			}
		case "roleIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleIn"))
			it.RoleIn, err = ec.unmarshalOProjectContributorRole2githubcomfogoshgrackdbentprojectcontributorRole(ctx, v)
			if err != nil {
				return it, err
			}
		case "roleNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleNotIn"))
			it.RoleNotIn, err = ec.unmarshalOProjectContributorRole2githubcomfogoshgrackdbentprojectcontributorRole(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProject":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProject"))
			it.HasProject, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProjectWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProjectWith"))
			it.HasProjectWith, err = ec.unmarshalOProjectWhereInput2githubcomfogoshgrackdbentProjectWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasUser":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUser"))
			it.HasUser, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasUserWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserWith"))
			it.HasUserWith, err = ec.unmarshalOUserWhereInput2githubcomfogoshgrackdbentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectOrder(ctx context.Context, obj interface{}) (ent.ProjectOrder, error) {
	var it ent.ProjectOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNProjectOrderField2githubcomfogoshgrackdbentProjectOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectTechnologyOrder(ctx context.Context, obj interface{}) (ent.ProjectTechnologyOrder, error) {
	var it ent.ProjectTechnologyOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNProjectTechnologyOrderField2githubcomfogoshgrackdbentProjectTechnologyOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectTechnologyWhereInput(ctx context.Context, obj interface{}) (ent.ProjectTechnologyWhereInput, error) {
	var it ent.ProjectTechnologyWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "type", "typeNEQ", "typeIn", "typeNotIn", "hasProject", "hasProjectWith", "hasTechnology", "hasTechnologyWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOProjectTechnologyWhereInput2githubcomfogoshgrackdbentProjectTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOProjectTechnologyWhereInput2githubcomfogoshgrackdbentProjectTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOProjectTechnologyWhereInput2githubcomfogoshgrackdbentProjectTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOProjectTechnologyType2githubcomfogoshgrackdbentprojecttechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			it.TypeNEQ, err = ec.unmarshalOProjectTechnologyType2githubcomfogoshgrackdbentprojecttechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			it.TypeIn, err = ec.unmarshalOProjectTechnologyType2githubcomfogoshgrackdbentprojecttechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			it.TypeNotIn, err = ec.unmarshalOProjectTechnologyType2githubcomfogoshgrackdbentprojecttechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProject":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProject"))
			it.HasProject, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProjectWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProjectWith"))
			it.HasProjectWith, err = ec.unmarshalOProjectWhereInput2githubcomfogoshgrackdbentProjectWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTechnology":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTechnology"))
			it.HasTechnology, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTechnologyWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTechnologyWith"))
			it.HasTechnologyWith, err = ec.unmarshalOTechnologyWhereInput2githubcomfogoshgrackdbentTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectWhereInput(ctx context.Context, obj interface{}) (ent.ProjectWhereInput, error) {
	var it ent.ProjectWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionIsNil", "descriptionNotNil", "descriptionEqualFold", "descriptionContainsFold", "startDate", "startDateNEQ", "startDateIn", "startDateNotIn", "startDateGT", "startDateGTE", "startDateLT", "startDateLTE", "endDate", "endDateNEQ", "endDateIn", "endDateNotIn", "endDateGT", "endDateGTE", "endDateLT", "endDateLTE", "endDateIsNil", "endDateNotNil", "hasContributors", "hasContributorsWith", "hasParentProjects", "hasParentProjectsWith", "hasChildProjects", "hasChildProjectsWith", "hasRepositories", "hasRepositoriesWith", "hasDiscordBots", "hasDiscordBotsWith", "hasSites", "hasSitesWith", "hasTechnologies", "hasTechnologiesWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOProjectWhereInput2githubcomfogoshgrackdbentProjectWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOProjectWhereInput2githubcomfogoshgrackdbentProjectWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOProjectWhereInput2githubcomfogoshgrackdbentProjectWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			it.DescriptionNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			it.DescriptionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			it.DescriptionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			it.DescriptionGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			it.DescriptionGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			it.DescriptionLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			it.DescriptionLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			it.DescriptionContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			it.DescriptionHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			it.DescriptionHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIsNil"))
			it.DescriptionIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotNil"))
			it.DescriptionNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			it.DescriptionEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			it.DescriptionContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			it.StartDate, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDateNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDateNEQ"))
			it.StartDateNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDateIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDateIn"))
			it.StartDateIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDateNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDateNotIn"))
			it.StartDateNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDateGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDateGT"))
			it.StartDateGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDateGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDateGTE"))
			it.StartDateGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDateLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDateLT"))
			it.StartDateLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDateLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDateLTE"))
			it.StartDateLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))
			it.EndDate, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDateNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDateNEQ"))
			it.EndDateNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDateIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDateIn"))
			it.EndDateIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDateNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDateNotIn"))
			it.EndDateNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDateGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDateGT"))
			it.EndDateGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDateGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDateGTE"))
			it.EndDateGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDateLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDateLT"))
			it.EndDateLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDateLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDateLTE"))
			it.EndDateLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDateIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDateIsNil"))
			it.EndDateIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDateNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDateNotNil"))
			it.EndDateNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasContributors":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasContributors"))
			it.HasContributors, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasContributorsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasContributorsWith"))
			it.HasContributorsWith, err = ec.unmarshalOProjectContributorWhereInput2githubcomfogoshgrackdbentProjectContributorWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasParentProjects":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasParentProjects"))
			it.HasParentProjects, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasParentProjectsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasParentProjectsWith"))
			it.HasParentProjectsWith, err = ec.unmarshalOProjectAssociationWhereInput2githubcomfogoshgrackdbentProjectAssociationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasChildProjects":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasChildProjects"))
			it.HasChildProjects, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasChildProjectsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasChildProjectsWith"))
			it.HasChildProjectsWith, err = ec.unmarshalOProjectAssociationWhereInput2githubcomfogoshgrackdbentProjectAssociationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepositories":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepositories"))
			it.HasRepositories, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepositoriesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepositoriesWith"))
			it.HasRepositoriesWith, err = ec.unmarshalORepositoryWhereInput2githubcomfogoshgrackdbentRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDiscordBots":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDiscordBots"))
			it.HasDiscordBots, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDiscordBotsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDiscordBotsWith"))
			it.HasDiscordBotsWith, err = ec.unmarshalODiscordBotWhereInput2githubcomfogoshgrackdbentDiscordBotWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSites":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSites"))
			it.HasSites, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSitesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSitesWith"))
			it.HasSitesWith, err = ec.unmarshalOSiteWhereInput2githubcomfogoshgrackdbentSiteWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTechnologies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTechnologies"))
			it.HasTechnologies, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTechnologiesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTechnologiesWith"))
			it.HasTechnologiesWith, err = ec.unmarshalOProjectTechnologyWhereInput2githubcomfogoshgrackdbentProjectTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepositoryOrder(ctx context.Context, obj interface{}) (ent.RepositoryOrder, error) {
	var it ent.RepositoryOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNRepositoryOrderField2githubcomfogoshgrackdbentRepositoryOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepositoryTechnologyOrder(ctx context.Context, obj interface{}) (ent.RepositoryTechnologyOrder, error) {
	var it ent.RepositoryTechnologyOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNRepositoryTechnologyOrderField2githubcomfogoshgrackdbentRepositoryTechnologyOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepositoryTechnologyWhereInput(ctx context.Context, obj interface{}) (ent.RepositoryTechnologyWhereInput, error) {
	var it ent.RepositoryTechnologyWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "type", "typeNEQ", "typeIn", "typeNotIn", "hasRepository", "hasRepositoryWith", "hasTechnology", "hasTechnologyWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalORepositoryTechnologyWhereInput2githubcomfogoshgrackdbentRepositoryTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalORepositoryTechnologyWhereInput2githubcomfogoshgrackdbentRepositoryTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalORepositoryTechnologyWhereInput2githubcomfogoshgrackdbentRepositoryTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalORepositoryTechnologyType2githubcomfogoshgrackdbentrepositorytechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			it.TypeNEQ, err = ec.unmarshalORepositoryTechnologyType2githubcomfogoshgrackdbentrepositorytechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			it.TypeIn, err = ec.unmarshalORepositoryTechnologyType2githubcomfogoshgrackdbentrepositorytechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			it.TypeNotIn, err = ec.unmarshalORepositoryTechnologyType2githubcomfogoshgrackdbentrepositorytechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepository":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepository"))
			it.HasRepository, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepositoryWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepositoryWith"))
			it.HasRepositoryWith, err = ec.unmarshalORepositoryWhereInput2githubcomfogoshgrackdbentRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTechnology":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTechnology"))
			it.HasTechnology, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTechnologyWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTechnologyWith"))
			it.HasTechnologyWith, err = ec.unmarshalOTechnologyWhereInput2githubcomfogoshgrackdbentTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepositoryWhereInput(ctx context.Context, obj interface{}) (ent.RepositoryWhereInput, error) {
	var it ent.RepositoryWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionIsNil", "descriptionNotNil", "descriptionEqualFold", "descriptionContainsFold", "hasProject", "hasProjectWith", "hasGithubAccount", "hasGithubAccountWith", "hasGithubOrganization", "hasGithubOrganizationWith", "hasDiscordBots", "hasDiscordBotsWith", "hasSites", "hasSitesWith", "hasTechnologies", "hasTechnologiesWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalORepositoryWhereInput2githubcomfogoshgrackdbentRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalORepositoryWhereInput2githubcomfogoshgrackdbentRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalORepositoryWhereInput2githubcomfogoshgrackdbentRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			it.DescriptionNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			it.DescriptionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			it.DescriptionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			it.DescriptionGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			it.DescriptionGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			it.DescriptionLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			it.DescriptionLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			it.DescriptionContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			it.DescriptionHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			it.DescriptionHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIsNil"))
			it.DescriptionIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotNil"))
			it.DescriptionNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			it.DescriptionEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			it.DescriptionContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProject":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProject"))
			it.HasProject, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProjectWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProjectWith"))
			it.HasProjectWith, err = ec.unmarshalOProjectWhereInput2githubcomfogoshgrackdbentProjectWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasGithubAccount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGithubAccount"))
			it.HasGithubAccount, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasGithubAccountWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGithubAccountWith"))
			it.HasGithubAccountWith, err = ec.unmarshalOGithubAccountWhereInput2githubcomfogoshgrackdbentGithubAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasGithubOrganization":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGithubOrganization"))
			it.HasGithubOrganization, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasGithubOrganizationWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGithubOrganizationWith"))
			it.HasGithubOrganizationWith, err = ec.unmarshalOGithubOrganizationWhereInput2githubcomfogoshgrackdbentGithubOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDiscordBots":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDiscordBots"))
			it.HasDiscordBots, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDiscordBotsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDiscordBotsWith"))
			it.HasDiscordBotsWith, err = ec.unmarshalODiscordBotWhereInput2githubcomfogoshgrackdbentDiscordBotWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSites":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSites"))
			it.HasSites, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSitesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSitesWith"))
			it.HasSitesWith, err = ec.unmarshalOSiteWhereInput2githubcomfogoshgrackdbentSiteWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTechnologies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTechnologies"))
			it.HasTechnologies, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTechnologiesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTechnologiesWith"))
			it.HasTechnologiesWith, err = ec.unmarshalORepositoryTechnologyWhereInput2githubcomfogoshgrackdbentRepositoryTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSiteOrder(ctx context.Context, obj interface{}) (ent.SiteOrder, error) {
	var it ent.SiteOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNSiteOrderField2githubcomfogoshgrackdbentSiteOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSiteWhereInput(ctx context.Context, obj interface{}) (ent.SiteWhereInput, error) {
	var it ent.SiteWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "url", "urlNEQ", "urlIn", "urlNotIn", "urlGT", "urlGTE", "urlLT", "urlLTE", "urlContains", "urlHasPrefix", "urlHasSuffix", "urlEqualFold", "urlContainsFold", "hasProject", "hasProjectWith", "hasRepository", "hasRepositoryWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOSiteWhereInput2githubcomfogoshgrackdbentSiteWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOSiteWhereInput2githubcomfogoshgrackdbentSiteWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOSiteWhereInput2githubcomfogoshgrackdbentSiteWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			it.URL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "urlNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlNEQ"))
			it.URLNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "urlIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlIn"))
			it.URLIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "urlNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlNotIn"))
			it.URLNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "urlGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlGT"))
			it.URLGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "urlGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlGTE"))
			it.URLGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "urlLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlLT"))
			it.URLLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "urlLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlLTE"))
			it.URLLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "urlContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlContains"))
			it.URLContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "urlHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlHasPrefix"))
			it.URLHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "urlHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlHasSuffix"))
			it.URLHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "urlEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlEqualFold"))
			it.URLEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "urlContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlContainsFold"))
			it.URLContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProject":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProject"))
			it.HasProject, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProjectWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProjectWith"))
			it.HasProjectWith, err = ec.unmarshalOProjectWhereInput2githubcomfogoshgrackdbentProjectWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepository":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepository"))
			it.HasRepository, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepositoryWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepositoryWith"))
			it.HasRepositoryWith, err = ec.unmarshalORepositoryWhereInput2githubcomfogoshgrackdbentRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTechnologyAssociationOrder(ctx context.Context, obj interface{}) (ent.TechnologyAssociationOrder, error) {
	var it ent.TechnologyAssociationOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNTechnologyAssociationOrderField2githubcomfogoshgrackdbentTechnologyAssociationOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTechnologyAssociationWhereInput(ctx context.Context, obj interface{}) (ent.TechnologyAssociationWhereInput, error) {
	var it ent.TechnologyAssociationWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "type", "typeNEQ", "typeIn", "typeNotIn", "hasParent", "hasParentWith", "hasChild", "hasChildWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOTechnologyAssociationWhereInput2githubcomfogoshgrackdbentTechnologyAssociationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOTechnologyAssociationWhereInput2githubcomfogoshgrackdbentTechnologyAssociationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOTechnologyAssociationWhereInput2githubcomfogoshgrackdbentTechnologyAssociationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOTechnologyAssociationType2githubcomfogoshgrackdbenttechnologyassociationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			it.TypeNEQ, err = ec.unmarshalOTechnologyAssociationType2githubcomfogoshgrackdbenttechnologyassociationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			it.TypeIn, err = ec.unmarshalOTechnologyAssociationType2githubcomfogoshgrackdbenttechnologyassociationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			it.TypeNotIn, err = ec.unmarshalOTechnologyAssociationType2githubcomfogoshgrackdbenttechnologyassociationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasParent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasParent"))
			it.HasParent, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasParentWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasParentWith"))
			it.HasParentWith, err = ec.unmarshalOTechnologyWhereInput2githubcomfogoshgrackdbentTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasChild":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasChild"))
			it.HasChild, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasChildWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasChildWith"))
			it.HasChildWith, err = ec.unmarshalOTechnologyWhereInput2githubcomfogoshgrackdbentTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTechnologyOrder(ctx context.Context, obj interface{}) (ent.TechnologyOrder, error) {
	var it ent.TechnologyOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNTechnologyOrderField2githubcomfogoshgrackdbentTechnologyOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTechnologyWhereInput(ctx context.Context, obj interface{}) (ent.TechnologyWhereInput, error) {
	var it ent.TechnologyWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionIsNil", "descriptionNotNil", "descriptionEqualFold", "descriptionContainsFold", "colour", "colourNEQ", "colourIn", "colourNotIn", "colourGT", "colourGTE", "colourLT", "colourLTE", "colourContains", "colourHasPrefix", "colourHasSuffix", "colourIsNil", "colourNotNil", "colourEqualFold", "colourContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "hasParentTechnologies", "hasParentTechnologiesWith", "hasChildTechnologies", "hasChildTechnologiesWith", "hasProjects", "hasProjectsWith", "hasRepositories", "hasRepositoriesWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOTechnologyWhereInput2githubcomfogoshgrackdbentTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOTechnologyWhereInput2githubcomfogoshgrackdbentTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOTechnologyWhereInput2githubcomfogoshgrackdbentTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			it.DescriptionNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			it.DescriptionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			it.DescriptionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			it.DescriptionGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			it.DescriptionGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			it.DescriptionLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			it.DescriptionLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			it.DescriptionContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			it.DescriptionHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			it.DescriptionHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIsNil"))
			it.DescriptionIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotNil"))
			it.DescriptionNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			it.DescriptionEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			it.DescriptionContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "colour":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colour"))
			it.Colour, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "colourNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colourNEQ"))
			it.ColourNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "colourIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colourIn"))
			it.ColourIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "colourNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colourNotIn"))
			it.ColourNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "colourGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colourGT"))
			it.ColourGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "colourGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colourGTE"))
			it.ColourGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "colourLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colourLT"))
			it.ColourLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "colourLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colourLTE"))
			it.ColourLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "colourContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colourContains"))
			it.ColourContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "colourHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colourHasPrefix"))
			it.ColourHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "colourHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colourHasSuffix"))
			it.ColourHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "colourIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colourIsNil"))
			it.ColourIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "colourNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colourNotNil"))
			it.ColourNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "colourEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colourEqualFold"))
			it.ColourEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "colourContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colourContainsFold"))
			it.ColourContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOTechnologyType2githubcomfogoshgrackdbenttechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			it.TypeNEQ, err = ec.unmarshalOTechnologyType2githubcomfogoshgrackdbenttechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			it.TypeIn, err = ec.unmarshalOTechnologyType2githubcomfogoshgrackdbenttechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			it.TypeNotIn, err = ec.unmarshalOTechnologyType2githubcomfogoshgrackdbenttechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasParentTechnologies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasParentTechnologies"))
			it.HasParentTechnologies, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasParentTechnologiesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasParentTechnologiesWith"))
			it.HasParentTechnologiesWith, err = ec.unmarshalOTechnologyAssociationWhereInput2githubcomfogoshgrackdbentTechnologyAssociationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasChildTechnologies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasChildTechnologies"))
			it.HasChildTechnologies, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasChildTechnologiesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasChildTechnologiesWith"))
			it.HasChildTechnologiesWith, err = ec.unmarshalOTechnologyAssociationWhereInput2githubcomfogoshgrackdbentTechnologyAssociationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProjects":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProjects"))
			it.HasProjects, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProjectsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProjectsWith"))
			it.HasProjectsWith, err = ec.unmarshalOProjectTechnologyWhereInput2githubcomfogoshgrackdbentProjectTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepositories":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepositories"))
			it.HasRepositories, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepositoriesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepositoriesWith"))
			it.HasRepositoriesWith, err = ec.unmarshalORepositoryTechnologyWhereInput2githubcomfogoshgrackdbentRepositoryTechnologyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateDiscordAccountInput(ctx context.Context, obj interface{}) (ent.UpdateDiscordAccountInput, error) {
	var it ent.UpdateDiscordAccountInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "discriminator", "owner"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			it.Username, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discriminator":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discriminator"))
			it.Discriminator, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "owner":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			it.Owner, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateDiscordBotInput(ctx context.Context, obj interface{}) (ent.UpdateDiscordBotInput, error) {
	var it ent.UpdateDiscordBotInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"account", "project", "repository"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "account":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("account"))
			it.Account, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "project":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			it.Project, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "repository":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repository"))
			it.Repository, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateGithubAccountInput(ctx context.Context, obj interface{}) (ent.UpdateGithubAccountInput, error) {
	var it ent.UpdateGithubAccountInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "owner"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			it.Username, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "owner":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			it.Owner, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateGithubOrganizationInput(ctx context.Context, obj interface{}) (ent.UpdateGithubOrganizationInput, error) {
	var it ent.UpdateGithubOrganizationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "displayName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			it.DisplayName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateGithubOrganizationMemberInput(ctx context.Context, obj interface{}) (ent.UpdateGithubOrganizationMemberInput, error) {
	var it ent.UpdateGithubOrganizationMemberInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"role", "account", "organization"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "role":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			it.Role, err = ec.unmarshalOGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx, v)
			if err != nil {
				return it, err
			}
		case "account":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("account"))
			it.Account, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "organization":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organization"))
			it.Organization, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateProjectAssociationInput(ctx context.Context, obj interface{}) (ent.UpdateProjectAssociationInput, error) {
	var it ent.UpdateProjectAssociationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "parent", "child"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOProjectAssociationType2githubcomfogoshgrackdbentprojectassociationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "parent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parent"))
			it.Parent, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "child":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("child"))
			it.Child, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateProjectContributorInput(ctx context.Context, obj interface{}) (ent.UpdateProjectContributorInput, error) {
	var it ent.UpdateProjectContributorInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"role", "project", "user"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "role":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			it.Role, err = ec.unmarshalOProjectContributorRole2githubcomfogoshgrackdbentprojectcontributorRole(ctx, v)
			if err != nil {
				return it, err
			}
		case "project":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			it.Project, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "user":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user"))
			it.User, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateProjectInput(ctx context.Context, obj interface{}) (ent.UpdateProjectInput, error) {
	var it ent.UpdateProjectInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "startDate", "endDate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			it.StartDate, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))
			it.EndDate, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateProjectTechnologyInput(ctx context.Context, obj interface{}) (ent.UpdateProjectTechnologyInput, error) {
	var it ent.UpdateProjectTechnologyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "technology", "project"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOProjectTechnologyType2githubcomfogoshgrackdbentprojecttechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "technology":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("technology"))
			it.Technology, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "project":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			it.Project, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateRepositoryInput(ctx context.Context, obj interface{}) (ent.UpdateRepositoryInput, error) {
	var it ent.UpdateRepositoryInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "project", "githubAccount", "githubOrganization"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "project":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			it.Project, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubAccount"))
			it.GithubAccount, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubOrganization":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubOrganization"))
			it.GithubOrganization, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateRepositoryTechnologyInput(ctx context.Context, obj interface{}) (ent.UpdateRepositoryTechnologyInput, error) {
	var it ent.UpdateRepositoryTechnologyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "technology", "repository"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalORepositoryTechnologyType2githubcomfogoshgrackdbentrepositorytechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		case "technology":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("technology"))
			it.Technology, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "repository":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repository"))
			it.Repository, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSiteInput(ctx context.Context, obj interface{}) (ent.UpdateSiteInput, error) {
	var it ent.UpdateSiteInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url", "project", "repository"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			it.URL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "project":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			it.Project, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "repository":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repository"))
			it.Repository, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTechnologyAssociationInput(ctx context.Context, obj interface{}) (ent.UpdateTechnologyAssociationInput, error) {
	var it ent.UpdateTechnologyAssociationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "parent", "child"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOTechnologyAssociationType2githubcomfogoshgrackdbenttechnologyassociationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "parent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parent"))
			it.Parent, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "child":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("child"))
			it.Child, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTechnologyInput(ctx context.Context, obj interface{}) (ent.UpdateTechnologyInput, error) {
	var it ent.UpdateTechnologyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "colour", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "colour":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colour"))
			it.Colour, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOTechnologyType2githubcomfogoshgrackdbenttechnologyType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserInput(ctx context.Context, obj interface{}) (ent.UpdateUserInput, error) {
	var it ent.UpdateUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "avatarUrl"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			it.Username, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarUrl":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUrl"))
			it.AvatarURL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserOrder(ctx context.Context, obj interface{}) (ent.UserOrder, error) {
	var it ent.UserOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNUserOrderField2githubcomfogoshgrackdbentUserOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserWhereInput(ctx context.Context, obj interface{}) (ent.UserWhereInput, error) {
	var it ent.UserWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "username", "usernameNEQ", "usernameIn", "usernameNotIn", "usernameGT", "usernameGTE", "usernameLT", "usernameLTE", "usernameContains", "usernameHasPrefix", "usernameHasSuffix", "usernameEqualFold", "usernameContainsFold", "avatarURL", "avatarURLNEQ", "avatarURLIn", "avatarURLNotIn", "avatarURLGT", "avatarURLGTE", "avatarURLLT", "avatarURLLTE", "avatarURLContains", "avatarURLHasPrefix", "avatarURLHasSuffix", "avatarURLIsNil", "avatarURLNotNil", "avatarURLEqualFold", "avatarURLContainsFold", "hasDiscordAccounts", "hasDiscordAccountsWith", "hasGithubAccounts", "hasGithubAccountsWith", "hasProjectContributions", "hasProjectContributionsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOUserWhereInput2githubcomfogoshgrackdbentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOUserWhereInput2githubcomfogoshgrackdbentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOUserWhereInput2githubcomfogoshgrackdbentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			it.Username, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameNEQ"))
			it.UsernameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameIn"))
			it.UsernameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameNotIn"))
			it.UsernameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameGT"))
			it.UsernameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameGTE"))
			it.UsernameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameLT"))
			it.UsernameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameLTE"))
			it.UsernameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameContains"))
			it.UsernameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameHasPrefix"))
			it.UsernameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameHasSuffix"))
			it.UsernameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameEqualFold"))
			it.UsernameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "usernameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameContainsFold"))
			it.UsernameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURL":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURL"))
			it.AvatarURL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLNEQ"))
			it.AvatarURLNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLIn"))
			it.AvatarURLIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLNotIn"))
			it.AvatarURLNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLGT"))
			it.AvatarURLGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLGTE"))
			it.AvatarURLGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLLT"))
			it.AvatarURLLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLLTE"))
			it.AvatarURLLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLContains"))
			it.AvatarURLContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLHasPrefix"))
			it.AvatarURLHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLHasSuffix"))
			it.AvatarURLHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLIsNil"))
			it.AvatarURLIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLNotNil"))
			it.AvatarURLNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLEqualFold"))
			it.AvatarURLEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLContainsFold"))
			it.AvatarURLContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDiscordAccounts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDiscordAccounts"))
			it.HasDiscordAccounts, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDiscordAccountsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDiscordAccountsWith"))
			it.HasDiscordAccountsWith, err = ec.unmarshalODiscordAccountWhereInput2githubcomfogoshgrackdbentDiscordAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasGithubAccounts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGithubAccounts"))
			it.HasGithubAccounts, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasGithubAccountsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGithubAccountsWith"))
			it.HasGithubAccountsWith, err = ec.unmarshalOGithubAccountWhereInput2githubcomfogoshgrackdbentGithubAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProjectContributions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProjectContributions"))
			it.HasProjectContributions, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProjectContributionsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProjectContributionsWith"))
			it.HasProjectContributionsWith, err = ec.unmarshalOProjectContributorWhereInput2githubcomfogoshgrackdbentProjectContributorWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj ent.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.DiscordAccount:
		if obj == nil {
			return graphql.Null
		}
		return ec._DiscordAccount(ctx, sel, obj)
	case *ent.DiscordBot:
		if obj == nil {
			return graphql.Null
		}
		return ec._DiscordBot(ctx, sel, obj)
	case *ent.GithubAccount:
		if obj == nil {
			return graphql.Null
		}
		return ec._GithubAccount(ctx, sel, obj)
	case *ent.GithubOrganization:
		if obj == nil {
			return graphql.Null
		}
		return ec._GithubOrganization(ctx, sel, obj)
	case *ent.GithubOrganizationMember:
		if obj == nil {
			return graphql.Null
		}
		return ec._GithubOrganizationMember(ctx, sel, obj)
	case *ent.Project:
		if obj == nil {
			return graphql.Null
		}
		return ec._Project(ctx, sel, obj)
	case *ent.ProjectAssociation:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProjectAssociation(ctx, sel, obj)
	case *ent.ProjectContributor:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProjectContributor(ctx, sel, obj)
	case *ent.ProjectTechnology:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProjectTechnology(ctx, sel, obj)
	case *ent.Repository:
		if obj == nil {
			return graphql.Null
		}
		return ec._Repository(ctx, sel, obj)
	case *ent.RepositoryTechnology:
		if obj == nil {
			return graphql.Null
		}
		return ec._RepositoryTechnology(ctx, sel, obj)
	case *ent.Site:
		if obj == nil {
			return graphql.Null
		}
		return ec._Site(ctx, sel, obj)
	case *ent.Technology:
		if obj == nil {
			return graphql.Null
		}
		return ec._Technology(ctx, sel, obj)
	case *ent.TechnologyAssociation:
		if obj == nil {
			return graphql.Null
		}
		return ec._TechnologyAssociation(ctx, sel, obj)
	case *ent.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var authProviderImplementors = []string{"AuthProvider"}

func (ec *executionContext) _AuthProvider(ctx context.Context, sel ast.SelectionSet, obj *AuthProvider) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authProviderImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthProvider")
		case "type":

			out.Values[i] = ec._AuthProvider_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":

			out.Values[i] = ec._AuthProvider_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var discordAccountImplementors = []string{"DiscordAccount", "Node"}

func (ec *executionContext) _DiscordAccount(ctx context.Context, sel ast.SelectionSet, obj *ent.DiscordAccount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, discordAccountImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiscordAccount")
		case "id":

			out.Values[i] = ec._DiscordAccount_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "discordID":

			out.Values[i] = ec._DiscordAccount_discordID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "username":

			out.Values[i] = ec._DiscordAccount_username(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "discriminator":

			out.Values[i] = ec._DiscordAccount_discriminator(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "owner":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscordAccount_owner(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "bot":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscordAccount_bot(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var discordAccountConnectionImplementors = []string{"DiscordAccountConnection"}

func (ec *executionContext) _DiscordAccountConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.DiscordAccountConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, discordAccountConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiscordAccountConnection")
		case "edges":

			out.Values[i] = ec._DiscordAccountConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._DiscordAccountConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._DiscordAccountConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var discordAccountEdgeImplementors = []string{"DiscordAccountEdge"}

func (ec *executionContext) _DiscordAccountEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.DiscordAccountEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, discordAccountEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiscordAccountEdge")
		case "node":

			out.Values[i] = ec._DiscordAccountEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._DiscordAccountEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var discordBotImplementors = []string{"DiscordBot", "Node"}

func (ec *executionContext) _DiscordBot(ctx context.Context, sel ast.SelectionSet, obj *ent.DiscordBot) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, discordBotImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiscordBot")
		case "id":

			out.Values[i] = ec._DiscordBot_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "account":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscordBot_account(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "project":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscordBot_project(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "repository":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscordBot_repository(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var discordBotConnectionImplementors = []string{"DiscordBotConnection"}

func (ec *executionContext) _DiscordBotConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.DiscordBotConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, discordBotConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiscordBotConnection")
		case "edges":

			out.Values[i] = ec._DiscordBotConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._DiscordBotConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._DiscordBotConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var discordBotEdgeImplementors = []string{"DiscordBotEdge"}

func (ec *executionContext) _DiscordBotEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.DiscordBotEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, discordBotEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiscordBotEdge")
		case "node":

			out.Values[i] = ec._DiscordBotEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._DiscordBotEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubAccountImplementors = []string{"GithubAccount", "Node"}

func (ec *executionContext) _GithubAccount(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubAccount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubAccountImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubAccount")
		case "id":

			out.Values[i] = ec._GithubAccount_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "username":

			out.Values[i] = ec._GithubAccount_username(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "owner":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubAccount_owner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "organizationMemberships":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubAccount_organizationMemberships(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "repositories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubAccount_repositories(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubAccountConnectionImplementors = []string{"GithubAccountConnection"}

func (ec *executionContext) _GithubAccountConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubAccountConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubAccountConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubAccountConnection")
		case "edges":

			out.Values[i] = ec._GithubAccountConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._GithubAccountConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._GithubAccountConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubAccountEdgeImplementors = []string{"GithubAccountEdge"}

func (ec *executionContext) _GithubAccountEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubAccountEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubAccountEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubAccountEdge")
		case "node":

			out.Values[i] = ec._GithubAccountEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._GithubAccountEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubOrganizationImplementors = []string{"GithubOrganization", "Node"}

func (ec *executionContext) _GithubOrganization(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubOrganization) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubOrganizationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubOrganization")
		case "id":

			out.Values[i] = ec._GithubOrganization_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._GithubOrganization_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "displayName":

			out.Values[i] = ec._GithubOrganization_displayName(ctx, field, obj)

		case "members":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubOrganization_members(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "repositories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubOrganization_repositories(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubOrganizationConnectionImplementors = []string{"GithubOrganizationConnection"}

func (ec *executionContext) _GithubOrganizationConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubOrganizationConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubOrganizationConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubOrganizationConnection")
		case "edges":

			out.Values[i] = ec._GithubOrganizationConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._GithubOrganizationConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._GithubOrganizationConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubOrganizationEdgeImplementors = []string{"GithubOrganizationEdge"}

func (ec *executionContext) _GithubOrganizationEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubOrganizationEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubOrganizationEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubOrganizationEdge")
		case "node":

			out.Values[i] = ec._GithubOrganizationEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._GithubOrganizationEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubOrganizationMemberImplementors = []string{"GithubOrganizationMember", "Node"}

func (ec *executionContext) _GithubOrganizationMember(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubOrganizationMember) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubOrganizationMemberImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubOrganizationMember")
		case "id":

			out.Values[i] = ec._GithubOrganizationMember_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "role":

			out.Values[i] = ec._GithubOrganizationMember_role(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "organization":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubOrganizationMember_organization(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "account":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubOrganizationMember_account(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubOrganizationMemberConnectionImplementors = []string{"GithubOrganizationMemberConnection"}

func (ec *executionContext) _GithubOrganizationMemberConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubOrganizationMemberConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubOrganizationMemberConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubOrganizationMemberConnection")
		case "edges":

			out.Values[i] = ec._GithubOrganizationMemberConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._GithubOrganizationMemberConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._GithubOrganizationMemberConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubOrganizationMemberEdgeImplementors = []string{"GithubOrganizationMemberEdge"}

func (ec *executionContext) _GithubOrganizationMemberEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubOrganizationMemberEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubOrganizationMemberEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubOrganizationMemberEdge")
		case "node":

			out.Values[i] = ec._GithubOrganizationMemberEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._GithubOrganizationMemberEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUser(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUser(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteUser(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createDiscordAccount":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createDiscordAccount(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateDiscordAccount":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateDiscordAccount(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteDiscordAccount":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteDiscordAccount(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createDiscordBot":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createDiscordBot(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateDiscordBot":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateDiscordBot(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteDiscordBot":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteDiscordBot(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createGithubAccount":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createGithubAccount(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateGithubAccount":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateGithubAccount(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteGithubAccount":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteGithubAccount(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createGithubOrganization":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createGithubOrganization(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateGithubOrganization":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateGithubOrganization(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteGithubOrganization":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteGithubOrganization(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createGithubOrganizationMember":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createGithubOrganizationMember(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateGithubOrganizationMember":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateGithubOrganizationMember(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteGithubOrganizationMember":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteGithubOrganizationMember(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createProject":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createProject(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateProject":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateProject(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteProject":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteProject(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createProjectContributor":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createProjectContributor(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateProjectContributor":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateProjectContributor(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteProjectContributor":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteProjectContributor(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createProjectAssociation":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createProjectAssociation(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateProjectAssociation":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateProjectAssociation(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteProjectAssociation":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteProjectAssociation(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createRepository":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createRepository(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateRepository":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRepository(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteRepository":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteRepository(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createSite":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSite(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateSite":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSite(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteSite":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSite(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createTechnology":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTechnology(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateTechnology":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTechnology(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteTechnology":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTechnology(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createTechnologyAssociation":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTechnologyAssociation(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateTechnologyAssociation":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTechnologyAssociation(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteTechnologyAssociation":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTechnologyAssociation(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createProjectTechnology":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createProjectTechnology(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateProjectTechnology":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateProjectTechnology(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteProjectTechnology":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteProjectTechnology(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createRepositoryTechnology":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createRepositoryTechnology(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateRepositoryTechnology":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRepositoryTechnology(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteRepositoryTechnology":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteRepositoryTechnology(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "assumeDevelopmentUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_assumeDevelopmentUser(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *ent.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":

			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hasPreviousPage":

			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startCursor":

			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)

		case "endCursor":

			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectImplementors = []string{"Project", "Node"}

func (ec *executionContext) _Project(ctx context.Context, sel ast.SelectionSet, obj *ent.Project) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Project")
		case "id":

			out.Values[i] = ec._Project_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Project_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Project_description(ctx, field, obj)

		case "startDate":

			out.Values[i] = ec._Project_startDate(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "endDate":

			out.Values[i] = ec._Project_endDate(ctx, field, obj)

		case "contributors":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_contributors(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "parentProjects":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_parentProjects(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "childProjects":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_childProjects(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "repositories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_repositories(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "discordBots":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_discordBots(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "sites":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_sites(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "technologies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_technologies(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectAssociationImplementors = []string{"ProjectAssociation", "Node"}

func (ec *executionContext) _ProjectAssociation(ctx context.Context, sel ast.SelectionSet, obj *ent.ProjectAssociation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectAssociationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectAssociation")
		case "id":

			out.Values[i] = ec._ProjectAssociation_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":

			out.Values[i] = ec._ProjectAssociation_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "parent":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectAssociation_parent(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "child":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectAssociation_child(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectAssociationConnectionImplementors = []string{"ProjectAssociationConnection"}

func (ec *executionContext) _ProjectAssociationConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.ProjectAssociationConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectAssociationConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectAssociationConnection")
		case "edges":

			out.Values[i] = ec._ProjectAssociationConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._ProjectAssociationConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._ProjectAssociationConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectAssociationEdgeImplementors = []string{"ProjectAssociationEdge"}

func (ec *executionContext) _ProjectAssociationEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.ProjectAssociationEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectAssociationEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectAssociationEdge")
		case "node":

			out.Values[i] = ec._ProjectAssociationEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._ProjectAssociationEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectConnectionImplementors = []string{"ProjectConnection"}

func (ec *executionContext) _ProjectConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.ProjectConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectConnection")
		case "edges":

			out.Values[i] = ec._ProjectConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._ProjectConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._ProjectConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectContributorImplementors = []string{"ProjectContributor", "Node"}

func (ec *executionContext) _ProjectContributor(ctx context.Context, sel ast.SelectionSet, obj *ent.ProjectContributor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectContributorImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectContributor")
		case "id":

			out.Values[i] = ec._ProjectContributor_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "role":

			out.Values[i] = ec._ProjectContributor_role(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "project":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectContributor_project(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "user":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectContributor_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectContributorConnectionImplementors = []string{"ProjectContributorConnection"}

func (ec *executionContext) _ProjectContributorConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.ProjectContributorConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectContributorConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectContributorConnection")
		case "edges":

			out.Values[i] = ec._ProjectContributorConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._ProjectContributorConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._ProjectContributorConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectContributorEdgeImplementors = []string{"ProjectContributorEdge"}

func (ec *executionContext) _ProjectContributorEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.ProjectContributorEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectContributorEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectContributorEdge")
		case "node":

			out.Values[i] = ec._ProjectContributorEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._ProjectContributorEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectEdgeImplementors = []string{"ProjectEdge"}

func (ec *executionContext) _ProjectEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.ProjectEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectEdge")
		case "node":

			out.Values[i] = ec._ProjectEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._ProjectEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectTechnologyImplementors = []string{"ProjectTechnology", "Node"}

func (ec *executionContext) _ProjectTechnology(ctx context.Context, sel ast.SelectionSet, obj *ent.ProjectTechnology) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectTechnologyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectTechnology")
		case "id":

			out.Values[i] = ec._ProjectTechnology_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":

			out.Values[i] = ec._ProjectTechnology_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "project":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectTechnology_project(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "technology":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectTechnology_technology(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectTechnologyConnectionImplementors = []string{"ProjectTechnologyConnection"}

func (ec *executionContext) _ProjectTechnologyConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.ProjectTechnologyConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectTechnologyConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectTechnologyConnection")
		case "edges":

			out.Values[i] = ec._ProjectTechnologyConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._ProjectTechnologyConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._ProjectTechnologyConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectTechnologyEdgeImplementors = []string{"ProjectTechnologyEdge"}

func (ec *executionContext) _ProjectTechnologyEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.ProjectTechnologyEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectTechnologyEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectTechnologyEdge")
		case "node":

			out.Values[i] = ec._ProjectTechnologyEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._ProjectTechnologyEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "nodes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "discordAccounts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_discordAccounts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "discordBots":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_discordBots(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "githubAccounts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_githubAccounts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "githubOrganizations":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_githubOrganizations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "githubOrganizationMembers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_githubOrganizationMembers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "projects":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projects(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "projectAssociations":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projectAssociations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "projectContributors":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projectContributors(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "projectTechnologies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projectTechnologies(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "repositories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_repositories(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "repositoryTechnologies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_repositoryTechnologies(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "sites":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sites(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "technologies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_technologies(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "technologyAssociations":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_technologyAssociations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "availableAuthProviders":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_availableAuthProviders(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "currentUser":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_currentUser(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "developmentMode":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_developmentMode(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryImplementors = []string{"Repository", "Node"}

func (ec *executionContext) _Repository(ctx context.Context, sel ast.SelectionSet, obj *ent.Repository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Repository")
		case "id":

			out.Values[i] = ec._Repository_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Repository_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Repository_description(ctx, field, obj)

		case "project":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_project(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "githubAccount":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_githubAccount(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "githubOrganization":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_githubOrganization(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "discordBots":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_discordBots(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "sites":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_sites(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "technologies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_technologies(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryConnectionImplementors = []string{"RepositoryConnection"}

func (ec *executionContext) _RepositoryConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.RepositoryConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryConnection")
		case "edges":

			out.Values[i] = ec._RepositoryConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._RepositoryConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._RepositoryConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryEdgeImplementors = []string{"RepositoryEdge"}

func (ec *executionContext) _RepositoryEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.RepositoryEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryEdge")
		case "node":

			out.Values[i] = ec._RepositoryEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._RepositoryEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryTechnologyImplementors = []string{"RepositoryTechnology", "Node"}

func (ec *executionContext) _RepositoryTechnology(ctx context.Context, sel ast.SelectionSet, obj *ent.RepositoryTechnology) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryTechnologyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryTechnology")
		case "id":

			out.Values[i] = ec._RepositoryTechnology_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":

			out.Values[i] = ec._RepositoryTechnology_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "repository":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepositoryTechnology_repository(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "technology":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepositoryTechnology_technology(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryTechnologyConnectionImplementors = []string{"RepositoryTechnologyConnection"}

func (ec *executionContext) _RepositoryTechnologyConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.RepositoryTechnologyConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryTechnologyConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryTechnologyConnection")
		case "edges":

			out.Values[i] = ec._RepositoryTechnologyConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._RepositoryTechnologyConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._RepositoryTechnologyConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryTechnologyEdgeImplementors = []string{"RepositoryTechnologyEdge"}

func (ec *executionContext) _RepositoryTechnologyEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.RepositoryTechnologyEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryTechnologyEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryTechnologyEdge")
		case "node":

			out.Values[i] = ec._RepositoryTechnologyEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._RepositoryTechnologyEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var siteImplementors = []string{"Site", "Node"}

func (ec *executionContext) _Site(ctx context.Context, sel ast.SelectionSet, obj *ent.Site) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, siteImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Site")
		case "id":

			out.Values[i] = ec._Site_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "url":

			out.Values[i] = ec._Site_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "project":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Site_project(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "repository":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Site_repository(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var siteConnectionImplementors = []string{"SiteConnection"}

func (ec *executionContext) _SiteConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.SiteConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, siteConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SiteConnection")
		case "edges":

			out.Values[i] = ec._SiteConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._SiteConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._SiteConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var siteEdgeImplementors = []string{"SiteEdge"}

func (ec *executionContext) _SiteEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.SiteEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, siteEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SiteEdge")
		case "node":

			out.Values[i] = ec._SiteEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._SiteEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var technologyImplementors = []string{"Technology", "Node"}

func (ec *executionContext) _Technology(ctx context.Context, sel ast.SelectionSet, obj *ent.Technology) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, technologyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Technology")
		case "id":

			out.Values[i] = ec._Technology_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Technology_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Technology_description(ctx, field, obj)

		case "colour":

			out.Values[i] = ec._Technology_colour(ctx, field, obj)

		case "type":

			out.Values[i] = ec._Technology_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "parentTechnologies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Technology_parentTechnologies(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "childTechnologies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Technology_childTechnologies(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "projects":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Technology_projects(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "repositories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Technology_repositories(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var technologyAssociationImplementors = []string{"TechnologyAssociation", "Node"}

func (ec *executionContext) _TechnologyAssociation(ctx context.Context, sel ast.SelectionSet, obj *ent.TechnologyAssociation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, technologyAssociationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TechnologyAssociation")
		case "id":

			out.Values[i] = ec._TechnologyAssociation_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":

			out.Values[i] = ec._TechnologyAssociation_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "parent":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TechnologyAssociation_parent(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "child":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TechnologyAssociation_child(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var technologyAssociationConnectionImplementors = []string{"TechnologyAssociationConnection"}

func (ec *executionContext) _TechnologyAssociationConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.TechnologyAssociationConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, technologyAssociationConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TechnologyAssociationConnection")
		case "edges":

			out.Values[i] = ec._TechnologyAssociationConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._TechnologyAssociationConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._TechnologyAssociationConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var technologyAssociationEdgeImplementors = []string{"TechnologyAssociationEdge"}

func (ec *executionContext) _TechnologyAssociationEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.TechnologyAssociationEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, technologyAssociationEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TechnologyAssociationEdge")
		case "node":

			out.Values[i] = ec._TechnologyAssociationEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._TechnologyAssociationEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var technologyConnectionImplementors = []string{"TechnologyConnection"}

func (ec *executionContext) _TechnologyConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.TechnologyConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, technologyConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TechnologyConnection")
		case "edges":

			out.Values[i] = ec._TechnologyConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._TechnologyConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._TechnologyConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var technologyEdgeImplementors = []string{"TechnologyEdge"}

func (ec *executionContext) _TechnologyEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.TechnologyEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, technologyEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TechnologyEdge")
		case "node":

			out.Values[i] = ec._TechnologyEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._TechnologyEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User", "Node"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *ent.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":

			out.Values[i] = ec._User_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "username":

			out.Values[i] = ec._User_username(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "avatarURL":

			out.Values[i] = ec._User_avatarURL(ctx, field, obj)

		case "discordAccounts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_discordAccounts(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "githubAccounts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_githubAccounts(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "projectContributions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_projectContributions(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userConnectionImplementors = []string{"UserConnection"}

func (ec *executionContext) _UserConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.UserConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserConnection")
		case "edges":

			out.Values[i] = ec._UserConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._UserConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._UserConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userEdgeImplementors = []string{"UserEdge"}

func (ec *executionContext) _UserEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.UserEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserEdge")
		case "node":

			out.Values[i] = ec._UserEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._UserEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAuthProviderType2githubcomfogoshgrackdbgraphqlAuthProviderType(ctx context.Context, v interface{}) (AuthProviderType, error) {
	var res AuthProviderType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAuthProviderType2githubcomfogoshgrackdbgraphqlAuthProviderType(ctx context.Context, sel ast.SelectionSet, v AuthProviderType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNCreateDiscordAccountInput2githubcomfogoshgrackdbentCreateDiscordAccountInput(ctx context.Context, v interface{}) (ent.CreateDiscordAccountInput, error) {
	res, err := ec.unmarshalInputCreateDiscordAccountInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateDiscordBotInput2githubcomfogoshgrackdbentCreateDiscordBotInput(ctx context.Context, v interface{}) (ent.CreateDiscordBotInput, error) {
	res, err := ec.unmarshalInputCreateDiscordBotInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateGithubAccountInput2githubcomfogoshgrackdbentCreateGithubAccountInput(ctx context.Context, v interface{}) (ent.CreateGithubAccountInput, error) {
	res, err := ec.unmarshalInputCreateGithubAccountInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateGithubOrganizationInput2githubcomfogoshgrackdbentCreateGithubOrganizationInput(ctx context.Context, v interface{}) (ent.CreateGithubOrganizationInput, error) {
	res, err := ec.unmarshalInputCreateGithubOrganizationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateGithubOrganizationMemberInput2githubcomfogoshgrackdbentCreateGithubOrganizationMemberInput(ctx context.Context, v interface{}) (ent.CreateGithubOrganizationMemberInput, error) {
	res, err := ec.unmarshalInputCreateGithubOrganizationMemberInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateProjectAssociationInput2githubcomfogoshgrackdbentCreateProjectAssociationInput(ctx context.Context, v interface{}) (ent.CreateProjectAssociationInput, error) {
	res, err := ec.unmarshalInputCreateProjectAssociationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateProjectContributorInput2githubcomfogoshgrackdbentCreateProjectContributorInput(ctx context.Context, v interface{}) (ent.CreateProjectContributorInput, error) {
	res, err := ec.unmarshalInputCreateProjectContributorInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateProjectInput2githubcomfogoshgrackdbentCreateProjectInput(ctx context.Context, v interface{}) (ent.CreateProjectInput, error) {
	res, err := ec.unmarshalInputCreateProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateProjectTechnologyInput2githubcomfogoshgrackdbentCreateProjectTechnologyInput(ctx context.Context, v interface{}) (ent.CreateProjectTechnologyInput, error) {
	res, err := ec.unmarshalInputCreateProjectTechnologyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateRepositoryInput2githubcomfogoshgrackdbentCreateRepositoryInput(ctx context.Context, v interface{}) (ent.CreateRepositoryInput, error) {
	res, err := ec.unmarshalInputCreateRepositoryInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateRepositoryTechnologyInput2githubcomfogoshgrackdbentCreateRepositoryTechnologyInput(ctx context.Context, v interface{}) (ent.CreateRepositoryTechnologyInput, error) {
	res, err := ec.unmarshalInputCreateRepositoryTechnologyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateSiteInput2githubcomfogoshgrackdbentCreateSiteInput(ctx context.Context, v interface{}) (ent.CreateSiteInput, error) {
	res, err := ec.unmarshalInputCreateSiteInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateTechnologyAssociationInput2githubcomfogoshgrackdbentCreateTechnologyAssociationInput(ctx context.Context, v interface{}) (ent.CreateTechnologyAssociationInput, error) {
	res, err := ec.unmarshalInputCreateTechnologyAssociationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateTechnologyInput2githubcomfogoshgrackdbentCreateTechnologyInput(ctx context.Context, v interface{}) (ent.CreateTechnologyInput, error) {
	res, err := ec.unmarshalInputCreateTechnologyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateUserInput2githubcomfogoshgrackdbentCreateUserInput(ctx context.Context, v interface{}) (ent.CreateUserInput, error) {
	res, err := ec.unmarshalInputCreateUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursor2githubcomfogoshgrackdbentCursor(ctx context.Context, v interface{}) (ent.Cursor, error) {
	var res ent.Cursor
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2githubcomfogoshgrackdbentCursor(ctx context.Context, sel ast.SelectionSet, v ent.Cursor) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDiscordAccount2githubcomfogoshgrackdbentDiscordAccount(ctx context.Context, sel ast.SelectionSet, v ent.DiscordAccount) graphql.Marshaler {
	return ec._DiscordAccount(ctx, sel, &v)
}

func (ec *executionContext) marshalNDiscordAccount2githubcomfogoshgrackdbentDiscordAccount(ctx context.Context, sel ast.SelectionSet, v *ent.DiscordAccount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiscordAccount(ctx, sel, v)
}

func (ec *executionContext) marshalNDiscordAccountConnection2githubcomfogoshgrackdbentDiscordAccountConnection(ctx context.Context, sel ast.SelectionSet, v ent.DiscordAccountConnection) graphql.Marshaler {
	return ec._DiscordAccountConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNDiscordAccountConnection2githubcomfogoshgrackdbentDiscordAccountConnection(ctx context.Context, sel ast.SelectionSet, v *ent.DiscordAccountConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiscordAccountConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDiscordAccountOrderField2githubcomfogoshgrackdbentDiscordAccountOrderField(ctx context.Context, v interface{}) (*ent.DiscordAccountOrderField, error) {
	var res = new(ent.DiscordAccountOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDiscordAccountOrderField2githubcomfogoshgrackdbentDiscordAccountOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.DiscordAccountOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNDiscordAccountWhereInput2githubcomfogoshgrackdbentDiscordAccountWhereInput(ctx context.Context, v interface{}) (*ent.DiscordAccountWhereInput, error) {
	res, err := ec.unmarshalInputDiscordAccountWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDiscordBot2githubcomfogoshgrackdbentDiscordBot(ctx context.Context, sel ast.SelectionSet, v ent.DiscordBot) graphql.Marshaler {
	return ec._DiscordBot(ctx, sel, &v)
}

func (ec *executionContext) marshalNDiscordBot2githubcomfogoshgrackdbentDiscordBot(ctx context.Context, sel ast.SelectionSet, v *ent.DiscordBot) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiscordBot(ctx, sel, v)
}

func (ec *executionContext) marshalNDiscordBotConnection2githubcomfogoshgrackdbentDiscordBotConnection(ctx context.Context, sel ast.SelectionSet, v ent.DiscordBotConnection) graphql.Marshaler {
	return ec._DiscordBotConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNDiscordBotConnection2githubcomfogoshgrackdbentDiscordBotConnection(ctx context.Context, sel ast.SelectionSet, v *ent.DiscordBotConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiscordBotConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDiscordBotWhereInput2githubcomfogoshgrackdbentDiscordBotWhereInput(ctx context.Context, v interface{}) (*ent.DiscordBotWhereInput, error) {
	res, err := ec.unmarshalInputDiscordBotWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubAccount2githubcomfogoshgrackdbentGithubAccount(ctx context.Context, sel ast.SelectionSet, v ent.GithubAccount) graphql.Marshaler {
	return ec._GithubAccount(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubAccount2githubcomfogoshgrackdbentGithubAccount(ctx context.Context, sel ast.SelectionSet, v *ent.GithubAccount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubAccount(ctx, sel, v)
}

func (ec *executionContext) marshalNGithubAccountConnection2githubcomfogoshgrackdbentGithubAccountConnection(ctx context.Context, sel ast.SelectionSet, v ent.GithubAccountConnection) graphql.Marshaler {
	return ec._GithubAccountConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubAccountConnection2githubcomfogoshgrackdbentGithubAccountConnection(ctx context.Context, sel ast.SelectionSet, v *ent.GithubAccountConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubAccountConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGithubAccountOrderField2githubcomfogoshgrackdbentGithubAccountOrderField(ctx context.Context, v interface{}) (*ent.GithubAccountOrderField, error) {
	var res = new(ent.GithubAccountOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubAccountOrderField2githubcomfogoshgrackdbentGithubAccountOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.GithubAccountOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNGithubAccountWhereInput2githubcomfogoshgrackdbentGithubAccountWhereInput(ctx context.Context, v interface{}) (*ent.GithubAccountWhereInput, error) {
	res, err := ec.unmarshalInputGithubAccountWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubOrganization2githubcomfogoshgrackdbentGithubOrganization(ctx context.Context, sel ast.SelectionSet, v ent.GithubOrganization) graphql.Marshaler {
	return ec._GithubOrganization(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubOrganization2githubcomfogoshgrackdbentGithubOrganization(ctx context.Context, sel ast.SelectionSet, v *ent.GithubOrganization) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubOrganization(ctx, sel, v)
}

func (ec *executionContext) marshalNGithubOrganizationConnection2githubcomfogoshgrackdbentGithubOrganizationConnection(ctx context.Context, sel ast.SelectionSet, v ent.GithubOrganizationConnection) graphql.Marshaler {
	return ec._GithubOrganizationConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubOrganizationConnection2githubcomfogoshgrackdbentGithubOrganizationConnection(ctx context.Context, sel ast.SelectionSet, v *ent.GithubOrganizationConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubOrganizationConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNGithubOrganizationMember2githubcomfogoshgrackdbentGithubOrganizationMember(ctx context.Context, sel ast.SelectionSet, v ent.GithubOrganizationMember) graphql.Marshaler {
	return ec._GithubOrganizationMember(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubOrganizationMember2githubcomfogoshgrackdbentGithubOrganizationMember(ctx context.Context, sel ast.SelectionSet, v *ent.GithubOrganizationMember) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubOrganizationMember(ctx, sel, v)
}

func (ec *executionContext) marshalNGithubOrganizationMemberConnection2githubcomfogoshgrackdbentGithubOrganizationMemberConnection(ctx context.Context, sel ast.SelectionSet, v ent.GithubOrganizationMemberConnection) graphql.Marshaler {
	return ec._GithubOrganizationMemberConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubOrganizationMemberConnection2githubcomfogoshgrackdbentGithubOrganizationMemberConnection(ctx context.Context, sel ast.SelectionSet, v *ent.GithubOrganizationMemberConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubOrganizationMemberConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGithubOrganizationMemberOrderField2githubcomfogoshgrackdbentGithubOrganizationMemberOrderField(ctx context.Context, v interface{}) (*ent.GithubOrganizationMemberOrderField, error) {
	var res = new(ent.GithubOrganizationMemberOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubOrganizationMemberOrderField2githubcomfogoshgrackdbentGithubOrganizationMemberOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.GithubOrganizationMemberOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx context.Context, v interface{}) (githuborganizationmember.Role, error) {
	var res githuborganizationmember.Role
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx context.Context, sel ast.SelectionSet, v githuborganizationmember.Role) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx context.Context, v interface{}) (*githuborganizationmember.Role, error) {
	var res = new(githuborganizationmember.Role)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx context.Context, sel ast.SelectionSet, v *githuborganizationmember.Role) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNGithubOrganizationMemberWhereInput2githubcomfogoshgrackdbentGithubOrganizationMemberWhereInput(ctx context.Context, v interface{}) (*ent.GithubOrganizationMemberWhereInput, error) {
	res, err := ec.unmarshalInputGithubOrganizationMemberWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNGithubOrganizationOrderField2githubcomfogoshgrackdbentGithubOrganizationOrderField(ctx context.Context, v interface{}) (*ent.GithubOrganizationOrderField, error) {
	var res = new(ent.GithubOrganizationOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubOrganizationOrderField2githubcomfogoshgrackdbentGithubOrganizationOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.GithubOrganizationOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNGithubOrganizationWhereInput2githubcomfogoshgrackdbentGithubOrganizationWhereInput(ctx context.Context, v interface{}) (*ent.GithubOrganizationWhereInput, error) {
	res, err := ec.unmarshalInputGithubOrganizationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalIntID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalIntID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNNode2githubcomfogoshgrackdbentNoder(ctx context.Context, sel ast.SelectionSet, v []ent.Noder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONode2githubcomfogoshgrackdbentNoder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx context.Context, v interface{}) (ent.OrderDirection, error) {
	var res ent.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2githubcomfogoshgrackdbentOrderDirection(ctx context.Context, sel ast.SelectionSet, v ent.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2githubcomfogoshgrackdbentPageInfo(ctx context.Context, sel ast.SelectionSet, v ent.PageInfo) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNProject2githubcomfogoshgrackdbentProject(ctx context.Context, sel ast.SelectionSet, v ent.Project) graphql.Marshaler {
	return ec._Project(ctx, sel, &v)
}

func (ec *executionContext) marshalNProject2githubcomfogoshgrackdbentProject(ctx context.Context, sel ast.SelectionSet, v *ent.Project) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Project(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectAssociation2githubcomfogoshgrackdbentProjectAssociation(ctx context.Context, sel ast.SelectionSet, v ent.ProjectAssociation) graphql.Marshaler {
	return ec._ProjectAssociation(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectAssociation2githubcomfogoshgrackdbentProjectAssociation(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectAssociation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectAssociation(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectAssociationConnection2githubcomfogoshgrackdbentProjectAssociationConnection(ctx context.Context, sel ast.SelectionSet, v ent.ProjectAssociationConnection) graphql.Marshaler {
	return ec._ProjectAssociationConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectAssociationConnection2githubcomfogoshgrackdbentProjectAssociationConnection(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectAssociationConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectAssociationConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectAssociationOrderField2githubcomfogoshgrackdbentProjectAssociationOrderField(ctx context.Context, v interface{}) (*ent.ProjectAssociationOrderField, error) {
	var res = new(ent.ProjectAssociationOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectAssociationOrderField2githubcomfogoshgrackdbentProjectAssociationOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectAssociationOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNProjectAssociationType2githubcomfogoshgrackdbentprojectassociationType(ctx context.Context, v interface{}) (projectassociation.Type, error) {
	var res projectassociation.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectAssociationType2githubcomfogoshgrackdbentprojectassociationType(ctx context.Context, sel ast.SelectionSet, v projectassociation.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNProjectAssociationWhereInput2githubcomfogoshgrackdbentProjectAssociationWhereInput(ctx context.Context, v interface{}) (*ent.ProjectAssociationWhereInput, error) {
	res, err := ec.unmarshalInputProjectAssociationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectConnection2githubcomfogoshgrackdbentProjectConnection(ctx context.Context, sel ast.SelectionSet, v ent.ProjectConnection) graphql.Marshaler {
	return ec._ProjectConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectConnection2githubcomfogoshgrackdbentProjectConnection(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectContributor2githubcomfogoshgrackdbentProjectContributor(ctx context.Context, sel ast.SelectionSet, v ent.ProjectContributor) graphql.Marshaler {
	return ec._ProjectContributor(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectContributor2githubcomfogoshgrackdbentProjectContributor(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectContributor) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectContributor(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectContributorConnection2githubcomfogoshgrackdbentProjectContributorConnection(ctx context.Context, sel ast.SelectionSet, v ent.ProjectContributorConnection) graphql.Marshaler {
	return ec._ProjectContributorConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectContributorConnection2githubcomfogoshgrackdbentProjectContributorConnection(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectContributorConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectContributorConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectContributorOrderField2githubcomfogoshgrackdbentProjectContributorOrderField(ctx context.Context, v interface{}) (*ent.ProjectContributorOrderField, error) {
	var res = new(ent.ProjectContributorOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectContributorOrderField2githubcomfogoshgrackdbentProjectContributorOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectContributorOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNProjectContributorRole2githubcomfogoshgrackdbentprojectcontributorRole(ctx context.Context, v interface{}) (projectcontributor.Role, error) {
	var res projectcontributor.Role
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectContributorRole2githubcomfogoshgrackdbentprojectcontributorRole(ctx context.Context, sel ast.SelectionSet, v projectcontributor.Role) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNProjectContributorWhereInput2githubcomfogoshgrackdbentProjectContributorWhereInput(ctx context.Context, v interface{}) (*ent.ProjectContributorWhereInput, error) {
	res, err := ec.unmarshalInputProjectContributorWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNProjectOrderField2githubcomfogoshgrackdbentProjectOrderField(ctx context.Context, v interface{}) (*ent.ProjectOrderField, error) {
	var res = new(ent.ProjectOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectOrderField2githubcomfogoshgrackdbentProjectOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNProjectTechnology2githubcomfogoshgrackdbentProjectTechnology(ctx context.Context, sel ast.SelectionSet, v ent.ProjectTechnology) graphql.Marshaler {
	return ec._ProjectTechnology(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectTechnology2githubcomfogoshgrackdbentProjectTechnology(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectTechnology) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectTechnology(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectTechnologyConnection2githubcomfogoshgrackdbentProjectTechnologyConnection(ctx context.Context, sel ast.SelectionSet, v ent.ProjectTechnologyConnection) graphql.Marshaler {
	return ec._ProjectTechnologyConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectTechnologyConnection2githubcomfogoshgrackdbentProjectTechnologyConnection(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectTechnologyConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectTechnologyConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectTechnologyOrderField2githubcomfogoshgrackdbentProjectTechnologyOrderField(ctx context.Context, v interface{}) (*ent.ProjectTechnologyOrderField, error) {
	var res = new(ent.ProjectTechnologyOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectTechnologyOrderField2githubcomfogoshgrackdbentProjectTechnologyOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectTechnologyOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNProjectTechnologyType2githubcomfogoshgrackdbentprojecttechnologyType(ctx context.Context, v interface{}) (projecttechnology.Type, error) {
	var res projecttechnology.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectTechnologyType2githubcomfogoshgrackdbentprojecttechnologyType(ctx context.Context, sel ast.SelectionSet, v projecttechnology.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNProjectTechnologyWhereInput2githubcomfogoshgrackdbentProjectTechnologyWhereInput(ctx context.Context, v interface{}) (*ent.ProjectTechnologyWhereInput, error) {
	res, err := ec.unmarshalInputProjectTechnologyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNProjectWhereInput2githubcomfogoshgrackdbentProjectWhereInput(ctx context.Context, v interface{}) (*ent.ProjectWhereInput, error) {
	res, err := ec.unmarshalInputProjectWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRepository2githubcomfogoshgrackdbentRepository(ctx context.Context, sel ast.SelectionSet, v ent.Repository) graphql.Marshaler {
	return ec._Repository(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepository2githubcomfogoshgrackdbentRepository(ctx context.Context, sel ast.SelectionSet, v *ent.Repository) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) marshalNRepositoryConnection2githubcomfogoshgrackdbentRepositoryConnection(ctx context.Context, sel ast.SelectionSet, v ent.RepositoryConnection) graphql.Marshaler {
	return ec._RepositoryConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepositoryConnection2githubcomfogoshgrackdbentRepositoryConnection(ctx context.Context, sel ast.SelectionSet, v *ent.RepositoryConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepositoryConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRepositoryOrderField2githubcomfogoshgrackdbentRepositoryOrderField(ctx context.Context, v interface{}) (*ent.RepositoryOrderField, error) {
	var res = new(ent.RepositoryOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRepositoryOrderField2githubcomfogoshgrackdbentRepositoryOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.RepositoryOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNRepositoryTechnology2githubcomfogoshgrackdbentRepositoryTechnology(ctx context.Context, sel ast.SelectionSet, v ent.RepositoryTechnology) graphql.Marshaler {
	return ec._RepositoryTechnology(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepositoryTechnology2githubcomfogoshgrackdbentRepositoryTechnology(ctx context.Context, sel ast.SelectionSet, v *ent.RepositoryTechnology) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepositoryTechnology(ctx, sel, v)
}

func (ec *executionContext) marshalNRepositoryTechnologyConnection2githubcomfogoshgrackdbentRepositoryTechnologyConnection(ctx context.Context, sel ast.SelectionSet, v ent.RepositoryTechnologyConnection) graphql.Marshaler {
	return ec._RepositoryTechnologyConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepositoryTechnologyConnection2githubcomfogoshgrackdbentRepositoryTechnologyConnection(ctx context.Context, sel ast.SelectionSet, v *ent.RepositoryTechnologyConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepositoryTechnologyConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRepositoryTechnologyOrderField2githubcomfogoshgrackdbentRepositoryTechnologyOrderField(ctx context.Context, v interface{}) (*ent.RepositoryTechnologyOrderField, error) {
	var res = new(ent.RepositoryTechnologyOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRepositoryTechnologyOrderField2githubcomfogoshgrackdbentRepositoryTechnologyOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.RepositoryTechnologyOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNRepositoryTechnologyType2githubcomfogoshgrackdbentrepositorytechnologyType(ctx context.Context, v interface{}) (repositorytechnology.Type, error) {
	var res repositorytechnology.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRepositoryTechnologyType2githubcomfogoshgrackdbentrepositorytechnologyType(ctx context.Context, sel ast.SelectionSet, v repositorytechnology.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNRepositoryTechnologyWhereInput2githubcomfogoshgrackdbentRepositoryTechnologyWhereInput(ctx context.Context, v interface{}) (*ent.RepositoryTechnologyWhereInput, error) {
	res, err := ec.unmarshalInputRepositoryTechnologyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRepositoryWhereInput2githubcomfogoshgrackdbentRepositoryWhereInput(ctx context.Context, v interface{}) (*ent.RepositoryWhereInput, error) {
	res, err := ec.unmarshalInputRepositoryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSite2githubcomfogoshgrackdbentSite(ctx context.Context, sel ast.SelectionSet, v ent.Site) graphql.Marshaler {
	return ec._Site(ctx, sel, &v)
}

func (ec *executionContext) marshalNSite2githubcomfogoshgrackdbentSite(ctx context.Context, sel ast.SelectionSet, v *ent.Site) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Site(ctx, sel, v)
}

func (ec *executionContext) marshalNSiteConnection2githubcomfogoshgrackdbentSiteConnection(ctx context.Context, sel ast.SelectionSet, v ent.SiteConnection) graphql.Marshaler {
	return ec._SiteConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSiteConnection2githubcomfogoshgrackdbentSiteConnection(ctx context.Context, sel ast.SelectionSet, v *ent.SiteConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SiteConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSiteOrderField2githubcomfogoshgrackdbentSiteOrderField(ctx context.Context, v interface{}) (*ent.SiteOrderField, error) {
	var res = new(ent.SiteOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSiteOrderField2githubcomfogoshgrackdbentSiteOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.SiteOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNSiteWhereInput2githubcomfogoshgrackdbentSiteWhereInput(ctx context.Context, v interface{}) (*ent.SiteWhereInput, error) {
	res, err := ec.unmarshalInputSiteWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTechnology2githubcomfogoshgrackdbentTechnology(ctx context.Context, sel ast.SelectionSet, v ent.Technology) graphql.Marshaler {
	return ec._Technology(ctx, sel, &v)
}

func (ec *executionContext) marshalNTechnology2githubcomfogoshgrackdbentTechnology(ctx context.Context, sel ast.SelectionSet, v *ent.Technology) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Technology(ctx, sel, v)
}

func (ec *executionContext) marshalNTechnologyAssociation2githubcomfogoshgrackdbentTechnologyAssociation(ctx context.Context, sel ast.SelectionSet, v ent.TechnologyAssociation) graphql.Marshaler {
	return ec._TechnologyAssociation(ctx, sel, &v)
}

func (ec *executionContext) marshalNTechnologyAssociation2githubcomfogoshgrackdbentTechnologyAssociation(ctx context.Context, sel ast.SelectionSet, v *ent.TechnologyAssociation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TechnologyAssociation(ctx, sel, v)
}

func (ec *executionContext) marshalNTechnologyAssociationConnection2githubcomfogoshgrackdbentTechnologyAssociationConnection(ctx context.Context, sel ast.SelectionSet, v ent.TechnologyAssociationConnection) graphql.Marshaler {
	return ec._TechnologyAssociationConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNTechnologyAssociationConnection2githubcomfogoshgrackdbentTechnologyAssociationConnection(ctx context.Context, sel ast.SelectionSet, v *ent.TechnologyAssociationConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TechnologyAssociationConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTechnologyAssociationOrderField2githubcomfogoshgrackdbentTechnologyAssociationOrderField(ctx context.Context, v interface{}) (*ent.TechnologyAssociationOrderField, error) {
	var res = new(ent.TechnologyAssociationOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTechnologyAssociationOrderField2githubcomfogoshgrackdbentTechnologyAssociationOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.TechnologyAssociationOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNTechnologyAssociationType2githubcomfogoshgrackdbenttechnologyassociationType(ctx context.Context, v interface{}) (technologyassociation.Type, error) {
	var res technologyassociation.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTechnologyAssociationType2githubcomfogoshgrackdbenttechnologyassociationType(ctx context.Context, sel ast.SelectionSet, v technologyassociation.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTechnologyAssociationWhereInput2githubcomfogoshgrackdbentTechnologyAssociationWhereInput(ctx context.Context, v interface{}) (*ent.TechnologyAssociationWhereInput, error) {
	res, err := ec.unmarshalInputTechnologyAssociationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTechnologyConnection2githubcomfogoshgrackdbentTechnologyConnection(ctx context.Context, sel ast.SelectionSet, v ent.TechnologyConnection) graphql.Marshaler {
	return ec._TechnologyConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNTechnologyConnection2githubcomfogoshgrackdbentTechnologyConnection(ctx context.Context, sel ast.SelectionSet, v *ent.TechnologyConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TechnologyConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTechnologyOrderField2githubcomfogoshgrackdbentTechnologyOrderField(ctx context.Context, v interface{}) (*ent.TechnologyOrderField, error) {
	var res = new(ent.TechnologyOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTechnologyOrderField2githubcomfogoshgrackdbentTechnologyOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.TechnologyOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNTechnologyType2githubcomfogoshgrackdbenttechnologyType(ctx context.Context, v interface{}) (technology.Type, error) {
	var res technology.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTechnologyType2githubcomfogoshgrackdbenttechnologyType(ctx context.Context, sel ast.SelectionSet, v technology.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTechnologyWhereInput2githubcomfogoshgrackdbentTechnologyWhereInput(ctx context.Context, v interface{}) (*ent.TechnologyWhereInput, error) {
	res, err := ec.unmarshalInputTechnologyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUpdateDiscordAccountInput2githubcomfogoshgrackdbentUpdateDiscordAccountInput(ctx context.Context, v interface{}) (ent.UpdateDiscordAccountInput, error) {
	res, err := ec.unmarshalInputUpdateDiscordAccountInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateDiscordBotInput2githubcomfogoshgrackdbentUpdateDiscordBotInput(ctx context.Context, v interface{}) (ent.UpdateDiscordBotInput, error) {
	res, err := ec.unmarshalInputUpdateDiscordBotInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateGithubAccountInput2githubcomfogoshgrackdbentUpdateGithubAccountInput(ctx context.Context, v interface{}) (ent.UpdateGithubAccountInput, error) {
	res, err := ec.unmarshalInputUpdateGithubAccountInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateGithubOrganizationInput2githubcomfogoshgrackdbentUpdateGithubOrganizationInput(ctx context.Context, v interface{}) (ent.UpdateGithubOrganizationInput, error) {
	res, err := ec.unmarshalInputUpdateGithubOrganizationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateGithubOrganizationMemberInput2githubcomfogoshgrackdbentUpdateGithubOrganizationMemberInput(ctx context.Context, v interface{}) (ent.UpdateGithubOrganizationMemberInput, error) {
	res, err := ec.unmarshalInputUpdateGithubOrganizationMemberInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateProjectAssociationInput2githubcomfogoshgrackdbentUpdateProjectAssociationInput(ctx context.Context, v interface{}) (ent.UpdateProjectAssociationInput, error) {
	res, err := ec.unmarshalInputUpdateProjectAssociationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateProjectContributorInput2githubcomfogoshgrackdbentUpdateProjectContributorInput(ctx context.Context, v interface{}) (ent.UpdateProjectContributorInput, error) {
	res, err := ec.unmarshalInputUpdateProjectContributorInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateProjectInput2githubcomfogoshgrackdbentUpdateProjectInput(ctx context.Context, v interface{}) (ent.UpdateProjectInput, error) {
	res, err := ec.unmarshalInputUpdateProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateProjectTechnologyInput2githubcomfogoshgrackdbentUpdateProjectTechnologyInput(ctx context.Context, v interface{}) (ent.UpdateProjectTechnologyInput, error) {
	res, err := ec.unmarshalInputUpdateProjectTechnologyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateRepositoryInput2githubcomfogoshgrackdbentUpdateRepositoryInput(ctx context.Context, v interface{}) (ent.UpdateRepositoryInput, error) {
	res, err := ec.unmarshalInputUpdateRepositoryInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateRepositoryTechnologyInput2githubcomfogoshgrackdbentUpdateRepositoryTechnologyInput(ctx context.Context, v interface{}) (ent.UpdateRepositoryTechnologyInput, error) {
	res, err := ec.unmarshalInputUpdateRepositoryTechnologyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSiteInput2githubcomfogoshgrackdbentUpdateSiteInput(ctx context.Context, v interface{}) (ent.UpdateSiteInput, error) {
	res, err := ec.unmarshalInputUpdateSiteInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateTechnologyAssociationInput2githubcomfogoshgrackdbentUpdateTechnologyAssociationInput(ctx context.Context, v interface{}) (ent.UpdateTechnologyAssociationInput, error) {
	res, err := ec.unmarshalInputUpdateTechnologyAssociationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateTechnologyInput2githubcomfogoshgrackdbentUpdateTechnologyInput(ctx context.Context, v interface{}) (ent.UpdateTechnologyInput, error) {
	res, err := ec.unmarshalInputUpdateTechnologyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUserInput2githubcomfogoshgrackdbentUpdateUserInput(ctx context.Context, v interface{}) (ent.UpdateUserInput, error) {
	res, err := ec.unmarshalInputUpdateUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2githubcomfogoshgrackdbentUser(ctx context.Context, sel ast.SelectionSet, v ent.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2githubcomfogoshgrackdbentUser(ctx context.Context, sel ast.SelectionSet, v *ent.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserConnection2githubcomfogoshgrackdbentUserConnection(ctx context.Context, sel ast.SelectionSet, v ent.UserConnection) graphql.Marshaler {
	return ec._UserConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserConnection2githubcomfogoshgrackdbentUserConnection(ctx context.Context, sel ast.SelectionSet, v *ent.UserConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserOrderField2githubcomfogoshgrackdbentUserOrderField(ctx context.Context, v interface{}) (*ent.UserOrderField, error) {
	var res = new(ent.UserOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserOrderField2githubcomfogoshgrackdbentUserOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.UserOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNUserWhereInput2githubcomfogoshgrackdbentUserWhereInput(ctx context.Context, v interface{}) (*ent.UserWhereInput, error) {
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAuthProvider2githubcomfogoshgrackdbgraphqlAuthProvider(ctx context.Context, sel ast.SelectionSet, v []*AuthProvider) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAuthProvider2githubcomfogoshgrackdbgraphqlAuthProvider(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAuthProvider2githubcomfogoshgrackdbgraphqlAuthProvider(ctx context.Context, sel ast.SelectionSet, v *AuthProvider) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AuthProvider(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOCursor2githubcomfogoshgrackdbentCursor(ctx context.Context, v interface{}) (*ent.Cursor, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ent.Cursor)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2githubcomfogoshgrackdbentCursor(ctx context.Context, sel ast.SelectionSet, v *ent.Cursor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalODiscordAccount2githubcomfogoshgrackdbentDiscordAccount(ctx context.Context, sel ast.SelectionSet, v []*ent.DiscordAccount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDiscordAccount2githubcomfogoshgrackdbentDiscordAccount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODiscordAccount2githubcomfogoshgrackdbentDiscordAccount(ctx context.Context, sel ast.SelectionSet, v *ent.DiscordAccount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DiscordAccount(ctx, sel, v)
}

func (ec *executionContext) marshalODiscordAccountEdge2githubcomfogoshgrackdbentDiscordAccountEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.DiscordAccountEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODiscordAccountEdge2githubcomfogoshgrackdbentDiscordAccountEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalODiscordAccountEdge2githubcomfogoshgrackdbentDiscordAccountEdge(ctx context.Context, sel ast.SelectionSet, v *ent.DiscordAccountEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DiscordAccountEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalODiscordAccountOrder2githubcomfogoshgrackdbentDiscordAccountOrder(ctx context.Context, v interface{}) (*ent.DiscordAccountOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDiscordAccountOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODiscordAccountWhereInput2githubcomfogoshgrackdbentDiscordAccountWhereInput(ctx context.Context, v interface{}) ([]*ent.DiscordAccountWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.DiscordAccountWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDiscordAccountWhereInput2githubcomfogoshgrackdbentDiscordAccountWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalODiscordAccountWhereInput2githubcomfogoshgrackdbentDiscordAccountWhereInput(ctx context.Context, v interface{}) (*ent.DiscordAccountWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDiscordAccountWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODiscordBot2githubcomfogoshgrackdbentDiscordBot(ctx context.Context, sel ast.SelectionSet, v []*ent.DiscordBot) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDiscordBot2githubcomfogoshgrackdbentDiscordBot(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODiscordBot2githubcomfogoshgrackdbentDiscordBot(ctx context.Context, sel ast.SelectionSet, v *ent.DiscordBot) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DiscordBot(ctx, sel, v)
}

func (ec *executionContext) marshalODiscordBotEdge2githubcomfogoshgrackdbentDiscordBotEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.DiscordBotEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODiscordBotEdge2githubcomfogoshgrackdbentDiscordBotEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalODiscordBotEdge2githubcomfogoshgrackdbentDiscordBotEdge(ctx context.Context, sel ast.SelectionSet, v *ent.DiscordBotEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DiscordBotEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalODiscordBotWhereInput2githubcomfogoshgrackdbentDiscordBotWhereInput(ctx context.Context, v interface{}) ([]*ent.DiscordBotWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.DiscordBotWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDiscordBotWhereInput2githubcomfogoshgrackdbentDiscordBotWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalODiscordBotWhereInput2githubcomfogoshgrackdbentDiscordBotWhereInput(ctx context.Context, v interface{}) (*ent.DiscordBotWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDiscordBotWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGithubAccount2githubcomfogoshgrackdbentGithubAccount(ctx context.Context, sel ast.SelectionSet, v []*ent.GithubAccount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGithubAccount2githubcomfogoshgrackdbentGithubAccount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGithubAccount2githubcomfogoshgrackdbentGithubAccount(ctx context.Context, sel ast.SelectionSet, v *ent.GithubAccount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubAccount(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubAccountEdge2githubcomfogoshgrackdbentGithubAccountEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.GithubAccountEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGithubAccountEdge2githubcomfogoshgrackdbentGithubAccountEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGithubAccountEdge2githubcomfogoshgrackdbentGithubAccountEdge(ctx context.Context, sel ast.SelectionSet, v *ent.GithubAccountEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubAccountEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGithubAccountOrder2githubcomfogoshgrackdbentGithubAccountOrder(ctx context.Context, v interface{}) (*ent.GithubAccountOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubAccountOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGithubAccountWhereInput2githubcomfogoshgrackdbentGithubAccountWhereInput(ctx context.Context, v interface{}) ([]*ent.GithubAccountWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GithubAccountWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGithubAccountWhereInput2githubcomfogoshgrackdbentGithubAccountWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGithubAccountWhereInput2githubcomfogoshgrackdbentGithubAccountWhereInput(ctx context.Context, v interface{}) (*ent.GithubAccountWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubAccountWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGithubOrganization2githubcomfogoshgrackdbentGithubOrganization(ctx context.Context, sel ast.SelectionSet, v *ent.GithubOrganization) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubOrganization(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubOrganizationEdge2githubcomfogoshgrackdbentGithubOrganizationEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.GithubOrganizationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGithubOrganizationEdge2githubcomfogoshgrackdbentGithubOrganizationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGithubOrganizationEdge2githubcomfogoshgrackdbentGithubOrganizationEdge(ctx context.Context, sel ast.SelectionSet, v *ent.GithubOrganizationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubOrganizationEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubOrganizationMember2githubcomfogoshgrackdbentGithubOrganizationMember(ctx context.Context, sel ast.SelectionSet, v []*ent.GithubOrganizationMember) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGithubOrganizationMember2githubcomfogoshgrackdbentGithubOrganizationMember(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGithubOrganizationMember2githubcomfogoshgrackdbentGithubOrganizationMember(ctx context.Context, sel ast.SelectionSet, v *ent.GithubOrganizationMember) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubOrganizationMember(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubOrganizationMemberEdge2githubcomfogoshgrackdbentGithubOrganizationMemberEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.GithubOrganizationMemberEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGithubOrganizationMemberEdge2githubcomfogoshgrackdbentGithubOrganizationMemberEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGithubOrganizationMemberEdge2githubcomfogoshgrackdbentGithubOrganizationMemberEdge(ctx context.Context, sel ast.SelectionSet, v *ent.GithubOrganizationMemberEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubOrganizationMemberEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGithubOrganizationMemberOrder2githubcomfogoshgrackdbentGithubOrganizationMemberOrder(ctx context.Context, v interface{}) (*ent.GithubOrganizationMemberOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubOrganizationMemberOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx context.Context, v interface{}) ([]githuborganizationmember.Role, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]githuborganizationmember.Role, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx context.Context, sel ast.SelectionSet, v []githuborganizationmember.Role) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx context.Context, v interface{}) (*githuborganizationmember.Role, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(githuborganizationmember.Role)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGithubOrganizationMemberRole2githubcomfogoshgrackdbentgithuborganizationmemberRole(ctx context.Context, sel ast.SelectionSet, v *githuborganizationmember.Role) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOGithubOrganizationMemberWhereInput2githubcomfogoshgrackdbentGithubOrganizationMemberWhereInput(ctx context.Context, v interface{}) ([]*ent.GithubOrganizationMemberWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GithubOrganizationMemberWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGithubOrganizationMemberWhereInput2githubcomfogoshgrackdbentGithubOrganizationMemberWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGithubOrganizationMemberWhereInput2githubcomfogoshgrackdbentGithubOrganizationMemberWhereInput(ctx context.Context, v interface{}) (*ent.GithubOrganizationMemberWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubOrganizationMemberWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGithubOrganizationOrder2githubcomfogoshgrackdbentGithubOrganizationOrder(ctx context.Context, v interface{}) (*ent.GithubOrganizationOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubOrganizationOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGithubOrganizationWhereInput2githubcomfogoshgrackdbentGithubOrganizationWhereInput(ctx context.Context, v interface{}) ([]*ent.GithubOrganizationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GithubOrganizationWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGithubOrganizationWhereInput2githubcomfogoshgrackdbentGithubOrganizationWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGithubOrganizationWhereInput2githubcomfogoshgrackdbentGithubOrganizationWhereInput(ctx context.Context, v interface{}) (*ent.GithubOrganizationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubOrganizationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOID2int(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalIntID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalIntID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalONode2githubcomfogoshgrackdbentNoder(ctx context.Context, sel ast.SelectionSet, v ent.Noder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalOProject2githubcomfogoshgrackdbentProject(ctx context.Context, sel ast.SelectionSet, v *ent.Project) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Project(ctx, sel, v)
}

func (ec *executionContext) marshalOProjectAssociation2githubcomfogoshgrackdbentProjectAssociation(ctx context.Context, sel ast.SelectionSet, v []*ent.ProjectAssociation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectAssociation2githubcomfogoshgrackdbentProjectAssociation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOProjectAssociation2githubcomfogoshgrackdbentProjectAssociation(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectAssociation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProjectAssociation(ctx, sel, v)
}

func (ec *executionContext) marshalOProjectAssociationEdge2githubcomfogoshgrackdbentProjectAssociationEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.ProjectAssociationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProjectAssociationEdge2githubcomfogoshgrackdbentProjectAssociationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOProjectAssociationEdge2githubcomfogoshgrackdbentProjectAssociationEdge(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectAssociationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProjectAssociationEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProjectAssociationOrder2githubcomfogoshgrackdbentProjectAssociationOrder(ctx context.Context, v interface{}) (*ent.ProjectAssociationOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProjectAssociationOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProjectAssociationType2githubcomfogoshgrackdbentprojectassociationType(ctx context.Context, v interface{}) ([]projectassociation.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]projectassociation.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProjectAssociationType2githubcomfogoshgrackdbentprojectassociationType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOProjectAssociationType2githubcomfogoshgrackdbentprojectassociationType(ctx context.Context, sel ast.SelectionSet, v []projectassociation.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectAssociationType2githubcomfogoshgrackdbentprojectassociationType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOProjectAssociationType2githubcomfogoshgrackdbentprojectassociationType(ctx context.Context, v interface{}) (*projectassociation.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(projectassociation.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectAssociationType2githubcomfogoshgrackdbentprojectassociationType(ctx context.Context, sel ast.SelectionSet, v *projectassociation.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOProjectAssociationWhereInput2githubcomfogoshgrackdbentProjectAssociationWhereInput(ctx context.Context, v interface{}) ([]*ent.ProjectAssociationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ProjectAssociationWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProjectAssociationWhereInput2githubcomfogoshgrackdbentProjectAssociationWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOProjectAssociationWhereInput2githubcomfogoshgrackdbentProjectAssociationWhereInput(ctx context.Context, v interface{}) (*ent.ProjectAssociationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProjectAssociationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectContributor2githubcomfogoshgrackdbentProjectContributor(ctx context.Context, sel ast.SelectionSet, v []*ent.ProjectContributor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectContributor2githubcomfogoshgrackdbentProjectContributor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOProjectContributor2githubcomfogoshgrackdbentProjectContributor(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectContributor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProjectContributor(ctx, sel, v)
}

func (ec *executionContext) marshalOProjectContributorEdge2githubcomfogoshgrackdbentProjectContributorEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.ProjectContributorEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProjectContributorEdge2githubcomfogoshgrackdbentProjectContributorEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOProjectContributorEdge2githubcomfogoshgrackdbentProjectContributorEdge(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectContributorEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProjectContributorEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProjectContributorOrder2githubcomfogoshgrackdbentProjectContributorOrder(ctx context.Context, v interface{}) (*ent.ProjectContributorOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProjectContributorOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProjectContributorRole2githubcomfogoshgrackdbentprojectcontributorRole(ctx context.Context, v interface{}) ([]projectcontributor.Role, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]projectcontributor.Role, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProjectContributorRole2githubcomfogoshgrackdbentprojectcontributorRole(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOProjectContributorRole2githubcomfogoshgrackdbentprojectcontributorRole(ctx context.Context, sel ast.SelectionSet, v []projectcontributor.Role) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectContributorRole2githubcomfogoshgrackdbentprojectcontributorRole(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOProjectContributorRole2githubcomfogoshgrackdbentprojectcontributorRole(ctx context.Context, v interface{}) (*projectcontributor.Role, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(projectcontributor.Role)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectContributorRole2githubcomfogoshgrackdbentprojectcontributorRole(ctx context.Context, sel ast.SelectionSet, v *projectcontributor.Role) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOProjectContributorWhereInput2githubcomfogoshgrackdbentProjectContributorWhereInput(ctx context.Context, v interface{}) ([]*ent.ProjectContributorWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ProjectContributorWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProjectContributorWhereInput2githubcomfogoshgrackdbentProjectContributorWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOProjectContributorWhereInput2githubcomfogoshgrackdbentProjectContributorWhereInput(ctx context.Context, v interface{}) (*ent.ProjectContributorWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProjectContributorWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectEdge2githubcomfogoshgrackdbentProjectEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.ProjectEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProjectEdge2githubcomfogoshgrackdbentProjectEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOProjectEdge2githubcomfogoshgrackdbentProjectEdge(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProjectEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProjectOrder2githubcomfogoshgrackdbentProjectOrder(ctx context.Context, v interface{}) (*ent.ProjectOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProjectOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectTechnology2githubcomfogoshgrackdbentProjectTechnology(ctx context.Context, sel ast.SelectionSet, v []*ent.ProjectTechnology) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectTechnology2githubcomfogoshgrackdbentProjectTechnology(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOProjectTechnology2githubcomfogoshgrackdbentProjectTechnology(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectTechnology) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProjectTechnology(ctx, sel, v)
}

func (ec *executionContext) marshalOProjectTechnologyEdge2githubcomfogoshgrackdbentProjectTechnologyEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.ProjectTechnologyEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProjectTechnologyEdge2githubcomfogoshgrackdbentProjectTechnologyEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOProjectTechnologyEdge2githubcomfogoshgrackdbentProjectTechnologyEdge(ctx context.Context, sel ast.SelectionSet, v *ent.ProjectTechnologyEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProjectTechnologyEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProjectTechnologyOrder2githubcomfogoshgrackdbentProjectTechnologyOrder(ctx context.Context, v interface{}) (*ent.ProjectTechnologyOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProjectTechnologyOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProjectTechnologyType2githubcomfogoshgrackdbentprojecttechnologyType(ctx context.Context, v interface{}) ([]projecttechnology.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]projecttechnology.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProjectTechnologyType2githubcomfogoshgrackdbentprojecttechnologyType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOProjectTechnologyType2githubcomfogoshgrackdbentprojecttechnologyType(ctx context.Context, sel ast.SelectionSet, v []projecttechnology.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectTechnologyType2githubcomfogoshgrackdbentprojecttechnologyType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOProjectTechnologyType2githubcomfogoshgrackdbentprojecttechnologyType(ctx context.Context, v interface{}) (*projecttechnology.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(projecttechnology.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectTechnologyType2githubcomfogoshgrackdbentprojecttechnologyType(ctx context.Context, sel ast.SelectionSet, v *projecttechnology.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOProjectTechnologyWhereInput2githubcomfogoshgrackdbentProjectTechnologyWhereInput(ctx context.Context, v interface{}) ([]*ent.ProjectTechnologyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ProjectTechnologyWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProjectTechnologyWhereInput2githubcomfogoshgrackdbentProjectTechnologyWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOProjectTechnologyWhereInput2githubcomfogoshgrackdbentProjectTechnologyWhereInput(ctx context.Context, v interface{}) (*ent.ProjectTechnologyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProjectTechnologyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProjectWhereInput2githubcomfogoshgrackdbentProjectWhereInput(ctx context.Context, v interface{}) ([]*ent.ProjectWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ProjectWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProjectWhereInput2githubcomfogoshgrackdbentProjectWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOProjectWhereInput2githubcomfogoshgrackdbentProjectWhereInput(ctx context.Context, v interface{}) (*ent.ProjectWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProjectWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepository2githubcomfogoshgrackdbentRepository(ctx context.Context, sel ast.SelectionSet, v []*ent.Repository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepository2githubcomfogoshgrackdbentRepository(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalORepository2githubcomfogoshgrackdbentRepository(ctx context.Context, sel ast.SelectionSet, v *ent.Repository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) marshalORepositoryEdge2githubcomfogoshgrackdbentRepositoryEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.RepositoryEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalORepositoryEdge2githubcomfogoshgrackdbentRepositoryEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalORepositoryEdge2githubcomfogoshgrackdbentRepositoryEdge(ctx context.Context, sel ast.SelectionSet, v *ent.RepositoryEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepositoryEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalORepositoryOrder2githubcomfogoshgrackdbentRepositoryOrder(ctx context.Context, v interface{}) (*ent.RepositoryOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRepositoryOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepositoryTechnology2githubcomfogoshgrackdbentRepositoryTechnology(ctx context.Context, sel ast.SelectionSet, v []*ent.RepositoryTechnology) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepositoryTechnology2githubcomfogoshgrackdbentRepositoryTechnology(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalORepositoryTechnology2githubcomfogoshgrackdbentRepositoryTechnology(ctx context.Context, sel ast.SelectionSet, v *ent.RepositoryTechnology) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepositoryTechnology(ctx, sel, v)
}

func (ec *executionContext) marshalORepositoryTechnologyEdge2githubcomfogoshgrackdbentRepositoryTechnologyEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.RepositoryTechnologyEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalORepositoryTechnologyEdge2githubcomfogoshgrackdbentRepositoryTechnologyEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalORepositoryTechnologyEdge2githubcomfogoshgrackdbentRepositoryTechnologyEdge(ctx context.Context, sel ast.SelectionSet, v *ent.RepositoryTechnologyEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepositoryTechnologyEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalORepositoryTechnologyOrder2githubcomfogoshgrackdbentRepositoryTechnologyOrder(ctx context.Context, v interface{}) (*ent.RepositoryTechnologyOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRepositoryTechnologyOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORepositoryTechnologyType2githubcomfogoshgrackdbentrepositorytechnologyType(ctx context.Context, v interface{}) ([]repositorytechnology.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]repositorytechnology.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRepositoryTechnologyType2githubcomfogoshgrackdbentrepositorytechnologyType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalORepositoryTechnologyType2githubcomfogoshgrackdbentrepositorytechnologyType(ctx context.Context, sel ast.SelectionSet, v []repositorytechnology.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepositoryTechnologyType2githubcomfogoshgrackdbentrepositorytechnologyType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalORepositoryTechnologyType2githubcomfogoshgrackdbentrepositorytechnologyType(ctx context.Context, v interface{}) (*repositorytechnology.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(repositorytechnology.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepositoryTechnologyType2githubcomfogoshgrackdbentrepositorytechnologyType(ctx context.Context, sel ast.SelectionSet, v *repositorytechnology.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalORepositoryTechnologyWhereInput2githubcomfogoshgrackdbentRepositoryTechnologyWhereInput(ctx context.Context, v interface{}) ([]*ent.RepositoryTechnologyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.RepositoryTechnologyWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRepositoryTechnologyWhereInput2githubcomfogoshgrackdbentRepositoryTechnologyWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalORepositoryTechnologyWhereInput2githubcomfogoshgrackdbentRepositoryTechnologyWhereInput(ctx context.Context, v interface{}) (*ent.RepositoryTechnologyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRepositoryTechnologyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORepositoryWhereInput2githubcomfogoshgrackdbentRepositoryWhereInput(ctx context.Context, v interface{}) ([]*ent.RepositoryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.RepositoryWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRepositoryWhereInput2githubcomfogoshgrackdbentRepositoryWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalORepositoryWhereInput2githubcomfogoshgrackdbentRepositoryWhereInput(ctx context.Context, v interface{}) (*ent.RepositoryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRepositoryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSite2githubcomfogoshgrackdbentSite(ctx context.Context, sel ast.SelectionSet, v []*ent.Site) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSite2githubcomfogoshgrackdbentSite(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOSite2githubcomfogoshgrackdbentSite(ctx context.Context, sel ast.SelectionSet, v *ent.Site) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Site(ctx, sel, v)
}

func (ec *executionContext) marshalOSiteEdge2githubcomfogoshgrackdbentSiteEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.SiteEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSiteEdge2githubcomfogoshgrackdbentSiteEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOSiteEdge2githubcomfogoshgrackdbentSiteEdge(ctx context.Context, sel ast.SelectionSet, v *ent.SiteEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SiteEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSiteOrder2githubcomfogoshgrackdbentSiteOrder(ctx context.Context, v interface{}) (*ent.SiteOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSiteOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSiteWhereInput2githubcomfogoshgrackdbentSiteWhereInput(ctx context.Context, v interface{}) ([]*ent.SiteWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.SiteWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSiteWhereInput2githubcomfogoshgrackdbentSiteWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSiteWhereInput2githubcomfogoshgrackdbentSiteWhereInput(ctx context.Context, v interface{}) (*ent.SiteWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSiteWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTechnology2githubcomfogoshgrackdbentTechnology(ctx context.Context, sel ast.SelectionSet, v *ent.Technology) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Technology(ctx, sel, v)
}

func (ec *executionContext) marshalOTechnologyAssociation2githubcomfogoshgrackdbentTechnologyAssociation(ctx context.Context, sel ast.SelectionSet, v []*ent.TechnologyAssociation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTechnologyAssociation2githubcomfogoshgrackdbentTechnologyAssociation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTechnologyAssociation2githubcomfogoshgrackdbentTechnologyAssociation(ctx context.Context, sel ast.SelectionSet, v *ent.TechnologyAssociation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TechnologyAssociation(ctx, sel, v)
}

func (ec *executionContext) marshalOTechnologyAssociationEdge2githubcomfogoshgrackdbentTechnologyAssociationEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.TechnologyAssociationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTechnologyAssociationEdge2githubcomfogoshgrackdbentTechnologyAssociationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTechnologyAssociationEdge2githubcomfogoshgrackdbentTechnologyAssociationEdge(ctx context.Context, sel ast.SelectionSet, v *ent.TechnologyAssociationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TechnologyAssociationEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTechnologyAssociationOrder2githubcomfogoshgrackdbentTechnologyAssociationOrder(ctx context.Context, v interface{}) (*ent.TechnologyAssociationOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTechnologyAssociationOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTechnologyAssociationType2githubcomfogoshgrackdbenttechnologyassociationType(ctx context.Context, v interface{}) ([]technologyassociation.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]technologyassociation.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTechnologyAssociationType2githubcomfogoshgrackdbenttechnologyassociationType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTechnologyAssociationType2githubcomfogoshgrackdbenttechnologyassociationType(ctx context.Context, sel ast.SelectionSet, v []technologyassociation.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTechnologyAssociationType2githubcomfogoshgrackdbenttechnologyassociationType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTechnologyAssociationType2githubcomfogoshgrackdbenttechnologyassociationType(ctx context.Context, v interface{}) (*technologyassociation.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(technologyassociation.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTechnologyAssociationType2githubcomfogoshgrackdbenttechnologyassociationType(ctx context.Context, sel ast.SelectionSet, v *technologyassociation.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOTechnologyAssociationWhereInput2githubcomfogoshgrackdbentTechnologyAssociationWhereInput(ctx context.Context, v interface{}) ([]*ent.TechnologyAssociationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.TechnologyAssociationWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTechnologyAssociationWhereInput2githubcomfogoshgrackdbentTechnologyAssociationWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTechnologyAssociationWhereInput2githubcomfogoshgrackdbentTechnologyAssociationWhereInput(ctx context.Context, v interface{}) (*ent.TechnologyAssociationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTechnologyAssociationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTechnologyEdge2githubcomfogoshgrackdbentTechnologyEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.TechnologyEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTechnologyEdge2githubcomfogoshgrackdbentTechnologyEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTechnologyEdge2githubcomfogoshgrackdbentTechnologyEdge(ctx context.Context, sel ast.SelectionSet, v *ent.TechnologyEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TechnologyEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTechnologyOrder2githubcomfogoshgrackdbentTechnologyOrder(ctx context.Context, v interface{}) (*ent.TechnologyOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTechnologyOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTechnologyType2githubcomfogoshgrackdbenttechnologyType(ctx context.Context, v interface{}) ([]technology.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]technology.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTechnologyType2githubcomfogoshgrackdbenttechnologyType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTechnologyType2githubcomfogoshgrackdbenttechnologyType(ctx context.Context, sel ast.SelectionSet, v []technology.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTechnologyType2githubcomfogoshgrackdbenttechnologyType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTechnologyType2githubcomfogoshgrackdbenttechnologyType(ctx context.Context, v interface{}) (*technology.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(technology.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTechnologyType2githubcomfogoshgrackdbenttechnologyType(ctx context.Context, sel ast.SelectionSet, v *technology.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOTechnologyWhereInput2githubcomfogoshgrackdbentTechnologyWhereInput(ctx context.Context, v interface{}) ([]*ent.TechnologyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.TechnologyWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTechnologyWhereInput2githubcomfogoshgrackdbentTechnologyWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTechnologyWhereInput2githubcomfogoshgrackdbentTechnologyWhereInput(ctx context.Context, v interface{}) (*ent.TechnologyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTechnologyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) ([]time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTime2timeTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v []time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOUser2githubcomfogoshgrackdbentUser(ctx context.Context, sel ast.SelectionSet, v *ent.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalOUserEdge2githubcomfogoshgrackdbentUserEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.UserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUserEdge2githubcomfogoshgrackdbentUserEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOUserEdge2githubcomfogoshgrackdbentUserEdge(ctx context.Context, sel ast.SelectionSet, v *ent.UserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserOrder2githubcomfogoshgrackdbentUserOrder(ctx context.Context, v interface{}) (*ent.UserOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUserWhereInput2githubcomfogoshgrackdbentUserWhereInput(ctx context.Context, v interface{}) ([]*ent.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.UserWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserWhereInput2githubcomfogoshgrackdbentUserWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserWhereInput2githubcomfogoshgrackdbentUserWhereInput(ctx context.Context, v interface{}) (*ent.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
