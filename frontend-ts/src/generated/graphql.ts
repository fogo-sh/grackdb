import { useMutation, useQuery, UseMutationOptions, UseQueryOptions } from '@tanstack/react-query';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };

function fetcher<TData, TVariables>(endpoint: string, requestInit: RequestInit, query: string, variables?: TVariables) {
  return async (): Promise<TData> => {
    const res = await fetch(endpoint, {
      method: 'POST',
      ...requestInit,
      body: JSON.stringify({ query, variables }),
    });

    const json = await res.json();

    if (json.errors) {
      const { message } = json.errors[0];

      throw new Error(message);
    }

    return json.data;
  }
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Cursor: any;
  Time: any;
};

export type AuthProvider = {
  __typename?: 'AuthProvider';
  type: AuthProviderType;
  url: Scalars['String'];
};

export enum AuthProviderType {
  Discord = 'DISCORD',
  Github = 'GITHUB'
}

export type CreateDiscordAccountInput = {
  discordId: Scalars['String'];
  discriminator: Scalars['String'];
  owner?: InputMaybe<Scalars['Int']>;
  username: Scalars['String'];
};

export type CreateDiscordBotInput = {
  account: Scalars['Int'];
  project: Scalars['Int'];
  repository?: InputMaybe<Scalars['Int']>;
};

export type CreateGithubAccountInput = {
  owner: Scalars['Int'];
  username: Scalars['String'];
};

export type CreateGithubOrganizationInput = {
  displayName?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
};

export type CreateGithubOrganizationMemberInput = {
  account: Scalars['Int'];
  organization: Scalars['Int'];
  role: GithubOrganizationMemberRole;
};

export type CreateProjectAssociationInput = {
  child: Scalars['Int'];
  parent: Scalars['Int'];
  type: ProjectAssociationType;
};

export type CreateProjectContributorInput = {
  project: Scalars['Int'];
  role: ProjectContributorRole;
  user: Scalars['Int'];
};

export type CreateProjectInput = {
  description?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['Time']>;
  name: Scalars['String'];
  startDate: Scalars['Time'];
};

export type CreateProjectTechnologyInput = {
  project: Scalars['Int'];
  technology: Scalars['Int'];
  type: ProjectTechnologyAssociationType;
};

export type CreateRepositoryInput = {
  description?: InputMaybe<Scalars['String']>;
  githubAccount?: InputMaybe<Scalars['Int']>;
  githubOrganization?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  project: Scalars['Int'];
};

export type CreateRepositoryTechnologyInput = {
  repository: Scalars['Int'];
  technology: Scalars['Int'];
  type: RepositoryTechnologyAssociationType;
};

export type CreateSiteInput = {
  project: Scalars['Int'];
  repository?: InputMaybe<Scalars['Int']>;
  url: Scalars['String'];
};

export type CreateTechnologyAssociationInput = {
  child: Scalars['Int'];
  parent: Scalars['Int'];
  type: TechnologyAssociationType;
};

export type CreateTechnologyInput = {
  colour?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  type: TechnologyType;
};

export type CreateUserInput = {
  avatarUrl?: InputMaybe<Scalars['String']>;
  username: Scalars['String'];
};

export type DiscordAccount = Node & {
  __typename?: 'DiscordAccount';
  bot?: Maybe<DiscordBot>;
  discordId: Scalars['String'];
  discriminator: Scalars['String'];
  id: Scalars['ID'];
  owner?: Maybe<User>;
  username: Scalars['String'];
};

export type DiscordAccountConnection = {
  __typename?: 'DiscordAccountConnection';
  edges?: Maybe<Array<Maybe<DiscordAccountEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type DiscordAccountEdge = {
  __typename?: 'DiscordAccountEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<DiscordAccount>;
};

export type DiscordAccountOrder = {
  direction: OrderDirection;
  field?: InputMaybe<DiscordAccountOrderField>;
};

export enum DiscordAccountOrderField {
  DiscordId = 'DISCORD_ID',
  Discriminator = 'DISCRIMINATOR',
  Username = 'USERNAME'
}

/**
 * DiscordAccountWhereInput is used for filtering DiscordAccount objects.
 * Input was generated by ent.
 */
export type DiscordAccountWhereInput = {
  and?: InputMaybe<Array<DiscordAccountWhereInput>>;
  /** discord_id field predicates */
  discordID?: InputMaybe<Scalars['String']>;
  discordIDContains?: InputMaybe<Scalars['String']>;
  discordIDContainsFold?: InputMaybe<Scalars['String']>;
  discordIDEqualFold?: InputMaybe<Scalars['String']>;
  discordIDGT?: InputMaybe<Scalars['String']>;
  discordIDGTE?: InputMaybe<Scalars['String']>;
  discordIDHasPrefix?: InputMaybe<Scalars['String']>;
  discordIDHasSuffix?: InputMaybe<Scalars['String']>;
  discordIDIn?: InputMaybe<Array<Scalars['String']>>;
  discordIDLT?: InputMaybe<Scalars['String']>;
  discordIDLTE?: InputMaybe<Scalars['String']>;
  discordIDNEQ?: InputMaybe<Scalars['String']>;
  discordIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** discriminator field predicates */
  discriminator?: InputMaybe<Scalars['String']>;
  discriminatorContains?: InputMaybe<Scalars['String']>;
  discriminatorContainsFold?: InputMaybe<Scalars['String']>;
  discriminatorEqualFold?: InputMaybe<Scalars['String']>;
  discriminatorGT?: InputMaybe<Scalars['String']>;
  discriminatorGTE?: InputMaybe<Scalars['String']>;
  discriminatorHasPrefix?: InputMaybe<Scalars['String']>;
  discriminatorHasSuffix?: InputMaybe<Scalars['String']>;
  discriminatorIn?: InputMaybe<Array<Scalars['String']>>;
  discriminatorLT?: InputMaybe<Scalars['String']>;
  discriminatorLTE?: InputMaybe<Scalars['String']>;
  discriminatorNEQ?: InputMaybe<Scalars['String']>;
  discriminatorNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** bot edge predicates */
  hasBot?: InputMaybe<Scalars['Boolean']>;
  hasBotWith?: InputMaybe<Array<DiscordBotWhereInput>>;
  /** owner edge predicates */
  hasOwner?: InputMaybe<Scalars['Boolean']>;
  hasOwnerWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<DiscordAccountWhereInput>;
  or?: InputMaybe<Array<DiscordAccountWhereInput>>;
  /** username field predicates */
  username?: InputMaybe<Scalars['String']>;
  usernameContains?: InputMaybe<Scalars['String']>;
  usernameContainsFold?: InputMaybe<Scalars['String']>;
  usernameEqualFold?: InputMaybe<Scalars['String']>;
  usernameGT?: InputMaybe<Scalars['String']>;
  usernameGTE?: InputMaybe<Scalars['String']>;
  usernameHasPrefix?: InputMaybe<Scalars['String']>;
  usernameHasSuffix?: InputMaybe<Scalars['String']>;
  usernameIn?: InputMaybe<Array<Scalars['String']>>;
  usernameLT?: InputMaybe<Scalars['String']>;
  usernameLTE?: InputMaybe<Scalars['String']>;
  usernameNEQ?: InputMaybe<Scalars['String']>;
  usernameNotIn?: InputMaybe<Array<Scalars['String']>>;
};

export type DiscordBot = Node & {
  __typename?: 'DiscordBot';
  account: DiscordAccount;
  id: Scalars['ID'];
  project: Project;
  repository?: Maybe<Repository>;
};

export type DiscordBotConnection = {
  __typename?: 'DiscordBotConnection';
  edges?: Maybe<Array<Maybe<DiscordBotEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type DiscordBotEdge = {
  __typename?: 'DiscordBotEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<DiscordBot>;
};

/**
 * DiscordBotWhereInput is used for filtering DiscordBot objects.
 * Input was generated by ent.
 */
export type DiscordBotWhereInput = {
  and?: InputMaybe<Array<DiscordBotWhereInput>>;
  /** account edge predicates */
  hasAccount?: InputMaybe<Scalars['Boolean']>;
  hasAccountWith?: InputMaybe<Array<DiscordAccountWhereInput>>;
  /** project edge predicates */
  hasProject?: InputMaybe<Scalars['Boolean']>;
  hasProjectWith?: InputMaybe<Array<ProjectWhereInput>>;
  /** repository edge predicates */
  hasRepository?: InputMaybe<Scalars['Boolean']>;
  hasRepositoryWith?: InputMaybe<Array<RepositoryWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<DiscordBotWhereInput>;
  or?: InputMaybe<Array<DiscordBotWhereInput>>;
};

export type GithubAccount = Node & {
  __typename?: 'GithubAccount';
  id: Scalars['ID'];
  organizationMemberships?: Maybe<Array<GithubOrganizationMember>>;
  owner: User;
  repositories?: Maybe<Array<Repository>>;
  username: Scalars['String'];
};

export type GithubAccountConnection = {
  __typename?: 'GithubAccountConnection';
  edges?: Maybe<Array<Maybe<GithubAccountEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type GithubAccountEdge = {
  __typename?: 'GithubAccountEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<GithubAccount>;
};

export type GithubAccountOrder = {
  direction: OrderDirection;
  field?: InputMaybe<GithubAccountOrderField>;
};

export enum GithubAccountOrderField {
  Username = 'USERNAME'
}

/**
 * GithubAccountWhereInput is used for filtering GithubAccount objects.
 * Input was generated by ent.
 */
export type GithubAccountWhereInput = {
  and?: InputMaybe<Array<GithubAccountWhereInput>>;
  /** organization_memberships edge predicates */
  hasOrganizationMemberships?: InputMaybe<Scalars['Boolean']>;
  hasOrganizationMembershipsWith?: InputMaybe<Array<GithubOrganizationMemberWhereInput>>;
  /** owner edge predicates */
  hasOwner?: InputMaybe<Scalars['Boolean']>;
  hasOwnerWith?: InputMaybe<Array<UserWhereInput>>;
  /** repositories edge predicates */
  hasRepositories?: InputMaybe<Scalars['Boolean']>;
  hasRepositoriesWith?: InputMaybe<Array<RepositoryWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<GithubAccountWhereInput>;
  or?: InputMaybe<Array<GithubAccountWhereInput>>;
  /** username field predicates */
  username?: InputMaybe<Scalars['String']>;
  usernameContains?: InputMaybe<Scalars['String']>;
  usernameContainsFold?: InputMaybe<Scalars['String']>;
  usernameEqualFold?: InputMaybe<Scalars['String']>;
  usernameGT?: InputMaybe<Scalars['String']>;
  usernameGTE?: InputMaybe<Scalars['String']>;
  usernameHasPrefix?: InputMaybe<Scalars['String']>;
  usernameHasSuffix?: InputMaybe<Scalars['String']>;
  usernameIn?: InputMaybe<Array<Scalars['String']>>;
  usernameLT?: InputMaybe<Scalars['String']>;
  usernameLTE?: InputMaybe<Scalars['String']>;
  usernameNEQ?: InputMaybe<Scalars['String']>;
  usernameNotIn?: InputMaybe<Array<Scalars['String']>>;
};

export type GithubOrganization = Node & {
  __typename?: 'GithubOrganization';
  displayName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  members?: Maybe<Array<GithubOrganizationMember>>;
  name: Scalars['String'];
  repositories?: Maybe<Array<Repository>>;
};

export type GithubOrganizationConnection = {
  __typename?: 'GithubOrganizationConnection';
  edges?: Maybe<Array<Maybe<GithubOrganizationEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type GithubOrganizationEdge = {
  __typename?: 'GithubOrganizationEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<GithubOrganization>;
};

export type GithubOrganizationMember = Node & {
  __typename?: 'GithubOrganizationMember';
  account: GithubAccount;
  id: Scalars['ID'];
  organization: GithubOrganization;
  role: GithubOrganizationMemberRole;
};

export type GithubOrganizationMemberConnection = {
  __typename?: 'GithubOrganizationMemberConnection';
  edges?: Maybe<Array<Maybe<GithubOrganizationMemberEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type GithubOrganizationMemberEdge = {
  __typename?: 'GithubOrganizationMemberEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<GithubOrganizationMember>;
};

export type GithubOrganizationMemberOrder = {
  direction: OrderDirection;
  field?: InputMaybe<GithubOrganizationMemberOrderField>;
};

export enum GithubOrganizationMemberOrderField {
  Role = 'ROLE'
}

export enum GithubOrganizationMemberRole {
  Admin = 'ADMIN',
  Member = 'MEMBER'
}

/**
 * GithubOrganizationMemberWhereInput is used for filtering GithubOrganizationMember objects.
 * Input was generated by ent.
 */
export type GithubOrganizationMemberWhereInput = {
  and?: InputMaybe<Array<GithubOrganizationMemberWhereInput>>;
  /** account edge predicates */
  hasAccount?: InputMaybe<Scalars['Boolean']>;
  hasAccountWith?: InputMaybe<Array<GithubAccountWhereInput>>;
  /** organization edge predicates */
  hasOrganization?: InputMaybe<Scalars['Boolean']>;
  hasOrganizationWith?: InputMaybe<Array<GithubOrganizationWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<GithubOrganizationMemberWhereInput>;
  or?: InputMaybe<Array<GithubOrganizationMemberWhereInput>>;
  /** role field predicates */
  role?: InputMaybe<GithubOrganizationMemberRole>;
  roleIn?: InputMaybe<Array<GithubOrganizationMemberRole>>;
  roleNEQ?: InputMaybe<GithubOrganizationMemberRole>;
  roleNotIn?: InputMaybe<Array<GithubOrganizationMemberRole>>;
};

export type GithubOrganizationOrder = {
  direction: OrderDirection;
  field?: InputMaybe<GithubOrganizationOrderField>;
};

export enum GithubOrganizationOrderField {
  DisplayName = 'DISPLAY_NAME',
  Name = 'NAME'
}

/**
 * GithubOrganizationWhereInput is used for filtering GithubOrganization objects.
 * Input was generated by ent.
 */
export type GithubOrganizationWhereInput = {
  and?: InputMaybe<Array<GithubOrganizationWhereInput>>;
  /** display_name field predicates */
  displayName?: InputMaybe<Scalars['String']>;
  displayNameContains?: InputMaybe<Scalars['String']>;
  displayNameContainsFold?: InputMaybe<Scalars['String']>;
  displayNameEqualFold?: InputMaybe<Scalars['String']>;
  displayNameGT?: InputMaybe<Scalars['String']>;
  displayNameGTE?: InputMaybe<Scalars['String']>;
  displayNameHasPrefix?: InputMaybe<Scalars['String']>;
  displayNameHasSuffix?: InputMaybe<Scalars['String']>;
  displayNameIn?: InputMaybe<Array<Scalars['String']>>;
  displayNameIsNil?: InputMaybe<Scalars['Boolean']>;
  displayNameLT?: InputMaybe<Scalars['String']>;
  displayNameLTE?: InputMaybe<Scalars['String']>;
  displayNameNEQ?: InputMaybe<Scalars['String']>;
  displayNameNotIn?: InputMaybe<Array<Scalars['String']>>;
  displayNameNotNil?: InputMaybe<Scalars['Boolean']>;
  /** members edge predicates */
  hasMembers?: InputMaybe<Scalars['Boolean']>;
  hasMembersWith?: InputMaybe<Array<GithubOrganizationMemberWhereInput>>;
  /** repositories edge predicates */
  hasRepositories?: InputMaybe<Scalars['Boolean']>;
  hasRepositoriesWith?: InputMaybe<Array<RepositoryWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<GithubOrganizationWhereInput>;
  or?: InputMaybe<Array<GithubOrganizationWhereInput>>;
};

export type Mutation = {
  __typename?: 'Mutation';
  assumeDevelopmentUser: User;
  createDiscordAccount: DiscordAccount;
  createDiscordBot: DiscordBot;
  createGithubAccount: GithubAccount;
  createGithubOrganization: GithubOrganization;
  createGithubOrganizationMember: GithubOrganizationMember;
  createProject: Project;
  createProjectAssociation: ProjectAssociation;
  createProjectContributor: ProjectContributor;
  createProjectTechnology: ProjectTechnology;
  createRepository: Repository;
  createRepositoryTechnology: RepositoryTechnology;
  createSite: Site;
  createTechnology: Technology;
  createTechnologyAssociation: TechnologyAssociation;
  createUser: User;
  deleteDiscordAccount: DiscordAccount;
  deleteDiscordBot: DiscordBot;
  deleteGithubAccount: GithubAccount;
  deleteGithubOrganization: GithubOrganization;
  deleteGithubOrganizationMember: GithubOrganizationMember;
  deleteProject: Project;
  deleteProjectAssociation: ProjectAssociation;
  deleteProjectContributor: ProjectContributor;
  deleteProjectTechnology: ProjectTechnology;
  deleteRepository: Repository;
  deleteRepositoryTechnology: RepositoryTechnology;
  deleteSite: Site;
  deleteTechnology: Technology;
  deleteTechnologyAssociation: TechnologyAssociation;
  deleteUser: User;
  updateDiscordAccount: DiscordAccount;
  updateDiscordBot: DiscordBot;
  updateGithubAccount: GithubAccount;
  updateGithubOrganization: GithubOrganization;
  updateGithubOrganizationMember: GithubOrganizationMember;
  updateProject: Project;
  updateProjectAssociation: ProjectAssociation;
  updateProjectContributor: ProjectContributor;
  updateProjectTechnology: ProjectTechnology;
  updateRepository: Repository;
  updateRepositoryTechnology: RepositoryTechnology;
  updateSite: Site;
  updateTechnology: Technology;
  updateTechnologyAssociation: TechnologyAssociation;
  updateUser: User;
};


export type MutationAssumeDevelopmentUserArgs = {
  id: Scalars['ID'];
};


export type MutationCreateDiscordAccountArgs = {
  input: CreateDiscordAccountInput;
};


export type MutationCreateDiscordBotArgs = {
  input: CreateDiscordBotInput;
};


export type MutationCreateGithubAccountArgs = {
  input: CreateGithubAccountInput;
};


export type MutationCreateGithubOrganizationArgs = {
  input: CreateGithubOrganizationInput;
};


export type MutationCreateGithubOrganizationMemberArgs = {
  input: CreateGithubOrganizationMemberInput;
};


export type MutationCreateProjectArgs = {
  input: CreateProjectInput;
};


export type MutationCreateProjectAssociationArgs = {
  input: CreateProjectAssociationInput;
};


export type MutationCreateProjectContributorArgs = {
  input: CreateProjectContributorInput;
};


export type MutationCreateProjectTechnologyArgs = {
  input: CreateProjectTechnologyInput;
};


export type MutationCreateRepositoryArgs = {
  input: CreateRepositoryInput;
};


export type MutationCreateRepositoryTechnologyArgs = {
  input: CreateRepositoryTechnologyInput;
};


export type MutationCreateSiteArgs = {
  input: CreateSiteInput;
};


export type MutationCreateTechnologyArgs = {
  input: CreateTechnologyInput;
};


export type MutationCreateTechnologyAssociationArgs = {
  input: CreateTechnologyAssociationInput;
};


export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


export type MutationDeleteDiscordAccountArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteDiscordBotArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteGithubAccountArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteGithubOrganizationArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteGithubOrganizationMemberArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteProjectArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteProjectAssociationArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteProjectContributorArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteProjectTechnologyArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteRepositoryArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteRepositoryTechnologyArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteSiteArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteTechnologyArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteTechnologyAssociationArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteUserArgs = {
  id: Scalars['ID'];
};


export type MutationUpdateDiscordAccountArgs = {
  id: Scalars['ID'];
  input: UpdateDiscordAccountInput;
};


export type MutationUpdateDiscordBotArgs = {
  id: Scalars['ID'];
  input: UpdateDiscordBotInput;
};


export type MutationUpdateGithubAccountArgs = {
  id: Scalars['ID'];
  input: UpdateGithubAccountInput;
};


export type MutationUpdateGithubOrganizationArgs = {
  id: Scalars['ID'];
  input: UpdateGithubOrganizationInput;
};


export type MutationUpdateGithubOrganizationMemberArgs = {
  id: Scalars['ID'];
  input: UpdateGithubOrganizationMemberInput;
};


export type MutationUpdateProjectArgs = {
  id: Scalars['ID'];
  input: UpdateProjectInput;
};


export type MutationUpdateProjectAssociationArgs = {
  id: Scalars['ID'];
  input: UpdateProjectAssociationInput;
};


export type MutationUpdateProjectContributorArgs = {
  id: Scalars['ID'];
  input: UpdateProjectContributorInput;
};


export type MutationUpdateProjectTechnologyArgs = {
  id: Scalars['ID'];
  input: UpdateProjectTechnologyInput;
};


export type MutationUpdateRepositoryArgs = {
  id: Scalars['ID'];
  input: UpdateRepositoryInput;
};


export type MutationUpdateRepositoryTechnologyArgs = {
  id: Scalars['ID'];
  input: UpdateRepositoryTechnologyInput;
};


export type MutationUpdateSiteArgs = {
  id: Scalars['ID'];
  input: UpdateSiteInput;
};


export type MutationUpdateTechnologyArgs = {
  id: Scalars['ID'];
  input: UpdateTechnologyInput;
};


export type MutationUpdateTechnologyAssociationArgs = {
  id: Scalars['ID'];
  input: UpdateTechnologyAssociationInput;
};


export type MutationUpdateUserArgs = {
  id: Scalars['ID'];
  input: UpdateUserInput;
};

export type Node = {
  id: Scalars['ID'];
};

export enum OrderDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor?: Maybe<Scalars['Cursor']>;
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor?: Maybe<Scalars['Cursor']>;
};

export type Project = Node & {
  __typename?: 'Project';
  childProjects?: Maybe<Array<ProjectAssociation>>;
  contributors?: Maybe<Array<ProjectContributor>>;
  description?: Maybe<Scalars['String']>;
  discordBots?: Maybe<Array<DiscordBot>>;
  endDate?: Maybe<Scalars['Time']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  parentProjects?: Maybe<Array<ProjectAssociation>>;
  repositories?: Maybe<Array<Repository>>;
  sites?: Maybe<Array<Site>>;
  startDate: Scalars['Time'];
  technologies?: Maybe<Array<ProjectTechnology>>;
};

export type ProjectAssociation = Node & {
  __typename?: 'ProjectAssociation';
  child: Project;
  id: Scalars['ID'];
  parent: Project;
  type: ProjectAssociationType;
};

export type ProjectAssociationConnection = {
  __typename?: 'ProjectAssociationConnection';
  edges?: Maybe<Array<Maybe<ProjectAssociationEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type ProjectAssociationEdge = {
  __typename?: 'ProjectAssociationEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<ProjectAssociation>;
};

export type ProjectAssociationOrder = {
  direction: OrderDirection;
  field?: InputMaybe<ProjectAssociationOrderField>;
};

export enum ProjectAssociationOrderField {
  Type = 'TYPE'
}

export enum ProjectAssociationType {
  BasedOff = 'BASED_OFF',
  InspiredBy = 'INSPIRED_BY',
  Related = 'RELATED',
  Replaces = 'REPLACES'
}

/**
 * ProjectAssociationWhereInput is used for filtering ProjectAssociation objects.
 * Input was generated by ent.
 */
export type ProjectAssociationWhereInput = {
  and?: InputMaybe<Array<ProjectAssociationWhereInput>>;
  /** child edge predicates */
  hasChild?: InputMaybe<Scalars['Boolean']>;
  hasChildWith?: InputMaybe<Array<ProjectWhereInput>>;
  /** parent edge predicates */
  hasParent?: InputMaybe<Scalars['Boolean']>;
  hasParentWith?: InputMaybe<Array<ProjectWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ProjectAssociationWhereInput>;
  or?: InputMaybe<Array<ProjectAssociationWhereInput>>;
  /** type field predicates */
  type?: InputMaybe<ProjectAssociationType>;
  typeIn?: InputMaybe<Array<ProjectAssociationType>>;
  typeNEQ?: InputMaybe<ProjectAssociationType>;
  typeNotIn?: InputMaybe<Array<ProjectAssociationType>>;
};

export type ProjectConnection = {
  __typename?: 'ProjectConnection';
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type ProjectContributor = Node & {
  __typename?: 'ProjectContributor';
  id: Scalars['ID'];
  project: Project;
  role: ProjectContributorRole;
  user: User;
};

export type ProjectContributorConnection = {
  __typename?: 'ProjectContributorConnection';
  edges?: Maybe<Array<Maybe<ProjectContributorEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type ProjectContributorEdge = {
  __typename?: 'ProjectContributorEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<ProjectContributor>;
};

export type ProjectContributorOrder = {
  direction: OrderDirection;
  field?: InputMaybe<ProjectContributorOrderField>;
};

export enum ProjectContributorOrderField {
  Role = 'ROLE'
}

export enum ProjectContributorRole {
  Contributor = 'CONTRIBUTOR',
  Owner = 'OWNER'
}

/**
 * ProjectContributorWhereInput is used for filtering ProjectContributor objects.
 * Input was generated by ent.
 */
export type ProjectContributorWhereInput = {
  and?: InputMaybe<Array<ProjectContributorWhereInput>>;
  /** project edge predicates */
  hasProject?: InputMaybe<Scalars['Boolean']>;
  hasProjectWith?: InputMaybe<Array<ProjectWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ProjectContributorWhereInput>;
  or?: InputMaybe<Array<ProjectContributorWhereInput>>;
  /** role field predicates */
  role?: InputMaybe<ProjectContributorRole>;
  roleIn?: InputMaybe<Array<ProjectContributorRole>>;
  roleNEQ?: InputMaybe<ProjectContributorRole>;
  roleNotIn?: InputMaybe<Array<ProjectContributorRole>>;
};

export type ProjectEdge = {
  __typename?: 'ProjectEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Project>;
};

export type ProjectOrder = {
  direction: OrderDirection;
  field?: InputMaybe<ProjectOrderField>;
};

export enum ProjectOrderField {
  Description = 'DESCRIPTION',
  EndDate = 'END_DATE',
  Name = 'NAME',
  StartDate = 'START_DATE'
}

export type ProjectTechnology = Node & {
  __typename?: 'ProjectTechnology';
  id: Scalars['ID'];
  project: Project;
  technology: Technology;
  type: ProjectTechnologyAssociationType;
};

export enum ProjectTechnologyAssociationType {
  Contains = 'CONTAINS',
  Implements = 'IMPLEMENTS',
  Uses = 'USES',
  WrittenIn = 'WRITTEN_IN'
}

export type ProjectTechnologyConnection = {
  __typename?: 'ProjectTechnologyConnection';
  edges?: Maybe<Array<Maybe<ProjectTechnologyEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type ProjectTechnologyEdge = {
  __typename?: 'ProjectTechnologyEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<ProjectTechnology>;
};

export type ProjectTechnologyOrder = {
  direction: OrderDirection;
  field?: InputMaybe<ProjectTechnologyOrderField>;
};

export enum ProjectTechnologyOrderField {
  Type = 'TYPE'
}

/**
 * ProjectTechnologyWhereInput is used for filtering ProjectTechnology objects.
 * Input was generated by ent.
 */
export type ProjectTechnologyWhereInput = {
  and?: InputMaybe<Array<ProjectTechnologyWhereInput>>;
  /** project edge predicates */
  hasProject?: InputMaybe<Scalars['Boolean']>;
  hasProjectWith?: InputMaybe<Array<ProjectWhereInput>>;
  /** technology edge predicates */
  hasTechnology?: InputMaybe<Scalars['Boolean']>;
  hasTechnologyWith?: InputMaybe<Array<TechnologyWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ProjectTechnologyWhereInput>;
  or?: InputMaybe<Array<ProjectTechnologyWhereInput>>;
  /** type field predicates */
  type?: InputMaybe<ProjectTechnologyAssociationType>;
  typeIn?: InputMaybe<Array<ProjectTechnologyAssociationType>>;
  typeNEQ?: InputMaybe<ProjectTechnologyAssociationType>;
  typeNotIn?: InputMaybe<Array<ProjectTechnologyAssociationType>>;
};

/**
 * ProjectWhereInput is used for filtering Project objects.
 * Input was generated by ent.
 */
export type ProjectWhereInput = {
  and?: InputMaybe<Array<ProjectWhereInput>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;
  /** end_date field predicates */
  endDate?: InputMaybe<Scalars['Time']>;
  endDateGT?: InputMaybe<Scalars['Time']>;
  endDateGTE?: InputMaybe<Scalars['Time']>;
  endDateIn?: InputMaybe<Array<Scalars['Time']>>;
  endDateIsNil?: InputMaybe<Scalars['Boolean']>;
  endDateLT?: InputMaybe<Scalars['Time']>;
  endDateLTE?: InputMaybe<Scalars['Time']>;
  endDateNEQ?: InputMaybe<Scalars['Time']>;
  endDateNotIn?: InputMaybe<Array<Scalars['Time']>>;
  endDateNotNil?: InputMaybe<Scalars['Boolean']>;
  /** child_projects edge predicates */
  hasChildProjects?: InputMaybe<Scalars['Boolean']>;
  hasChildProjectsWith?: InputMaybe<Array<ProjectAssociationWhereInput>>;
  /** contributors edge predicates */
  hasContributors?: InputMaybe<Scalars['Boolean']>;
  hasContributorsWith?: InputMaybe<Array<ProjectContributorWhereInput>>;
  /** discord_bots edge predicates */
  hasDiscordBots?: InputMaybe<Scalars['Boolean']>;
  hasDiscordBotsWith?: InputMaybe<Array<DiscordBotWhereInput>>;
  /** parent_projects edge predicates */
  hasParentProjects?: InputMaybe<Scalars['Boolean']>;
  hasParentProjectsWith?: InputMaybe<Array<ProjectAssociationWhereInput>>;
  /** repositories edge predicates */
  hasRepositories?: InputMaybe<Scalars['Boolean']>;
  hasRepositoriesWith?: InputMaybe<Array<RepositoryWhereInput>>;
  /** sites edge predicates */
  hasSites?: InputMaybe<Scalars['Boolean']>;
  hasSitesWith?: InputMaybe<Array<SiteWhereInput>>;
  /** technologies edge predicates */
  hasTechnologies?: InputMaybe<Scalars['Boolean']>;
  hasTechnologiesWith?: InputMaybe<Array<ProjectTechnologyWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<ProjectWhereInput>;
  or?: InputMaybe<Array<ProjectWhereInput>>;
  /** start_date field predicates */
  startDate?: InputMaybe<Scalars['Time']>;
  startDateGT?: InputMaybe<Scalars['Time']>;
  startDateGTE?: InputMaybe<Scalars['Time']>;
  startDateIn?: InputMaybe<Array<Scalars['Time']>>;
  startDateLT?: InputMaybe<Scalars['Time']>;
  startDateLTE?: InputMaybe<Scalars['Time']>;
  startDateNEQ?: InputMaybe<Scalars['Time']>;
  startDateNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Query = {
  __typename?: 'Query';
  availableAuthProviders?: Maybe<Array<Maybe<AuthProvider>>>;
  currentUser?: Maybe<User>;
  developmentMode: Scalars['Boolean'];
  discordAccounts?: Maybe<DiscordAccountConnection>;
  discordBots?: Maybe<DiscordBotConnection>;
  githubAccounts?: Maybe<GithubAccountConnection>;
  githubOrganizationMembers?: Maybe<GithubOrganizationMemberConnection>;
  githubOrganizations?: Maybe<GithubOrganizationConnection>;
  projectAssociations?: Maybe<ProjectAssociationConnection>;
  projectContributors?: Maybe<ProjectContributorConnection>;
  projectTechnologies?: Maybe<ProjectTechnologyConnection>;
  projects?: Maybe<ProjectConnection>;
  repositories?: Maybe<RepositoryConnection>;
  repositoryTechnologies?: Maybe<RepositoryTechnologyConnection>;
  sites?: Maybe<SiteConnection>;
  technologies?: Maybe<TechnologyConnection>;
  technologyAssociations?: Maybe<TechnologyAssociationConnection>;
  users?: Maybe<UserConnection>;
};


export type QueryDiscordAccountsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<DiscordAccountOrder>;
  where?: InputMaybe<DiscordAccountWhereInput>;
};


export type QueryDiscordBotsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DiscordBotWhereInput>;
};


export type QueryGithubAccountsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<GithubAccountOrder>;
  where?: InputMaybe<GithubAccountWhereInput>;
};


export type QueryGithubOrganizationMembersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<GithubOrganizationMemberOrder>;
  where?: InputMaybe<GithubOrganizationMemberWhereInput>;
};


export type QueryGithubOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<GithubOrganizationOrder>;
  where?: InputMaybe<GithubOrganizationWhereInput>;
};


export type QueryProjectAssociationsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ProjectAssociationOrder>;
  where?: InputMaybe<ProjectAssociationWhereInput>;
};


export type QueryProjectContributorsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ProjectContributorOrder>;
  where?: InputMaybe<ProjectContributorWhereInput>;
};


export type QueryProjectTechnologiesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ProjectTechnologyOrder>;
  where?: InputMaybe<ProjectTechnologyWhereInput>;
};


export type QueryProjectsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ProjectOrder>;
  where?: InputMaybe<ProjectWhereInput>;
};


export type QueryRepositoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<RepositoryOrder>;
  where?: InputMaybe<RepositoryWhereInput>;
};


export type QueryRepositoryTechnologiesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<RepositoryTechnologyOrder>;
  where?: InputMaybe<RepositoryTechnologyWhereInput>;
};


export type QuerySitesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SiteOrder>;
  where?: InputMaybe<SiteWhereInput>;
};


export type QueryTechnologiesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TechnologyOrder>;
  where?: InputMaybe<TechnologyWhereInput>;
};


export type QueryTechnologyAssociationsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TechnologyAssociationOrder>;
  where?: InputMaybe<TechnologyAssociationWhereInput>;
};


export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<UserOrder>;
  where?: InputMaybe<UserWhereInput>;
};

export type Repository = Node & {
  __typename?: 'Repository';
  description?: Maybe<Scalars['String']>;
  discordBots?: Maybe<Array<DiscordBot>>;
  githubAccount?: Maybe<GithubAccount>;
  githubOrganization?: Maybe<GithubOrganization>;
  id: Scalars['ID'];
  name: Scalars['String'];
  project: Project;
  sites?: Maybe<Array<Site>>;
};

export type RepositoryConnection = {
  __typename?: 'RepositoryConnection';
  edges?: Maybe<Array<Maybe<RepositoryEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type RepositoryEdge = {
  __typename?: 'RepositoryEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Repository>;
};

export type RepositoryOrder = {
  direction: OrderDirection;
  field?: InputMaybe<RepositoryOrderField>;
};

export enum RepositoryOrderField {
  Description = 'DESCRIPTION',
  Name = 'NAME'
}

export type RepositoryTechnology = Node & {
  __typename?: 'RepositoryTechnology';
  id: Scalars['ID'];
  repository: Repository;
  technology: Technology;
  type: RepositoryTechnologyAssociationType;
};

export enum RepositoryTechnologyAssociationType {
  Contains = 'CONTAINS',
  Implements = 'IMPLEMENTS',
  Uses = 'USES',
  WrittenIn = 'WRITTEN_IN'
}

export type RepositoryTechnologyConnection = {
  __typename?: 'RepositoryTechnologyConnection';
  edges?: Maybe<Array<Maybe<RepositoryTechnologyEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type RepositoryTechnologyEdge = {
  __typename?: 'RepositoryTechnologyEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<RepositoryTechnology>;
};

export type RepositoryTechnologyOrder = {
  direction: OrderDirection;
  field?: InputMaybe<RepositoryTechnologyOrderField>;
};

export enum RepositoryTechnologyOrderField {
  Type = 'TYPE'
}

/**
 * RepositoryTechnologyWhereInput is used for filtering RepositoryTechnology objects.
 * Input was generated by ent.
 */
export type RepositoryTechnologyWhereInput = {
  and?: InputMaybe<Array<RepositoryTechnologyWhereInput>>;
  /** repository edge predicates */
  hasRepository?: InputMaybe<Scalars['Boolean']>;
  hasRepositoryWith?: InputMaybe<Array<RepositoryWhereInput>>;
  /** technology edge predicates */
  hasTechnology?: InputMaybe<Scalars['Boolean']>;
  hasTechnologyWith?: InputMaybe<Array<TechnologyWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<RepositoryTechnologyWhereInput>;
  or?: InputMaybe<Array<RepositoryTechnologyWhereInput>>;
  /** type field predicates */
  type?: InputMaybe<RepositoryTechnologyAssociationType>;
  typeIn?: InputMaybe<Array<RepositoryTechnologyAssociationType>>;
  typeNEQ?: InputMaybe<RepositoryTechnologyAssociationType>;
  typeNotIn?: InputMaybe<Array<RepositoryTechnologyAssociationType>>;
};

/**
 * RepositoryWhereInput is used for filtering Repository objects.
 * Input was generated by ent.
 */
export type RepositoryWhereInput = {
  and?: InputMaybe<Array<RepositoryWhereInput>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;
  /** discord_bots edge predicates */
  hasDiscordBots?: InputMaybe<Scalars['Boolean']>;
  hasDiscordBotsWith?: InputMaybe<Array<DiscordBotWhereInput>>;
  /** github_account edge predicates */
  hasGithubAccount?: InputMaybe<Scalars['Boolean']>;
  hasGithubAccountWith?: InputMaybe<Array<GithubAccountWhereInput>>;
  /** github_organization edge predicates */
  hasGithubOrganization?: InputMaybe<Scalars['Boolean']>;
  hasGithubOrganizationWith?: InputMaybe<Array<GithubOrganizationWhereInput>>;
  /** project edge predicates */
  hasProject?: InputMaybe<Scalars['Boolean']>;
  hasProjectWith?: InputMaybe<Array<ProjectWhereInput>>;
  /** sites edge predicates */
  hasSites?: InputMaybe<Scalars['Boolean']>;
  hasSitesWith?: InputMaybe<Array<SiteWhereInput>>;
  /** technologies edge predicates */
  hasTechnologies?: InputMaybe<Scalars['Boolean']>;
  hasTechnologiesWith?: InputMaybe<Array<RepositoryTechnologyWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<RepositoryWhereInput>;
  or?: InputMaybe<Array<RepositoryWhereInput>>;
};

export type Site = Node & {
  __typename?: 'Site';
  id: Scalars['ID'];
  project: Project;
  repository?: Maybe<Repository>;
  url: Scalars['String'];
};

export type SiteConnection = {
  __typename?: 'SiteConnection';
  edges?: Maybe<Array<Maybe<SiteEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type SiteEdge = {
  __typename?: 'SiteEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Site>;
};

export type SiteOrder = {
  direction: OrderDirection;
  field?: InputMaybe<SiteOrderField>;
};

export enum SiteOrderField {
  Url = 'URL'
}

/**
 * SiteWhereInput is used for filtering Site objects.
 * Input was generated by ent.
 */
export type SiteWhereInput = {
  and?: InputMaybe<Array<SiteWhereInput>>;
  /** project edge predicates */
  hasProject?: InputMaybe<Scalars['Boolean']>;
  hasProjectWith?: InputMaybe<Array<ProjectWhereInput>>;
  /** repository edge predicates */
  hasRepository?: InputMaybe<Scalars['Boolean']>;
  hasRepositoryWith?: InputMaybe<Array<RepositoryWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<SiteWhereInput>;
  or?: InputMaybe<Array<SiteWhereInput>>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']>;
  urlContains?: InputMaybe<Scalars['String']>;
  urlContainsFold?: InputMaybe<Scalars['String']>;
  urlEqualFold?: InputMaybe<Scalars['String']>;
  urlGT?: InputMaybe<Scalars['String']>;
  urlGTE?: InputMaybe<Scalars['String']>;
  urlHasPrefix?: InputMaybe<Scalars['String']>;
  urlHasSuffix?: InputMaybe<Scalars['String']>;
  urlIn?: InputMaybe<Array<Scalars['String']>>;
  urlLT?: InputMaybe<Scalars['String']>;
  urlLTE?: InputMaybe<Scalars['String']>;
  urlNEQ?: InputMaybe<Scalars['String']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']>>;
};

export type Technology = Node & {
  __typename?: 'Technology';
  childTechnologies?: Maybe<Array<TechnologyAssociation>>;
  colour?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  parentTechnologies?: Maybe<Array<TechnologyAssociation>>;
  projects?: Maybe<Array<ProjectTechnology>>;
  repositories?: Maybe<Array<RepositoryTechnology>>;
  type: TechnologyType;
};

export type TechnologyAssociation = Node & {
  __typename?: 'TechnologyAssociation';
  child: Technology;
  id: Scalars['ID'];
  parent: Technology;
  type: TechnologyAssociationType;
};

export type TechnologyAssociationConnection = {
  __typename?: 'TechnologyAssociationConnection';
  edges?: Maybe<Array<Maybe<TechnologyAssociationEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type TechnologyAssociationEdge = {
  __typename?: 'TechnologyAssociationEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<TechnologyAssociation>;
};

export type TechnologyAssociationOrder = {
  direction: OrderDirection;
  field?: InputMaybe<TechnologyAssociationOrderField>;
};

export enum TechnologyAssociationOrderField {
  Type = 'TYPE'
}

export enum TechnologyAssociationType {
  Implements = 'IMPLEMENTS',
  Uses = 'USES',
  WrittenIn = 'WRITTEN_IN'
}

/**
 * TechnologyAssociationWhereInput is used for filtering TechnologyAssociation objects.
 * Input was generated by ent.
 */
export type TechnologyAssociationWhereInput = {
  and?: InputMaybe<Array<TechnologyAssociationWhereInput>>;
  /** child edge predicates */
  hasChild?: InputMaybe<Scalars['Boolean']>;
  hasChildWith?: InputMaybe<Array<TechnologyWhereInput>>;
  /** parent edge predicates */
  hasParent?: InputMaybe<Scalars['Boolean']>;
  hasParentWith?: InputMaybe<Array<TechnologyWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<TechnologyAssociationWhereInput>;
  or?: InputMaybe<Array<TechnologyAssociationWhereInput>>;
  /** type field predicates */
  type?: InputMaybe<TechnologyAssociationType>;
  typeIn?: InputMaybe<Array<TechnologyAssociationType>>;
  typeNEQ?: InputMaybe<TechnologyAssociationType>;
  typeNotIn?: InputMaybe<Array<TechnologyAssociationType>>;
};

export type TechnologyConnection = {
  __typename?: 'TechnologyConnection';
  edges?: Maybe<Array<Maybe<TechnologyEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type TechnologyEdge = {
  __typename?: 'TechnologyEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Technology>;
};

export type TechnologyOrder = {
  direction: OrderDirection;
  field?: InputMaybe<TechnologyOrderField>;
};

export enum TechnologyOrderField {
  Colour = 'COLOUR',
  Description = 'DESCRIPTION',
  Name = 'NAME',
  Type = 'TYPE'
}

export enum TechnologyType {
  Algorithm = 'ALGORITHM',
  Database = 'DATABASE',
  Language = 'LANGUAGE',
  Library = 'LIBRARY',
  Protocol = 'PROTOCOL',
  Service = 'SERVICE'
}

/**
 * TechnologyWhereInput is used for filtering Technology objects.
 * Input was generated by ent.
 */
export type TechnologyWhereInput = {
  and?: InputMaybe<Array<TechnologyWhereInput>>;
  /** colour field predicates */
  colour?: InputMaybe<Scalars['String']>;
  colourContains?: InputMaybe<Scalars['String']>;
  colourContainsFold?: InputMaybe<Scalars['String']>;
  colourEqualFold?: InputMaybe<Scalars['String']>;
  colourGT?: InputMaybe<Scalars['String']>;
  colourGTE?: InputMaybe<Scalars['String']>;
  colourHasPrefix?: InputMaybe<Scalars['String']>;
  colourHasSuffix?: InputMaybe<Scalars['String']>;
  colourIn?: InputMaybe<Array<Scalars['String']>>;
  colourIsNil?: InputMaybe<Scalars['Boolean']>;
  colourLT?: InputMaybe<Scalars['String']>;
  colourLTE?: InputMaybe<Scalars['String']>;
  colourNEQ?: InputMaybe<Scalars['String']>;
  colourNotIn?: InputMaybe<Array<Scalars['String']>>;
  colourNotNil?: InputMaybe<Scalars['Boolean']>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;
  /** child_technologies edge predicates */
  hasChildTechnologies?: InputMaybe<Scalars['Boolean']>;
  hasChildTechnologiesWith?: InputMaybe<Array<TechnologyAssociationWhereInput>>;
  /** parent_technologies edge predicates */
  hasParentTechnologies?: InputMaybe<Scalars['Boolean']>;
  hasParentTechnologiesWith?: InputMaybe<Array<TechnologyAssociationWhereInput>>;
  /** projects edge predicates */
  hasProjects?: InputMaybe<Scalars['Boolean']>;
  hasProjectsWith?: InputMaybe<Array<ProjectTechnologyWhereInput>>;
  /** repositories edge predicates */
  hasRepositories?: InputMaybe<Scalars['Boolean']>;
  hasRepositoriesWith?: InputMaybe<Array<RepositoryTechnologyWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<TechnologyWhereInput>;
  or?: InputMaybe<Array<TechnologyWhereInput>>;
  /** type field predicates */
  type?: InputMaybe<TechnologyType>;
  typeIn?: InputMaybe<Array<TechnologyType>>;
  typeNEQ?: InputMaybe<TechnologyType>;
  typeNotIn?: InputMaybe<Array<TechnologyType>>;
};

export type UpdateDiscordAccountInput = {
  discriminator?: InputMaybe<Scalars['String']>;
  owner?: InputMaybe<Scalars['Int']>;
  username?: InputMaybe<Scalars['String']>;
};

export type UpdateDiscordBotInput = {
  account?: InputMaybe<Scalars['Int']>;
  project?: InputMaybe<Scalars['Int']>;
  repository?: InputMaybe<Scalars['Int']>;
};

export type UpdateGithubAccountInput = {
  owner?: InputMaybe<Scalars['Int']>;
  username?: InputMaybe<Scalars['String']>;
};

export type UpdateGithubOrganizationInput = {
  displayName?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
};

export type UpdateGithubOrganizationMemberInput = {
  account?: InputMaybe<Scalars['Int']>;
  organization?: InputMaybe<Scalars['Int']>;
  role?: InputMaybe<GithubOrganizationMemberRole>;
};

export type UpdateProjectAssociationInput = {
  child?: InputMaybe<Scalars['Int']>;
  parent?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<ProjectAssociationType>;
};

export type UpdateProjectContributorInput = {
  project?: InputMaybe<Scalars['Int']>;
  role?: InputMaybe<ProjectContributorRole>;
  user?: InputMaybe<Scalars['Int']>;
};

export type UpdateProjectInput = {
  description?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['Time']>;
  name?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['Time']>;
};

export type UpdateProjectTechnologyInput = {
  project?: InputMaybe<Scalars['Int']>;
  technology?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<ProjectTechnologyAssociationType>;
};

export type UpdateRepositoryInput = {
  description?: InputMaybe<Scalars['String']>;
  githubAccount?: InputMaybe<Scalars['Int']>;
  githubOrganization?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  project?: InputMaybe<Scalars['Int']>;
};

export type UpdateRepositoryTechnologyInput = {
  repository?: InputMaybe<Scalars['Int']>;
  technology?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<RepositoryTechnologyAssociationType>;
};

export type UpdateSiteInput = {
  project?: InputMaybe<Scalars['Int']>;
  repository?: InputMaybe<Scalars['Int']>;
  url?: InputMaybe<Scalars['String']>;
};

export type UpdateTechnologyAssociationInput = {
  child?: InputMaybe<Scalars['Int']>;
  parent?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<TechnologyAssociationType>;
};

export type UpdateTechnologyInput = {
  colour?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<TechnologyType>;
};

export type UpdateUserInput = {
  avatarUrl?: InputMaybe<Scalars['String']>;
  username?: InputMaybe<Scalars['String']>;
};

export type User = Node & {
  __typename?: 'User';
  avatarUrl?: Maybe<Scalars['String']>;
  discordAccounts?: Maybe<Array<DiscordAccount>>;
  githubAccounts?: Maybe<Array<GithubAccount>>;
  id: Scalars['ID'];
  projectContributions?: Maybe<Array<ProjectContributor>>;
  username: Scalars['String'];
};

export type UserConnection = {
  __typename?: 'UserConnection';
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type UserEdge = {
  __typename?: 'UserEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<User>;
};

export type UserOrder = {
  direction: OrderDirection;
  field?: InputMaybe<UserOrderField>;
};

export enum UserOrderField {
  Username = 'USERNAME'
}

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** avatar_url field predicates */
  avatarURL?: InputMaybe<Scalars['String']>;
  avatarURLContains?: InputMaybe<Scalars['String']>;
  avatarURLContainsFold?: InputMaybe<Scalars['String']>;
  avatarURLEqualFold?: InputMaybe<Scalars['String']>;
  avatarURLGT?: InputMaybe<Scalars['String']>;
  avatarURLGTE?: InputMaybe<Scalars['String']>;
  avatarURLHasPrefix?: InputMaybe<Scalars['String']>;
  avatarURLHasSuffix?: InputMaybe<Scalars['String']>;
  avatarURLIn?: InputMaybe<Array<Scalars['String']>>;
  avatarURLIsNil?: InputMaybe<Scalars['Boolean']>;
  avatarURLLT?: InputMaybe<Scalars['String']>;
  avatarURLLTE?: InputMaybe<Scalars['String']>;
  avatarURLNEQ?: InputMaybe<Scalars['String']>;
  avatarURLNotIn?: InputMaybe<Array<Scalars['String']>>;
  avatarURLNotNil?: InputMaybe<Scalars['Boolean']>;
  /** discord_accounts edge predicates */
  hasDiscordAccounts?: InputMaybe<Scalars['Boolean']>;
  hasDiscordAccountsWith?: InputMaybe<Array<DiscordAccountWhereInput>>;
  /** github_accounts edge predicates */
  hasGithubAccounts?: InputMaybe<Scalars['Boolean']>;
  hasGithubAccountsWith?: InputMaybe<Array<GithubAccountWhereInput>>;
  /** project_contributions edge predicates */
  hasProjectContributions?: InputMaybe<Scalars['Boolean']>;
  hasProjectContributionsWith?: InputMaybe<Array<ProjectContributorWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** username field predicates */
  username?: InputMaybe<Scalars['String']>;
  usernameContains?: InputMaybe<Scalars['String']>;
  usernameContainsFold?: InputMaybe<Scalars['String']>;
  usernameEqualFold?: InputMaybe<Scalars['String']>;
  usernameGT?: InputMaybe<Scalars['String']>;
  usernameGTE?: InputMaybe<Scalars['String']>;
  usernameHasPrefix?: InputMaybe<Scalars['String']>;
  usernameHasSuffix?: InputMaybe<Scalars['String']>;
  usernameIn?: InputMaybe<Array<Scalars['String']>>;
  usernameLT?: InputMaybe<Scalars['String']>;
  usernameLTE?: InputMaybe<Scalars['String']>;
  usernameNEQ?: InputMaybe<Scalars['String']>;
  usernameNotIn?: InputMaybe<Array<Scalars['String']>>;
};

export type CreateDiscordAccountMutationVariables = Exact<{
  discordId: Scalars['String'];
  username: Scalars['String'];
  discriminator: Scalars['String'];
  owner: Scalars['Int'];
}>;


export type CreateDiscordAccountMutation = { __typename?: 'Mutation', createDiscordAccount: { __typename?: 'DiscordAccount', id: string, username: string } };

export type CreateGithubAccountMutationVariables = Exact<{
  username: Scalars['String'];
  owner: Scalars['Int'];
}>;


export type CreateGithubAccountMutation = { __typename?: 'Mutation', createGithubAccount: { __typename?: 'GithubAccount', id: string, username: string } };

export type CreateProjectMutationVariables = Exact<{
  name: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  startDate: Scalars['Time'];
  endDate?: InputMaybe<Scalars['Time']>;
}>;


export type CreateProjectMutation = { __typename?: 'Mutation', createProject: { __typename?: 'Project', id: string, name: string, description?: string | null, startDate: any, endDate?: any | null } };

export type CreateProjectTechnologyMutationVariables = Exact<{
  type: ProjectTechnologyAssociationType;
  technology: Scalars['Int'];
  project: Scalars['Int'];
}>;


export type CreateProjectTechnologyMutation = { __typename?: 'Mutation', createProjectTechnology: { __typename?: 'ProjectTechnology', id: string, type: ProjectTechnologyAssociationType, technology: { __typename?: 'Technology', id: string, name: string }, project: { __typename?: 'Project', id: string, name: string } } };

export type CreateUserMutationVariables = Exact<{
  username: Scalars['String'];
  avatarUrl?: InputMaybe<Scalars['String']>;
}>;


export type CreateUserMutation = { __typename?: 'Mutation', createUser: { __typename?: 'User', id: string, username: string, avatarUrl?: string | null } };

export type DeleteUserMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteUserMutation = { __typename?: 'Mutation', deleteUser: { __typename?: 'User', id: string } };

export type DeleteDiscordAccountMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteDiscordAccountMutation = { __typename?: 'Mutation', deleteDiscordAccount: { __typename?: 'DiscordAccount', id: string } };

export type DeleteGithubAccountMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteGithubAccountMutation = { __typename?: 'Mutation', deleteGithubAccount: { __typename?: 'GithubAccount', id: string } };

export type DeleteProjectMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteProjectMutation = { __typename?: 'Mutation', deleteProject: { __typename?: 'Project', id: string } };

export type AssumeDevelopmentUserMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type AssumeDevelopmentUserMutation = { __typename?: 'Mutation', assumeDevelopmentUser: { __typename?: 'User', id: string } };

export type HomepageQueryVariables = Exact<{ [key: string]: never; }>;


export type HomepageQuery = { __typename?: 'Query', users?: { __typename?: 'UserConnection', edges?: Array<{ __typename?: 'UserEdge', node?: { __typename?: 'User', id: string, username: string, avatarUrl?: string | null } | null } | null> | null } | null, projects?: { __typename?: 'ProjectConnection', edges?: Array<{ __typename?: 'ProjectEdge', node?: { __typename?: 'Project', id: string, name: string, technologies?: Array<{ __typename?: 'ProjectTechnology', technology: { __typename?: 'Technology', id: string, type: TechnologyType, name: string, colour?: string | null } }> | null } | null } | null> | null } | null };

export type UsersQueryVariables = Exact<{ [key: string]: never; }>;


export type UsersQuery = { __typename?: 'Query', users?: { __typename?: 'UserConnection', edges?: Array<{ __typename?: 'UserEdge', node?: { __typename?: 'User', id: string, username: string, avatarUrl?: string | null } | null } | null> | null } | null };

export type UsersByUsernameQueryVariables = Exact<{
  username: Scalars['String'];
}>;


export type UsersByUsernameQuery = { __typename?: 'Query', users?: { __typename?: 'UserConnection', edges?: Array<{ __typename?: 'UserEdge', node?: { __typename?: 'User', id: string, username: string, avatarUrl?: string | null, githubAccounts?: Array<{ __typename?: 'GithubAccount', id: string, username: string }> | null, discordAccounts?: Array<{ __typename?: 'DiscordAccount', id: string, username: string, discriminator: string }> | null, projectContributions?: Array<{ __typename?: 'ProjectContributor', role: ProjectContributorRole, project: { __typename?: 'Project', id: string, name: string, technologies?: Array<{ __typename?: 'ProjectTechnology', technology: { __typename?: 'Technology', id: string, name: string, colour?: string | null } }> | null } }> | null } | null } | null> | null } | null };

export type ProjectsQueryVariables = Exact<{ [key: string]: never; }>;


export type ProjectsQuery = { __typename?: 'Query', projects?: { __typename?: 'ProjectConnection', edges?: Array<{ __typename?: 'ProjectEdge', node?: { __typename?: 'Project', id: string, name: string, technologies?: Array<{ __typename?: 'ProjectTechnology', technology: { __typename?: 'Technology', id: string, type: TechnologyType, name: string, colour?: string | null } }> | null } | null } | null> | null } | null };

export type ProjectsByProjectIdQueryVariables = Exact<{
  projectId: Scalars['ID'];
}>;


export type ProjectsByProjectIdQuery = { __typename?: 'Query', projects?: { __typename?: 'ProjectConnection', edges?: Array<{ __typename?: 'ProjectEdge', node?: { __typename?: 'Project', id: string, name: string, description?: string | null, startDate: any, endDate?: any | null, repositories?: Array<{ __typename?: 'Repository', id: string, name: string, githubAccount?: { __typename?: 'GithubAccount', username: string } | null, githubOrganization?: { __typename?: 'GithubOrganization', name: string } | null }> | null, sites?: Array<{ __typename?: 'Site', id: string, url: string }> | null, discordBots?: Array<{ __typename?: 'DiscordBot', id: string, account: { __typename?: 'DiscordAccount', username: string, discriminator: string } }> | null, parentProjects?: Array<{ __typename?: 'ProjectAssociation', id: string, type: ProjectAssociationType, parent: { __typename?: 'Project', id: string, name: string, technologies?: Array<{ __typename?: 'ProjectTechnology', technology: { __typename?: 'Technology', id: string, name: string, colour?: string | null } }> | null } }> | null, childProjects?: Array<{ __typename?: 'ProjectAssociation', id: string, type: ProjectAssociationType, child: { __typename?: 'Project', id: string, name: string, technologies?: Array<{ __typename?: 'ProjectTechnology', technology: { __typename?: 'Technology', id: string, name: string, colour?: string | null } }> | null } }> | null, contributors?: Array<{ __typename?: 'ProjectContributor', id: string, role: ProjectContributorRole, user: { __typename?: 'User', username: string } }> | null, technologies?: Array<{ __typename?: 'ProjectTechnology', id: string, type: ProjectTechnologyAssociationType, technology: { __typename?: 'Technology', id: string, type: TechnologyType, name: string, colour?: string | null } }> | null } | null } | null> | null } | null };

export type LoginQueryVariables = Exact<{ [key: string]: never; }>;


export type LoginQuery = { __typename?: 'Query', developmentMode: boolean, availableAuthProviders?: Array<{ __typename?: 'AuthProvider', url: string, type: AuthProviderType } | null> | null, users?: { __typename?: 'UserConnection', edges?: Array<{ __typename?: 'UserEdge', node?: { __typename?: 'User', id: string, username: string } | null } | null> | null } | null };

export type AssumableUsersQueryVariables = Exact<{ [key: string]: never; }>;


export type AssumableUsersQuery = { __typename?: 'Query', users?: { __typename?: 'UserConnection', edges?: Array<{ __typename?: 'UserEdge', node?: { __typename?: 'User', id: string, username: string } | null } | null> | null } | null };

export type CurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrentUserQuery = { __typename?: 'Query', currentUser?: { __typename?: 'User', id: string, username: string, avatarUrl?: string | null } | null };


export const CreateDiscordAccountDocument = `
    mutation CreateDiscordAccount($discordId: String!, $username: String!, $discriminator: String!, $owner: Int!) {
  createDiscordAccount(
    input: {discordId: $discordId, username: $username, discriminator: $discriminator, owner: $owner}
  ) {
    id
    username
  }
}
    `;
export const useCreateDiscordAccountMutation = <
      TError = unknown,
      TContext = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      options?: UseMutationOptions<CreateDiscordAccountMutation, TError, CreateDiscordAccountMutationVariables, TContext>
    ) =>
    useMutation<CreateDiscordAccountMutation, TError, CreateDiscordAccountMutationVariables, TContext>(
      ['CreateDiscordAccount'],
      (variables?: CreateDiscordAccountMutationVariables) => fetcher<CreateDiscordAccountMutation, CreateDiscordAccountMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, CreateDiscordAccountDocument, variables)(),
      options
    );
useCreateDiscordAccountMutation.getKey = () => ['CreateDiscordAccount'];

useCreateDiscordAccountMutation.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables: CreateDiscordAccountMutationVariables) => fetcher<CreateDiscordAccountMutation, CreateDiscordAccountMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, CreateDiscordAccountDocument, variables);
export const CreateGithubAccountDocument = `
    mutation CreateGithubAccount($username: String!, $owner: Int!) {
  createGithubAccount(input: {username: $username, owner: $owner}) {
    id
    username
  }
}
    `;
export const useCreateGithubAccountMutation = <
      TError = unknown,
      TContext = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      options?: UseMutationOptions<CreateGithubAccountMutation, TError, CreateGithubAccountMutationVariables, TContext>
    ) =>
    useMutation<CreateGithubAccountMutation, TError, CreateGithubAccountMutationVariables, TContext>(
      ['CreateGithubAccount'],
      (variables?: CreateGithubAccountMutationVariables) => fetcher<CreateGithubAccountMutation, CreateGithubAccountMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, CreateGithubAccountDocument, variables)(),
      options
    );
useCreateGithubAccountMutation.getKey = () => ['CreateGithubAccount'];

useCreateGithubAccountMutation.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables: CreateGithubAccountMutationVariables) => fetcher<CreateGithubAccountMutation, CreateGithubAccountMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, CreateGithubAccountDocument, variables);
export const CreateProjectDocument = `
    mutation CreateProject($name: String!, $description: String, $startDate: Time!, $endDate: Time) {
  createProject(
    input: {name: $name, description: $description, startDate: $startDate, endDate: $endDate}
  ) {
    id
    name
    description
    startDate
    endDate
  }
}
    `;
export const useCreateProjectMutation = <
      TError = unknown,
      TContext = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      options?: UseMutationOptions<CreateProjectMutation, TError, CreateProjectMutationVariables, TContext>
    ) =>
    useMutation<CreateProjectMutation, TError, CreateProjectMutationVariables, TContext>(
      ['CreateProject'],
      (variables?: CreateProjectMutationVariables) => fetcher<CreateProjectMutation, CreateProjectMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, CreateProjectDocument, variables)(),
      options
    );
useCreateProjectMutation.getKey = () => ['CreateProject'];

useCreateProjectMutation.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables: CreateProjectMutationVariables) => fetcher<CreateProjectMutation, CreateProjectMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, CreateProjectDocument, variables);
export const CreateProjectTechnologyDocument = `
    mutation CreateProjectTechnology($type: ProjectTechnologyAssociationType!, $technology: Int!, $project: Int!) {
  createProjectTechnology(
    input: {type: $type, technology: $technology, project: $project}
  ) {
    id
    type
    technology {
      id
      name
    }
    project {
      id
      name
    }
  }
}
    `;
export const useCreateProjectTechnologyMutation = <
      TError = unknown,
      TContext = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      options?: UseMutationOptions<CreateProjectTechnologyMutation, TError, CreateProjectTechnologyMutationVariables, TContext>
    ) =>
    useMutation<CreateProjectTechnologyMutation, TError, CreateProjectTechnologyMutationVariables, TContext>(
      ['CreateProjectTechnology'],
      (variables?: CreateProjectTechnologyMutationVariables) => fetcher<CreateProjectTechnologyMutation, CreateProjectTechnologyMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, CreateProjectTechnologyDocument, variables)(),
      options
    );
useCreateProjectTechnologyMutation.getKey = () => ['CreateProjectTechnology'];

useCreateProjectTechnologyMutation.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables: CreateProjectTechnologyMutationVariables) => fetcher<CreateProjectTechnologyMutation, CreateProjectTechnologyMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, CreateProjectTechnologyDocument, variables);
export const CreateUserDocument = `
    mutation CreateUser($username: String!, $avatarUrl: String) {
  createUser(input: {username: $username, avatarUrl: $avatarUrl}) {
    id
    username
    avatarUrl
  }
}
    `;
export const useCreateUserMutation = <
      TError = unknown,
      TContext = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      options?: UseMutationOptions<CreateUserMutation, TError, CreateUserMutationVariables, TContext>
    ) =>
    useMutation<CreateUserMutation, TError, CreateUserMutationVariables, TContext>(
      ['CreateUser'],
      (variables?: CreateUserMutationVariables) => fetcher<CreateUserMutation, CreateUserMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, CreateUserDocument, variables)(),
      options
    );
useCreateUserMutation.getKey = () => ['CreateUser'];

useCreateUserMutation.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables: CreateUserMutationVariables) => fetcher<CreateUserMutation, CreateUserMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, CreateUserDocument, variables);
export const DeleteUserDocument = `
    mutation DeleteUser($id: ID!) {
  deleteUser(id: $id) {
    id
  }
}
    `;
export const useDeleteUserMutation = <
      TError = unknown,
      TContext = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      options?: UseMutationOptions<DeleteUserMutation, TError, DeleteUserMutationVariables, TContext>
    ) =>
    useMutation<DeleteUserMutation, TError, DeleteUserMutationVariables, TContext>(
      ['DeleteUser'],
      (variables?: DeleteUserMutationVariables) => fetcher<DeleteUserMutation, DeleteUserMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, DeleteUserDocument, variables)(),
      options
    );
useDeleteUserMutation.getKey = () => ['DeleteUser'];

useDeleteUserMutation.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables: DeleteUserMutationVariables) => fetcher<DeleteUserMutation, DeleteUserMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, DeleteUserDocument, variables);
export const DeleteDiscordAccountDocument = `
    mutation DeleteDiscordAccount($id: ID!) {
  deleteDiscordAccount(id: $id) {
    id
  }
}
    `;
export const useDeleteDiscordAccountMutation = <
      TError = unknown,
      TContext = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      options?: UseMutationOptions<DeleteDiscordAccountMutation, TError, DeleteDiscordAccountMutationVariables, TContext>
    ) =>
    useMutation<DeleteDiscordAccountMutation, TError, DeleteDiscordAccountMutationVariables, TContext>(
      ['DeleteDiscordAccount'],
      (variables?: DeleteDiscordAccountMutationVariables) => fetcher<DeleteDiscordAccountMutation, DeleteDiscordAccountMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, DeleteDiscordAccountDocument, variables)(),
      options
    );
useDeleteDiscordAccountMutation.getKey = () => ['DeleteDiscordAccount'];

useDeleteDiscordAccountMutation.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables: DeleteDiscordAccountMutationVariables) => fetcher<DeleteDiscordAccountMutation, DeleteDiscordAccountMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, DeleteDiscordAccountDocument, variables);
export const DeleteGithubAccountDocument = `
    mutation DeleteGithubAccount($id: ID!) {
  deleteGithubAccount(id: $id) {
    id
  }
}
    `;
export const useDeleteGithubAccountMutation = <
      TError = unknown,
      TContext = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      options?: UseMutationOptions<DeleteGithubAccountMutation, TError, DeleteGithubAccountMutationVariables, TContext>
    ) =>
    useMutation<DeleteGithubAccountMutation, TError, DeleteGithubAccountMutationVariables, TContext>(
      ['DeleteGithubAccount'],
      (variables?: DeleteGithubAccountMutationVariables) => fetcher<DeleteGithubAccountMutation, DeleteGithubAccountMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, DeleteGithubAccountDocument, variables)(),
      options
    );
useDeleteGithubAccountMutation.getKey = () => ['DeleteGithubAccount'];

useDeleteGithubAccountMutation.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables: DeleteGithubAccountMutationVariables) => fetcher<DeleteGithubAccountMutation, DeleteGithubAccountMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, DeleteGithubAccountDocument, variables);
export const DeleteProjectDocument = `
    mutation DeleteProject($id: ID!) {
  deleteProject(id: $id) {
    id
  }
}
    `;
export const useDeleteProjectMutation = <
      TError = unknown,
      TContext = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      options?: UseMutationOptions<DeleteProjectMutation, TError, DeleteProjectMutationVariables, TContext>
    ) =>
    useMutation<DeleteProjectMutation, TError, DeleteProjectMutationVariables, TContext>(
      ['DeleteProject'],
      (variables?: DeleteProjectMutationVariables) => fetcher<DeleteProjectMutation, DeleteProjectMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, DeleteProjectDocument, variables)(),
      options
    );
useDeleteProjectMutation.getKey = () => ['DeleteProject'];

useDeleteProjectMutation.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables: DeleteProjectMutationVariables) => fetcher<DeleteProjectMutation, DeleteProjectMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, DeleteProjectDocument, variables);
export const AssumeDevelopmentUserDocument = `
    mutation AssumeDevelopmentUser($id: ID!) {
  assumeDevelopmentUser(id: $id) {
    id
  }
}
    `;
export const useAssumeDevelopmentUserMutation = <
      TError = unknown,
      TContext = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      options?: UseMutationOptions<AssumeDevelopmentUserMutation, TError, AssumeDevelopmentUserMutationVariables, TContext>
    ) =>
    useMutation<AssumeDevelopmentUserMutation, TError, AssumeDevelopmentUserMutationVariables, TContext>(
      ['AssumeDevelopmentUser'],
      (variables?: AssumeDevelopmentUserMutationVariables) => fetcher<AssumeDevelopmentUserMutation, AssumeDevelopmentUserMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, AssumeDevelopmentUserDocument, variables)(),
      options
    );
useAssumeDevelopmentUserMutation.getKey = () => ['AssumeDevelopmentUser'];

useAssumeDevelopmentUserMutation.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables: AssumeDevelopmentUserMutationVariables) => fetcher<AssumeDevelopmentUserMutation, AssumeDevelopmentUserMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, AssumeDevelopmentUserDocument, variables);
export const HomepageDocument = `
    query Homepage {
  users {
    edges {
      node {
        id
        username
        avatarUrl
      }
    }
  }
  projects {
    edges {
      node {
        id
        name
        technologies {
          technology {
            id
            type
            name
            colour
          }
        }
      }
    }
  }
}
    `;
export const useHomepageQuery = <
      TData = HomepageQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables?: HomepageQueryVariables,
      options?: UseQueryOptions<HomepageQuery, TError, TData>
    ) =>
    useQuery<HomepageQuery, TError, TData>(
      variables === undefined ? ['Homepage'] : ['Homepage', variables],
      fetcher<HomepageQuery, HomepageQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, HomepageDocument, variables),
      options
    );

useHomepageQuery.getKey = (variables?: HomepageQueryVariables) => variables === undefined ? ['Homepage'] : ['Homepage', variables];
;

useHomepageQuery.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables?: HomepageQueryVariables) => fetcher<HomepageQuery, HomepageQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, HomepageDocument, variables);
export const UsersDocument = `
    query Users {
  users {
    edges {
      node {
        id
        username
        avatarUrl
      }
    }
  }
}
    `;
export const useUsersQuery = <
      TData = UsersQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables?: UsersQueryVariables,
      options?: UseQueryOptions<UsersQuery, TError, TData>
    ) =>
    useQuery<UsersQuery, TError, TData>(
      variables === undefined ? ['Users'] : ['Users', variables],
      fetcher<UsersQuery, UsersQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, UsersDocument, variables),
      options
    );

useUsersQuery.getKey = (variables?: UsersQueryVariables) => variables === undefined ? ['Users'] : ['Users', variables];
;

useUsersQuery.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables?: UsersQueryVariables) => fetcher<UsersQuery, UsersQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, UsersDocument, variables);
export const UsersByUsernameDocument = `
    query UsersByUsername($username: String!) {
  users(where: {username: $username}) {
    edges {
      node {
        id
        username
        avatarUrl
        githubAccounts {
          id
          username
        }
        discordAccounts {
          id
          username
          discriminator
        }
        projectContributions {
          role
          project {
            id
            name
            technologies {
              technology {
                id
                name
                colour
              }
            }
          }
        }
      }
    }
  }
}
    `;
export const useUsersByUsernameQuery = <
      TData = UsersByUsernameQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables: UsersByUsernameQueryVariables,
      options?: UseQueryOptions<UsersByUsernameQuery, TError, TData>
    ) =>
    useQuery<UsersByUsernameQuery, TError, TData>(
      ['UsersByUsername', variables],
      fetcher<UsersByUsernameQuery, UsersByUsernameQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, UsersByUsernameDocument, variables),
      options
    );

useUsersByUsernameQuery.getKey = (variables: UsersByUsernameQueryVariables) => ['UsersByUsername', variables];
;

useUsersByUsernameQuery.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables: UsersByUsernameQueryVariables) => fetcher<UsersByUsernameQuery, UsersByUsernameQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, UsersByUsernameDocument, variables);
export const ProjectsDocument = `
    query Projects {
  projects {
    edges {
      node {
        id
        name
        technologies {
          technology {
            id
            type
            name
            colour
          }
        }
      }
    }
  }
}
    `;
export const useProjectsQuery = <
      TData = ProjectsQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables?: ProjectsQueryVariables,
      options?: UseQueryOptions<ProjectsQuery, TError, TData>
    ) =>
    useQuery<ProjectsQuery, TError, TData>(
      variables === undefined ? ['Projects'] : ['Projects', variables],
      fetcher<ProjectsQuery, ProjectsQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, ProjectsDocument, variables),
      options
    );

useProjectsQuery.getKey = (variables?: ProjectsQueryVariables) => variables === undefined ? ['Projects'] : ['Projects', variables];
;

useProjectsQuery.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables?: ProjectsQueryVariables) => fetcher<ProjectsQuery, ProjectsQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, ProjectsDocument, variables);
export const ProjectsByProjectIdDocument = `
    query ProjectsByProjectId($projectId: ID!) {
  projects(where: {id: $projectId}) {
    edges {
      node {
        id
        name
        description
        startDate
        endDate
        repositories {
          id
          name
          githubAccount {
            username
          }
          githubOrganization {
            name
          }
        }
        sites {
          id
          url
        }
        discordBots {
          id
          account {
            username
            discriminator
          }
        }
        parentProjects {
          id
          type
          parent {
            id
            name
            technologies {
              technology {
                id
                name
                colour
              }
            }
          }
        }
        childProjects {
          id
          type
          child {
            id
            name
            technologies {
              technology {
                id
                name
                colour
              }
            }
          }
        }
        contributors {
          id
          role
          user {
            username
          }
        }
        technologies {
          id
          type
          technology {
            id
            type
            name
            colour
          }
        }
      }
    }
  }
}
    `;
export const useProjectsByProjectIdQuery = <
      TData = ProjectsByProjectIdQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables: ProjectsByProjectIdQueryVariables,
      options?: UseQueryOptions<ProjectsByProjectIdQuery, TError, TData>
    ) =>
    useQuery<ProjectsByProjectIdQuery, TError, TData>(
      ['ProjectsByProjectId', variables],
      fetcher<ProjectsByProjectIdQuery, ProjectsByProjectIdQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, ProjectsByProjectIdDocument, variables),
      options
    );

useProjectsByProjectIdQuery.getKey = (variables: ProjectsByProjectIdQueryVariables) => ['ProjectsByProjectId', variables];
;

useProjectsByProjectIdQuery.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables: ProjectsByProjectIdQueryVariables) => fetcher<ProjectsByProjectIdQuery, ProjectsByProjectIdQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, ProjectsByProjectIdDocument, variables);
export const LoginDocument = `
    query Login {
  availableAuthProviders {
    url
    type
  }
  developmentMode
  users {
    edges {
      node {
        id
        username
      }
    }
  }
}
    `;
export const useLoginQuery = <
      TData = LoginQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables?: LoginQueryVariables,
      options?: UseQueryOptions<LoginQuery, TError, TData>
    ) =>
    useQuery<LoginQuery, TError, TData>(
      variables === undefined ? ['Login'] : ['Login', variables],
      fetcher<LoginQuery, LoginQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, LoginDocument, variables),
      options
    );

useLoginQuery.getKey = (variables?: LoginQueryVariables) => variables === undefined ? ['Login'] : ['Login', variables];
;

useLoginQuery.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables?: LoginQueryVariables) => fetcher<LoginQuery, LoginQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, LoginDocument, variables);
export const AssumableUsersDocument = `
    query AssumableUsers {
  users {
    edges {
      node {
        id
        username
      }
    }
  }
}
    `;
export const useAssumableUsersQuery = <
      TData = AssumableUsersQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables?: AssumableUsersQueryVariables,
      options?: UseQueryOptions<AssumableUsersQuery, TError, TData>
    ) =>
    useQuery<AssumableUsersQuery, TError, TData>(
      variables === undefined ? ['AssumableUsers'] : ['AssumableUsers', variables],
      fetcher<AssumableUsersQuery, AssumableUsersQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, AssumableUsersDocument, variables),
      options
    );

useAssumableUsersQuery.getKey = (variables?: AssumableUsersQueryVariables) => variables === undefined ? ['AssumableUsers'] : ['AssumableUsers', variables];
;

useAssumableUsersQuery.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables?: AssumableUsersQueryVariables) => fetcher<AssumableUsersQuery, AssumableUsersQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, AssumableUsersDocument, variables);
export const CurrentUserDocument = `
    query CurrentUser {
  currentUser {
    id
    username
    avatarUrl
  }
}
    `;
export const useCurrentUserQuery = <
      TData = CurrentUserQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables?: CurrentUserQueryVariables,
      options?: UseQueryOptions<CurrentUserQuery, TError, TData>
    ) =>
    useQuery<CurrentUserQuery, TError, TData>(
      variables === undefined ? ['CurrentUser'] : ['CurrentUser', variables],
      fetcher<CurrentUserQuery, CurrentUserQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, CurrentUserDocument, variables),
      options
    );

useCurrentUserQuery.getKey = (variables?: CurrentUserQueryVariables) => variables === undefined ? ['CurrentUser'] : ['CurrentUser', variables];
;

useCurrentUserQuery.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables?: CurrentUserQueryVariables) => fetcher<CurrentUserQuery, CurrentUserQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, CurrentUserDocument, variables);